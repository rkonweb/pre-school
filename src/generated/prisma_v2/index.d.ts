
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model Admission
 * 
 */
export type Admission = $Result.DefaultSelection<Prisma.$AdmissionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model LeavePolicy
 * 
 */
export type LeavePolicy = $Result.DefaultSelection<Prisma.$LeavePolicyPayload>
/**
 * Model LeaveType
 * 
 */
export type LeaveType = $Result.DefaultSelection<Prisma.$LeaveTypePayload>
/**
 * Model LeaveBalance
 * 
 */
export type LeaveBalance = $Result.DefaultSelection<Prisma.$LeaveBalancePayload>
/**
 * Model SalaryRevision
 * 
 */
export type SalaryRevision = $Result.DefaultSelection<Prisma.$SalaryRevisionPayload>
/**
 * Model Classroom
 * 
 */
export type Classroom = $Result.DefaultSelection<Prisma.$ClassroomPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Fee
 * 
 */
export type Fee = $Result.DefaultSelection<Prisma.$FeePayload>
/**
 * Model FeePayment
 * 
 */
export type FeePayment = $Result.DefaultSelection<Prisma.$FeePaymentPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model ReportCard
 * 
 */
export type ReportCard = $Result.DefaultSelection<Prisma.$ReportCardPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model MasterData
 * 
 */
export type MasterData = $Result.DefaultSelection<Prisma.$MasterDataPayload>
/**
 * Model StaffAttendance
 * 
 */
export type StaffAttendance = $Result.DefaultSelection<Prisma.$StaffAttendancePayload>
/**
 * Model StaffPunch
 * 
 */
export type StaffPunch = $Result.DefaultSelection<Prisma.$StaffPunchPayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model FeeStructure
 * 
 */
export type FeeStructure = $Result.DefaultSelection<Prisma.$FeeStructurePayload>
/**
 * Model FeeComponent
 * 
 */
export type FeeComponent = $Result.DefaultSelection<Prisma.$FeeComponentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Schools
 * const schools = await prisma.school.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Schools
   * const schools = await prisma.school.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs>;

  /**
   * `prisma.admission`: Exposes CRUD operations for the **Admission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admission.findMany()
    * ```
    */
  get admission(): Prisma.AdmissionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.leavePolicy`: Exposes CRUD operations for the **LeavePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeavePolicies
    * const leavePolicies = await prisma.leavePolicy.findMany()
    * ```
    */
  get leavePolicy(): Prisma.LeavePolicyDelegate<ExtArgs>;

  /**
   * `prisma.leaveType`: Exposes CRUD operations for the **LeaveType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveTypes
    * const leaveTypes = await prisma.leaveType.findMany()
    * ```
    */
  get leaveType(): Prisma.LeaveTypeDelegate<ExtArgs>;

  /**
   * `prisma.leaveBalance`: Exposes CRUD operations for the **LeaveBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveBalances
    * const leaveBalances = await prisma.leaveBalance.findMany()
    * ```
    */
  get leaveBalance(): Prisma.LeaveBalanceDelegate<ExtArgs>;

  /**
   * `prisma.salaryRevision`: Exposes CRUD operations for the **SalaryRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryRevisions
    * const salaryRevisions = await prisma.salaryRevision.findMany()
    * ```
    */
  get salaryRevision(): Prisma.SalaryRevisionDelegate<ExtArgs>;

  /**
   * `prisma.classroom`: Exposes CRUD operations for the **Classroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classrooms
    * const classrooms = await prisma.classroom.findMany()
    * ```
    */
  get classroom(): Prisma.ClassroomDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.fee`: Exposes CRUD operations for the **Fee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fees
    * const fees = await prisma.fee.findMany()
    * ```
    */
  get fee(): Prisma.FeeDelegate<ExtArgs>;

  /**
   * `prisma.feePayment`: Exposes CRUD operations for the **FeePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeePayments
    * const feePayments = await prisma.feePayment.findMany()
    * ```
    */
  get feePayment(): Prisma.FeePaymentDelegate<ExtArgs>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs>;

  /**
   * `prisma.reportCard`: Exposes CRUD operations for the **ReportCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportCards
    * const reportCards = await prisma.reportCard.findMany()
    * ```
    */
  get reportCard(): Prisma.ReportCardDelegate<ExtArgs>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.masterData`: Exposes CRUD operations for the **MasterData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterData
    * const masterData = await prisma.masterData.findMany()
    * ```
    */
  get masterData(): Prisma.MasterDataDelegate<ExtArgs>;

  /**
   * `prisma.staffAttendance`: Exposes CRUD operations for the **StaffAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffAttendances
    * const staffAttendances = await prisma.staffAttendance.findMany()
    * ```
    */
  get staffAttendance(): Prisma.StaffAttendanceDelegate<ExtArgs>;

  /**
   * `prisma.staffPunch`: Exposes CRUD operations for the **StaffPunch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffPunches
    * const staffPunches = await prisma.staffPunch.findMany()
    * ```
    */
  get staffPunch(): Prisma.StaffPunchDelegate<ExtArgs>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs>;

  /**
   * `prisma.feeStructure`: Exposes CRUD operations for the **FeeStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeStructures
    * const feeStructures = await prisma.feeStructure.findMany()
    * ```
    */
  get feeStructure(): Prisma.FeeStructureDelegate<ExtArgs>;

  /**
   * `prisma.feeComponent`: Exposes CRUD operations for the **FeeComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeComponents
    * const feeComponents = await prisma.feeComponent.findMany()
    * ```
    */
  get feeComponent(): Prisma.FeeComponentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    School: 'School',
    Admission: 'Admission',
    User: 'User',
    LeavePolicy: 'LeavePolicy',
    LeaveType: 'LeaveType',
    LeaveBalance: 'LeaveBalance',
    SalaryRevision: 'SalaryRevision',
    Classroom: 'Classroom',
    Student: 'Student',
    Fee: 'Fee',
    FeePayment: 'FeePayment',
    Attendance: 'Attendance',
    ReportCard: 'ReportCard',
    Otp: 'Otp',
    Subscription: 'Subscription',
    MasterData: 'MasterData',
    StaffAttendance: 'StaffAttendance',
    StaffPunch: 'StaffPunch',
    LeaveRequest: 'LeaveRequest',
    FeeStructure: 'FeeStructure',
    FeeComponent: 'FeeComponent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'school' | 'admission' | 'user' | 'leavePolicy' | 'leaveType' | 'leaveBalance' | 'salaryRevision' | 'classroom' | 'student' | 'fee' | 'feePayment' | 'attendance' | 'reportCard' | 'otp' | 'subscription' | 'masterData' | 'staffAttendance' | 'staffPunch' | 'leaveRequest' | 'feeStructure' | 'feeComponent'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>,
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      Admission: {
        payload: Prisma.$AdmissionPayload<ExtArgs>
        fields: Prisma.AdmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findFirst: {
            args: Prisma.AdmissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findMany: {
            args: Prisma.AdmissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          create: {
            args: Prisma.AdmissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          delete: {
            args: Prisma.AdmissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          update: {
            args: Prisma.AdmissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          aggregate: {
            args: Prisma.AdmissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmission>
          }
          groupBy: {
            args: Prisma.AdmissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionCountArgs<ExtArgs>,
            result: $Utils.Optional<AdmissionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      LeavePolicy: {
        payload: Prisma.$LeavePolicyPayload<ExtArgs>
        fields: Prisma.LeavePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeavePolicyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeavePolicyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          findFirst: {
            args: Prisma.LeavePolicyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeavePolicyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          findMany: {
            args: Prisma.LeavePolicyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>[]
          }
          create: {
            args: Prisma.LeavePolicyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          delete: {
            args: Prisma.LeavePolicyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          update: {
            args: Prisma.LeavePolicyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          deleteMany: {
            args: Prisma.LeavePolicyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeavePolicyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeavePolicyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          aggregate: {
            args: Prisma.LeavePolicyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeavePolicy>
          }
          groupBy: {
            args: Prisma.LeavePolicyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeavePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeavePolicyCountArgs<ExtArgs>,
            result: $Utils.Optional<LeavePolicyCountAggregateOutputType> | number
          }
        }
      }
      LeaveType: {
        payload: Prisma.$LeaveTypePayload<ExtArgs>
        fields: Prisma.LeaveTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findFirst: {
            args: Prisma.LeaveTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findMany: {
            args: Prisma.LeaveTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          create: {
            args: Prisma.LeaveTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          delete: {
            args: Prisma.LeaveTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          update: {
            args: Prisma.LeaveTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          deleteMany: {
            args: Prisma.LeaveTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaveTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          aggregate: {
            args: Prisma.LeaveTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaveType>
          }
          groupBy: {
            args: Prisma.LeaveTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaveTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaveTypeCountAggregateOutputType> | number
          }
        }
      }
      LeaveBalance: {
        payload: Prisma.$LeaveBalancePayload<ExtArgs>
        fields: Prisma.LeaveBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveBalanceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findFirst: {
            args: Prisma.LeaveBalanceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveBalanceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findMany: {
            args: Prisma.LeaveBalanceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          create: {
            args: Prisma.LeaveBalanceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          delete: {
            args: Prisma.LeaveBalanceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          update: {
            args: Prisma.LeaveBalanceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          deleteMany: {
            args: Prisma.LeaveBalanceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveBalanceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaveBalanceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          aggregate: {
            args: Prisma.LeaveBalanceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaveBalance>
          }
          groupBy: {
            args: Prisma.LeaveBalanceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaveBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveBalanceCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaveBalanceCountAggregateOutputType> | number
          }
        }
      }
      SalaryRevision: {
        payload: Prisma.$SalaryRevisionPayload<ExtArgs>
        fields: Prisma.SalaryRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryRevisionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryRevisionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload>
          }
          findFirst: {
            args: Prisma.SalaryRevisionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryRevisionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload>
          }
          findMany: {
            args: Prisma.SalaryRevisionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload>[]
          }
          create: {
            args: Prisma.SalaryRevisionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload>
          }
          delete: {
            args: Prisma.SalaryRevisionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload>
          }
          update: {
            args: Prisma.SalaryRevisionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload>
          }
          deleteMany: {
            args: Prisma.SalaryRevisionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryRevisionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SalaryRevisionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalaryRevisionPayload>
          }
          aggregate: {
            args: Prisma.SalaryRevisionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSalaryRevision>
          }
          groupBy: {
            args: Prisma.SalaryRevisionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SalaryRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryRevisionCountArgs<ExtArgs>,
            result: $Utils.Optional<SalaryRevisionCountAggregateOutputType> | number
          }
        }
      }
      Classroom: {
        payload: Prisma.$ClassroomPayload<ExtArgs>
        fields: Prisma.ClassroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findFirst: {
            args: Prisma.ClassroomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findMany: {
            args: Prisma.ClassroomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          create: {
            args: Prisma.ClassroomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          delete: {
            args: Prisma.ClassroomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          update: {
            args: Prisma.ClassroomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClassroomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          aggregate: {
            args: Prisma.ClassroomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClassroom>
          }
          groupBy: {
            args: Prisma.ClassroomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClassroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomCountArgs<ExtArgs>,
            result: $Utils.Optional<ClassroomCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Fee: {
        payload: Prisma.$FeePayload<ExtArgs>
        fields: Prisma.FeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          findFirst: {
            args: Prisma.FeeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          findMany: {
            args: Prisma.FeeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload>[]
          }
          create: {
            args: Prisma.FeeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          delete: {
            args: Prisma.FeeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          update: {
            args: Prisma.FeeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          deleteMany: {
            args: Prisma.FeeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          aggregate: {
            args: Prisma.FeeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFee>
          }
          groupBy: {
            args: Prisma.FeeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeCountArgs<ExtArgs>,
            result: $Utils.Optional<FeeCountAggregateOutputType> | number
          }
        }
      }
      FeePayment: {
        payload: Prisma.$FeePaymentPayload<ExtArgs>
        fields: Prisma.FeePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeePaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeePaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findFirst: {
            args: Prisma.FeePaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeePaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findMany: {
            args: Prisma.FeePaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          create: {
            args: Prisma.FeePaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          delete: {
            args: Prisma.FeePaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          update: {
            args: Prisma.FeePaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          deleteMany: {
            args: Prisma.FeePaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeePaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeePaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          aggregate: {
            args: Prisma.FeePaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeePayment>
          }
          groupBy: {
            args: Prisma.FeePaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeePaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<FeePaymentCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>,
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      ReportCard: {
        payload: Prisma.$ReportCardPayload<ExtArgs>
        fields: Prisma.ReportCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportCardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportCardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findFirst: {
            args: Prisma.ReportCardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportCardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findMany: {
            args: Prisma.ReportCardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          create: {
            args: Prisma.ReportCardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          delete: {
            args: Prisma.ReportCardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          update: {
            args: Prisma.ReportCardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          deleteMany: {
            args: Prisma.ReportCardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportCardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportCardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          aggregate: {
            args: Prisma.ReportCardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReportCard>
          }
          groupBy: {
            args: Prisma.ReportCardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCardCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCardCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>,
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      MasterData: {
        payload: Prisma.$MasterDataPayload<ExtArgs>
        fields: Prisma.MasterDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload>
          }
          findFirst: {
            args: Prisma.MasterDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload>
          }
          findMany: {
            args: Prisma.MasterDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload>[]
          }
          create: {
            args: Prisma.MasterDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload>
          }
          delete: {
            args: Prisma.MasterDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload>
          }
          update: {
            args: Prisma.MasterDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload>
          }
          deleteMany: {
            args: Prisma.MasterDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MasterDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MasterDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterDataPayload>
          }
          aggregate: {
            args: Prisma.MasterDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMasterData>
          }
          groupBy: {
            args: Prisma.MasterDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MasterDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterDataCountArgs<ExtArgs>,
            result: $Utils.Optional<MasterDataCountAggregateOutputType> | number
          }
        }
      }
      StaffAttendance: {
        payload: Prisma.$StaffAttendancePayload<ExtArgs>
        fields: Prisma.StaffAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffAttendanceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffAttendanceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          findFirst: {
            args: Prisma.StaffAttendanceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffAttendanceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          findMany: {
            args: Prisma.StaffAttendanceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>[]
          }
          create: {
            args: Prisma.StaffAttendanceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          delete: {
            args: Prisma.StaffAttendanceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          update: {
            args: Prisma.StaffAttendanceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          deleteMany: {
            args: Prisma.StaffAttendanceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffAttendanceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffAttendanceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          aggregate: {
            args: Prisma.StaffAttendanceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaffAttendance>
          }
          groupBy: {
            args: Prisma.StaffAttendanceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffAttendanceCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffAttendanceCountAggregateOutputType> | number
          }
        }
      }
      StaffPunch: {
        payload: Prisma.$StaffPunchPayload<ExtArgs>
        fields: Prisma.StaffPunchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffPunchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffPunchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload>
          }
          findFirst: {
            args: Prisma.StaffPunchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffPunchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload>
          }
          findMany: {
            args: Prisma.StaffPunchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload>[]
          }
          create: {
            args: Prisma.StaffPunchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload>
          }
          delete: {
            args: Prisma.StaffPunchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload>
          }
          update: {
            args: Prisma.StaffPunchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload>
          }
          deleteMany: {
            args: Prisma.StaffPunchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffPunchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffPunchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffPunchPayload>
          }
          aggregate: {
            args: Prisma.StaffPunchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaffPunch>
          }
          groupBy: {
            args: Prisma.StaffPunchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffPunchGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffPunchCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffPunchCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      FeeStructure: {
        payload: Prisma.$FeeStructurePayload<ExtArgs>
        fields: Prisma.FeeStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeStructureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeStructureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findFirst: {
            args: Prisma.FeeStructureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeStructureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findMany: {
            args: Prisma.FeeStructureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          create: {
            args: Prisma.FeeStructureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          delete: {
            args: Prisma.FeeStructureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          update: {
            args: Prisma.FeeStructureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          deleteMany: {
            args: Prisma.FeeStructureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeeStructureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeeStructureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          aggregate: {
            args: Prisma.FeeStructureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeeStructure>
          }
          groupBy: {
            args: Prisma.FeeStructureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeeStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeStructureCountArgs<ExtArgs>,
            result: $Utils.Optional<FeeStructureCountAggregateOutputType> | number
          }
        }
      }
      FeeComponent: {
        payload: Prisma.$FeeComponentPayload<ExtArgs>
        fields: Prisma.FeeComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeComponentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeComponentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload>
          }
          findFirst: {
            args: Prisma.FeeComponentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeComponentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload>
          }
          findMany: {
            args: Prisma.FeeComponentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload>[]
          }
          create: {
            args: Prisma.FeeComponentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload>
          }
          delete: {
            args: Prisma.FeeComponentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload>
          }
          update: {
            args: Prisma.FeeComponentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload>
          }
          deleteMany: {
            args: Prisma.FeeComponentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeeComponentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeeComponentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeeComponentPayload>
          }
          aggregate: {
            args: Prisma.FeeComponentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeeComponent>
          }
          groupBy: {
            args: Prisma.FeeComponentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeeComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeComponentCountArgs<ExtArgs>,
            result: $Utils.Optional<FeeComponentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
    students: number
    classrooms: number
    admissions: number
    leavePolicies: number
    feeStructures: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    students?: boolean | SchoolCountOutputTypeCountStudentsArgs
    classrooms?: boolean | SchoolCountOutputTypeCountClassroomsArgs
    admissions?: boolean | SchoolCountOutputTypeCountAdmissionsArgs
    leavePolicies?: boolean | SchoolCountOutputTypeCountLeavePoliciesArgs
    feeStructures?: boolean | SchoolCountOutputTypeCountFeeStructuresArgs
  }

  // Custom InputTypes

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountLeavePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeavePolicyWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    managedClassrooms: number
    staffAttendance: number
    leaveRequests: number
    salaryRevisions: number
    leaveBalances: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    managedClassrooms?: boolean | UserCountOutputTypeCountManagedClassroomsArgs
    staffAttendance?: boolean | UserCountOutputTypeCountStaffAttendanceArgs
    leaveRequests?: boolean | UserCountOutputTypeCountLeaveRequestsArgs
    salaryRevisions?: boolean | UserCountOutputTypeCountSalaryRevisionsArgs
    leaveBalances?: boolean | UserCountOutputTypeCountLeaveBalancesArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffAttendanceWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRevisionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
  }



  /**
   * Count Type LeavePolicyCountOutputType
   */

  export type LeavePolicyCountOutputType = {
    leaveTypes: number
  }

  export type LeavePolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveTypes?: boolean | LeavePolicyCountOutputTypeCountLeaveTypesArgs
  }

  // Custom InputTypes

  /**
   * LeavePolicyCountOutputType without action
   */
  export type LeavePolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicyCountOutputType
     */
    select?: LeavePolicyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LeavePolicyCountOutputType without action
   */
  export type LeavePolicyCountOutputTypeCountLeaveTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
  }



  /**
   * Count Type LeaveTypeCountOutputType
   */

  export type LeaveTypeCountOutputType = {
    leaveBalances: number
  }

  export type LeaveTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveBalances?: boolean | LeaveTypeCountOutputTypeCountLeaveBalancesArgs
  }

  // Custom InputTypes

  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveTypeCountOutputType
     */
    select?: LeaveTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeCountLeaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
  }



  /**
   * Count Type ClassroomCountOutputType
   */

  export type ClassroomCountOutputType = {
    students: number
  }

  export type ClassroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | ClassroomCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomCountOutputType
     */
    select?: ClassroomCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }



  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    attendance: number
    reports: number
    fees: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | StudentCountOutputTypeCountAttendanceArgs
    reports?: boolean | StudentCountOutputTypeCountReportsArgs
    fees?: boolean | StudentCountOutputTypeCountFeesArgs
  }

  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
  }



  /**
   * Count Type FeeCountOutputType
   */

  export type FeeCountOutputType = {
    payments: number
  }

  export type FeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | FeeCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes

  /**
   * FeeCountOutputType without action
   */
  export type FeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCountOutputType
     */
    select?: FeeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FeeCountOutputType without action
   */
  export type FeeCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
  }



  /**
   * Count Type MasterDataCountOutputType
   */

  export type MasterDataCountOutputType = {
    children: number
  }

  export type MasterDataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | MasterDataCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes

  /**
   * MasterDataCountOutputType without action
   */
  export type MasterDataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDataCountOutputType
     */
    select?: MasterDataCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MasterDataCountOutputType without action
   */
  export type MasterDataCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterDataWhereInput
  }



  /**
   * Count Type StaffAttendanceCountOutputType
   */

  export type StaffAttendanceCountOutputType = {
    punches: number
  }

  export type StaffAttendanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    punches?: boolean | StaffAttendanceCountOutputTypeCountPunchesArgs
  }

  // Custom InputTypes

  /**
   * StaffAttendanceCountOutputType without action
   */
  export type StaffAttendanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendanceCountOutputType
     */
    select?: StaffAttendanceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StaffAttendanceCountOutputType without action
   */
  export type StaffAttendanceCountOutputTypeCountPunchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffPunchWhereInput
  }



  /**
   * Count Type FeeStructureCountOutputType
   */

  export type FeeStructureCountOutputType = {
    components: number
  }

  export type FeeStructureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    components?: boolean | FeeStructureCountOutputTypeCountComponentsArgs
  }

  // Custom InputTypes

  /**
   * FeeStructureCountOutputType without action
   */
  export type FeeStructureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructureCountOutputType
     */
    select?: FeeStructureCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FeeStructureCountOutputType without action
   */
  export type FeeStructureCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeComponentWhereInput
  }



  /**
   * Models
   */

  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    latitude: string | null
    longitude: string | null
    phone: string | null
    email: string | null
    website: string | null
    motto: string | null
    foundingYear: string | null
    logo: string | null
    brandColor: string | null
    facebook: string | null
    twitter: string | null
    linkedin: string | null
    instagram: string | null
    youtube: string | null
    currency: string | null
    timezone: string | null
    dateFormat: string | null
    googleMapsApiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    latitude: string | null
    longitude: string | null
    phone: string | null
    email: string | null
    website: string | null
    motto: string | null
    foundingYear: string | null
    logo: string | null
    brandColor: string | null
    facebook: string | null
    twitter: string | null
    linkedin: string | null
    instagram: string | null
    youtube: string | null
    currency: string | null
    timezone: string | null
    dateFormat: string | null
    googleMapsApiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    address: number
    city: number
    state: number
    zip: number
    country: number
    latitude: number
    longitude: number
    phone: number
    email: number
    website: number
    motto: number
    foundingYear: number
    logo: number
    brandColor: number
    facebook: number
    twitter: number
    linkedin: number
    instagram: number
    youtube: number
    currency: number
    timezone: number
    dateFormat: number
    googleMapsApiKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    latitude?: true
    longitude?: true
    phone?: true
    email?: true
    website?: true
    motto?: true
    foundingYear?: true
    logo?: true
    brandColor?: true
    facebook?: true
    twitter?: true
    linkedin?: true
    instagram?: true
    youtube?: true
    currency?: true
    timezone?: true
    dateFormat?: true
    googleMapsApiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    latitude?: true
    longitude?: true
    phone?: true
    email?: true
    website?: true
    motto?: true
    foundingYear?: true
    logo?: true
    brandColor?: true
    facebook?: true
    twitter?: true
    linkedin?: true
    instagram?: true
    youtube?: true
    currency?: true
    timezone?: true
    dateFormat?: true
    googleMapsApiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    latitude?: true
    longitude?: true
    phone?: true
    email?: true
    website?: true
    motto?: true
    foundingYear?: true
    logo?: true
    brandColor?: true
    facebook?: true
    twitter?: true
    linkedin?: true
    instagram?: true
    youtube?: true
    currency?: true
    timezone?: true
    dateFormat?: true
    googleMapsApiKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    slug: string
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    latitude: string | null
    longitude: string | null
    phone: string | null
    email: string | null
    website: string | null
    motto: string | null
    foundingYear: string | null
    logo: string | null
    brandColor: string | null
    facebook: string | null
    twitter: string | null
    linkedin: string | null
    instagram: string | null
    youtube: string | null
    currency: string | null
    timezone: string | null
    dateFormat: string | null
    googleMapsApiKey: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    motto?: boolean
    foundingYear?: boolean
    logo?: boolean
    brandColor?: boolean
    facebook?: boolean
    twitter?: boolean
    linkedin?: boolean
    instagram?: boolean
    youtube?: boolean
    currency?: boolean
    timezone?: boolean
    dateFormat?: boolean
    googleMapsApiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | School$usersArgs<ExtArgs>
    students?: boolean | School$studentsArgs<ExtArgs>
    classrooms?: boolean | School$classroomsArgs<ExtArgs>
    admissions?: boolean | School$admissionsArgs<ExtArgs>
    leavePolicies?: boolean | School$leavePoliciesArgs<ExtArgs>
    subscription?: boolean | School$subscriptionArgs<ExtArgs>
    feeStructures?: boolean | School$feeStructuresArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    motto?: boolean
    foundingYear?: boolean
    logo?: boolean
    brandColor?: boolean
    facebook?: boolean
    twitter?: boolean
    linkedin?: boolean
    instagram?: boolean
    youtube?: boolean
    currency?: boolean
    timezone?: boolean
    dateFormat?: boolean
    googleMapsApiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | School$usersArgs<ExtArgs>
    students?: boolean | School$studentsArgs<ExtArgs>
    classrooms?: boolean | School$classroomsArgs<ExtArgs>
    admissions?: boolean | School$admissionsArgs<ExtArgs>
    leavePolicies?: boolean | School$leavePoliciesArgs<ExtArgs>
    subscription?: boolean | School$subscriptionArgs<ExtArgs>
    feeStructures?: boolean | School$feeStructuresArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      classrooms: Prisma.$ClassroomPayload<ExtArgs>[]
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
      leavePolicies: Prisma.$LeavePolicyPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      feeStructures: Prisma.$FeeStructurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      address: string | null
      city: string | null
      state: string | null
      zip: string | null
      country: string | null
      latitude: string | null
      longitude: string | null
      phone: string | null
      email: string | null
      website: string | null
      motto: string | null
      foundingYear: string | null
      logo: string | null
      brandColor: string | null
      facebook: string | null
      twitter: string | null
      linkedin: string | null
      instagram: string | null
      youtube: string | null
      currency: string | null
      timezone: string | null
      dateFormat: string | null
      googleMapsApiKey: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }


  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SchoolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SchoolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SchoolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
    **/
    create<T extends SchoolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
    **/
    delete<T extends SchoolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SchoolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SchoolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SchoolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
    **/
    upsert<T extends SchoolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    students<T extends School$studentsArgs<ExtArgs> = {}>(args?: Subset<T, School$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'> | Null>;

    classrooms<T extends School$classroomsArgs<ExtArgs> = {}>(args?: Subset<T, School$classroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findMany'> | Null>;

    admissions<T extends School$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, School$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    leavePolicies<T extends School$leavePoliciesArgs<ExtArgs> = {}>(args?: Subset<T, School$leavePoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'findMany'> | Null>;

    subscription<T extends School$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, School$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    feeStructures<T extends School$feeStructuresArgs<ExtArgs> = {}>(args?: Subset<T, School$feeStructuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly slug: FieldRef<"School", 'String'>
    readonly address: FieldRef<"School", 'String'>
    readonly city: FieldRef<"School", 'String'>
    readonly state: FieldRef<"School", 'String'>
    readonly zip: FieldRef<"School", 'String'>
    readonly country: FieldRef<"School", 'String'>
    readonly latitude: FieldRef<"School", 'String'>
    readonly longitude: FieldRef<"School", 'String'>
    readonly phone: FieldRef<"School", 'String'>
    readonly email: FieldRef<"School", 'String'>
    readonly website: FieldRef<"School", 'String'>
    readonly motto: FieldRef<"School", 'String'>
    readonly foundingYear: FieldRef<"School", 'String'>
    readonly logo: FieldRef<"School", 'String'>
    readonly brandColor: FieldRef<"School", 'String'>
    readonly facebook: FieldRef<"School", 'String'>
    readonly twitter: FieldRef<"School", 'String'>
    readonly linkedin: FieldRef<"School", 'String'>
    readonly instagram: FieldRef<"School", 'String'>
    readonly youtube: FieldRef<"School", 'String'>
    readonly currency: FieldRef<"School", 'String'>
    readonly timezone: FieldRef<"School", 'String'>
    readonly dateFormat: FieldRef<"School", 'String'>
    readonly googleMapsApiKey: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }


  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }


  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }


  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }


  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * School.students
   */
  export type School$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * School.classrooms
   */
  export type School$classroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }


  /**
   * School.admissions
   */
  export type School$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }


  /**
   * School.leavePolicies
   */
  export type School$leavePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    where?: LeavePolicyWhereInput
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    cursor?: LeavePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }


  /**
   * School.subscription
   */
  export type School$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }


  /**
   * School.feeStructures
   */
  export type School$feeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    cursor?: FeeStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }


  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
  }



  /**
   * Model Admission
   */

  export type AggregateAdmission = {
    _count: AdmissionCountAggregateOutputType | null
    _avg: AdmissionAvgAggregateOutputType | null
    _sum: AdmissionSumAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  export type AdmissionAvgAggregateOutputType = {
    studentAge: number | null
    admissionFormStep: number | null
  }

  export type AdmissionSumAggregateOutputType = {
    studentAge: number | null
    admissionFormStep: number | null
  }

  export type AdmissionMinAggregateOutputType = {
    id: string | null
    studentName: string | null
    studentAge: number | null
    studentGender: string | null
    dateOfBirth: Date | null
    parentName: string | null
    parentEmail: string | null
    parentPhone: string | null
    secondaryPhone: string | null
    relationship: string | null
    fatherName: string | null
    fatherPhone: string | null
    fatherEmail: string | null
    fatherOccupation: string | null
    motherName: string | null
    motherPhone: string | null
    motherEmail: string | null
    motherOccupation: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zip: string | null
    officialStatus: string | null
    stage: string | null
    priority: string | null
    enrolledGrade: string | null
    source: string | null
    notes: string | null
    bloodGroup: string | null
    medicalConditions: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    previousSchool: string | null
    documents: string | null
    accessToken: string | null
    admissionFormStep: number | null
    dateReceived: Date | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionMaxAggregateOutputType = {
    id: string | null
    studentName: string | null
    studentAge: number | null
    studentGender: string | null
    dateOfBirth: Date | null
    parentName: string | null
    parentEmail: string | null
    parentPhone: string | null
    secondaryPhone: string | null
    relationship: string | null
    fatherName: string | null
    fatherPhone: string | null
    fatherEmail: string | null
    fatherOccupation: string | null
    motherName: string | null
    motherPhone: string | null
    motherEmail: string | null
    motherOccupation: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zip: string | null
    officialStatus: string | null
    stage: string | null
    priority: string | null
    enrolledGrade: string | null
    source: string | null
    notes: string | null
    bloodGroup: string | null
    medicalConditions: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    previousSchool: string | null
    documents: string | null
    accessToken: string | null
    admissionFormStep: number | null
    dateReceived: Date | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionCountAggregateOutputType = {
    id: number
    studentName: number
    studentAge: number
    studentGender: number
    dateOfBirth: number
    parentName: number
    parentEmail: number
    parentPhone: number
    secondaryPhone: number
    relationship: number
    fatherName: number
    fatherPhone: number
    fatherEmail: number
    fatherOccupation: number
    motherName: number
    motherPhone: number
    motherEmail: number
    motherOccupation: number
    address: number
    city: number
    state: number
    country: number
    zip: number
    officialStatus: number
    stage: number
    priority: number
    enrolledGrade: number
    source: number
    notes: number
    bloodGroup: number
    medicalConditions: number
    allergies: number
    emergencyContactName: number
    emergencyContactPhone: number
    previousSchool: number
    documents: number
    accessToken: number
    admissionFormStep: number
    dateReceived: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionAvgAggregateInputType = {
    studentAge?: true
    admissionFormStep?: true
  }

  export type AdmissionSumAggregateInputType = {
    studentAge?: true
    admissionFormStep?: true
  }

  export type AdmissionMinAggregateInputType = {
    id?: true
    studentName?: true
    studentAge?: true
    studentGender?: true
    dateOfBirth?: true
    parentName?: true
    parentEmail?: true
    parentPhone?: true
    secondaryPhone?: true
    relationship?: true
    fatherName?: true
    fatherPhone?: true
    fatherEmail?: true
    fatherOccupation?: true
    motherName?: true
    motherPhone?: true
    motherEmail?: true
    motherOccupation?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zip?: true
    officialStatus?: true
    stage?: true
    priority?: true
    enrolledGrade?: true
    source?: true
    notes?: true
    bloodGroup?: true
    medicalConditions?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    previousSchool?: true
    documents?: true
    accessToken?: true
    admissionFormStep?: true
    dateReceived?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionMaxAggregateInputType = {
    id?: true
    studentName?: true
    studentAge?: true
    studentGender?: true
    dateOfBirth?: true
    parentName?: true
    parentEmail?: true
    parentPhone?: true
    secondaryPhone?: true
    relationship?: true
    fatherName?: true
    fatherPhone?: true
    fatherEmail?: true
    fatherOccupation?: true
    motherName?: true
    motherPhone?: true
    motherEmail?: true
    motherOccupation?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zip?: true
    officialStatus?: true
    stage?: true
    priority?: true
    enrolledGrade?: true
    source?: true
    notes?: true
    bloodGroup?: true
    medicalConditions?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    previousSchool?: true
    documents?: true
    accessToken?: true
    admissionFormStep?: true
    dateReceived?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionCountAggregateInputType = {
    id?: true
    studentName?: true
    studentAge?: true
    studentGender?: true
    dateOfBirth?: true
    parentName?: true
    parentEmail?: true
    parentPhone?: true
    secondaryPhone?: true
    relationship?: true
    fatherName?: true
    fatherPhone?: true
    fatherEmail?: true
    fatherOccupation?: true
    motherName?: true
    motherPhone?: true
    motherEmail?: true
    motherOccupation?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zip?: true
    officialStatus?: true
    stage?: true
    priority?: true
    enrolledGrade?: true
    source?: true
    notes?: true
    bloodGroup?: true
    medicalConditions?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    previousSchool?: true
    documents?: true
    accessToken?: true
    admissionFormStep?: true
    dateReceived?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admission to aggregate.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admissions
    **/
    _count?: true | AdmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionMaxAggregateInputType
  }

  export type GetAdmissionAggregateType<T extends AdmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmission[P]>
      : GetScalarType<T[P], AggregateAdmission[P]>
  }




  export type AdmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithAggregationInput | AdmissionOrderByWithAggregationInput[]
    by: AdmissionScalarFieldEnum[] | AdmissionScalarFieldEnum
    having?: AdmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionCountAggregateInputType | true
    _avg?: AdmissionAvgAggregateInputType
    _sum?: AdmissionSumAggregateInputType
    _min?: AdmissionMinAggregateInputType
    _max?: AdmissionMaxAggregateInputType
  }

  export type AdmissionGroupByOutputType = {
    id: string
    studentName: string
    studentAge: number | null
    studentGender: string | null
    dateOfBirth: Date | null
    parentName: string
    parentEmail: string | null
    parentPhone: string | null
    secondaryPhone: string | null
    relationship: string | null
    fatherName: string | null
    fatherPhone: string | null
    fatherEmail: string | null
    fatherOccupation: string | null
    motherName: string | null
    motherPhone: string | null
    motherEmail: string | null
    motherOccupation: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zip: string | null
    officialStatus: string | null
    stage: string
    priority: string
    enrolledGrade: string | null
    source: string | null
    notes: string | null
    bloodGroup: string | null
    medicalConditions: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    previousSchool: string | null
    documents: string | null
    accessToken: string | null
    admissionFormStep: number
    dateReceived: Date
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: AdmissionCountAggregateOutputType | null
    _avg: AdmissionAvgAggregateOutputType | null
    _sum: AdmissionSumAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  type GetAdmissionGroupByPayload<T extends AdmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentName?: boolean
    studentAge?: boolean
    studentGender?: boolean
    dateOfBirth?: boolean
    parentName?: boolean
    parentEmail?: boolean
    parentPhone?: boolean
    secondaryPhone?: boolean
    relationship?: boolean
    fatherName?: boolean
    fatherPhone?: boolean
    fatherEmail?: boolean
    fatherOccupation?: boolean
    motherName?: boolean
    motherPhone?: boolean
    motherEmail?: boolean
    motherOccupation?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zip?: boolean
    officialStatus?: boolean
    stage?: boolean
    priority?: boolean
    enrolledGrade?: boolean
    source?: boolean
    notes?: boolean
    bloodGroup?: boolean
    medicalConditions?: boolean
    allergies?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    previousSchool?: boolean
    documents?: boolean
    accessToken?: boolean
    admissionFormStep?: boolean
    dateReceived?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectScalar = {
    id?: boolean
    studentName?: boolean
    studentAge?: boolean
    studentGender?: boolean
    dateOfBirth?: boolean
    parentName?: boolean
    parentEmail?: boolean
    parentPhone?: boolean
    secondaryPhone?: boolean
    relationship?: boolean
    fatherName?: boolean
    fatherPhone?: boolean
    fatherEmail?: boolean
    fatherOccupation?: boolean
    motherName?: boolean
    motherPhone?: boolean
    motherEmail?: boolean
    motherOccupation?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zip?: boolean
    officialStatus?: boolean
    stage?: boolean
    priority?: boolean
    enrolledGrade?: boolean
    source?: boolean
    notes?: boolean
    bloodGroup?: boolean
    medicalConditions?: boolean
    allergies?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    previousSchool?: boolean
    documents?: boolean
    accessToken?: boolean
    admissionFormStep?: boolean
    dateReceived?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }


  export type $AdmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admission"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentName: string
      studentAge: number | null
      studentGender: string | null
      dateOfBirth: Date | null
      parentName: string
      parentEmail: string | null
      parentPhone: string | null
      secondaryPhone: string | null
      relationship: string | null
      fatherName: string | null
      fatherPhone: string | null
      fatherEmail: string | null
      fatherOccupation: string | null
      motherName: string | null
      motherPhone: string | null
      motherEmail: string | null
      motherOccupation: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      zip: string | null
      officialStatus: string | null
      stage: string
      priority: string
      enrolledGrade: string | null
      source: string | null
      notes: string | null
      bloodGroup: string | null
      medicalConditions: string | null
      allergies: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      previousSchool: string | null
      documents: string | null
      accessToken: string | null
      admissionFormStep: number
      dateReceived: Date
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admission"]>
    composites: {}
  }


  type AdmissionGetPayload<S extends boolean | null | undefined | AdmissionDefaultArgs> = $Result.GetResult<Prisma.$AdmissionPayload, S>

  type AdmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionCountAggregateInputType | true
    }

  export interface AdmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admission'], meta: { name: 'Admission' } }
    /**
     * Find zero or one Admission that matches the filter.
     * @param {AdmissionFindUniqueArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdmissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdmissionFindUniqueArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdmissionFindUniqueOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdmissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdmissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdmissionFindFirstArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdmissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admission.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionWithIdOnly = await prisma.admission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdmissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admission.
     * @param {AdmissionCreateArgs} args - Arguments to create a Admission.
     * @example
     * // Create one Admission
     * const Admission = await prisma.admission.create({
     *   data: {
     *     // ... data to create a Admission
     *   }
     * })
     * 
    **/
    create<T extends AdmissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdmissionCreateArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Admission.
     * @param {AdmissionDeleteArgs} args - Arguments to delete one Admission.
     * @example
     * // Delete one Admission
     * const Admission = await prisma.admission.delete({
     *   where: {
     *     // ... filter to delete one Admission
     *   }
     * })
     * 
    **/
    delete<T extends AdmissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdmissionDeleteArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admission.
     * @param {AdmissionUpdateArgs} args - Arguments to update one Admission.
     * @example
     * // Update one Admission
     * const admission = await prisma.admission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdmissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdmissionUpdateArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admissions.
     * @param {AdmissionDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdmissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdmissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admission.
     * @param {AdmissionUpsertArgs} args - Arguments to update or create a Admission.
     * @example
     * // Update or create a Admission
     * const admission = await prisma.admission.upsert({
     *   create: {
     *     // ... data to create a Admission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admission we want to update
     *   }
     * })
    **/
    upsert<T extends AdmissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdmissionUpsertArgs<ExtArgs>>
    ): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admission.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends AdmissionCountArgs>(
      args?: Subset<T, AdmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionAggregateArgs>(args: Subset<T, AdmissionAggregateArgs>): Prisma.PrismaPromise<GetAdmissionAggregateType<T>>

    /**
     * Group by Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admission model
   */
  readonly fields: AdmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admission model
   */ 
  interface AdmissionFieldRefs {
    readonly id: FieldRef<"Admission", 'String'>
    readonly studentName: FieldRef<"Admission", 'String'>
    readonly studentAge: FieldRef<"Admission", 'Int'>
    readonly studentGender: FieldRef<"Admission", 'String'>
    readonly dateOfBirth: FieldRef<"Admission", 'DateTime'>
    readonly parentName: FieldRef<"Admission", 'String'>
    readonly parentEmail: FieldRef<"Admission", 'String'>
    readonly parentPhone: FieldRef<"Admission", 'String'>
    readonly secondaryPhone: FieldRef<"Admission", 'String'>
    readonly relationship: FieldRef<"Admission", 'String'>
    readonly fatherName: FieldRef<"Admission", 'String'>
    readonly fatherPhone: FieldRef<"Admission", 'String'>
    readonly fatherEmail: FieldRef<"Admission", 'String'>
    readonly fatherOccupation: FieldRef<"Admission", 'String'>
    readonly motherName: FieldRef<"Admission", 'String'>
    readonly motherPhone: FieldRef<"Admission", 'String'>
    readonly motherEmail: FieldRef<"Admission", 'String'>
    readonly motherOccupation: FieldRef<"Admission", 'String'>
    readonly address: FieldRef<"Admission", 'String'>
    readonly city: FieldRef<"Admission", 'String'>
    readonly state: FieldRef<"Admission", 'String'>
    readonly country: FieldRef<"Admission", 'String'>
    readonly zip: FieldRef<"Admission", 'String'>
    readonly officialStatus: FieldRef<"Admission", 'String'>
    readonly stage: FieldRef<"Admission", 'String'>
    readonly priority: FieldRef<"Admission", 'String'>
    readonly enrolledGrade: FieldRef<"Admission", 'String'>
    readonly source: FieldRef<"Admission", 'String'>
    readonly notes: FieldRef<"Admission", 'String'>
    readonly bloodGroup: FieldRef<"Admission", 'String'>
    readonly medicalConditions: FieldRef<"Admission", 'String'>
    readonly allergies: FieldRef<"Admission", 'String'>
    readonly emergencyContactName: FieldRef<"Admission", 'String'>
    readonly emergencyContactPhone: FieldRef<"Admission", 'String'>
    readonly previousSchool: FieldRef<"Admission", 'String'>
    readonly documents: FieldRef<"Admission", 'String'>
    readonly accessToken: FieldRef<"Admission", 'String'>
    readonly admissionFormStep: FieldRef<"Admission", 'Int'>
    readonly dateReceived: FieldRef<"Admission", 'DateTime'>
    readonly schoolId: FieldRef<"Admission", 'String'>
    readonly createdAt: FieldRef<"Admission", 'DateTime'>
    readonly updatedAt: FieldRef<"Admission", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Admission findUnique
   */
  export type AdmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }


  /**
   * Admission findUniqueOrThrow
   */
  export type AdmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }


  /**
   * Admission findFirst
   */
  export type AdmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }


  /**
   * Admission findFirstOrThrow
   */
  export type AdmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }


  /**
   * Admission findMany
   */
  export type AdmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admissions to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }


  /**
   * Admission create
   */
  export type AdmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Admission.
     */
    data: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
  }


  /**
   * Admission update
   */
  export type AdmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Admission.
     */
    data: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
    /**
     * Choose, which Admission to update.
     */
    where: AdmissionWhereUniqueInput
  }


  /**
   * Admission updateMany
   */
  export type AdmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
  }


  /**
   * Admission upsert
   */
  export type AdmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Admission to update in case it exists.
     */
    where: AdmissionWhereUniqueInput
    /**
     * In case the Admission found by the `where` argument doesn't exist, create a new Admission with this data.
     */
    create: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
    /**
     * In case the Admission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
  }


  /**
   * Admission delete
   */
  export type AdmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter which Admission to delete.
     */
    where: AdmissionWhereUniqueInput
  }


  /**
   * Admission deleteMany
   */
  export type AdmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admissions to delete
     */
    where?: AdmissionWhereInput
  }


  /**
   * Admission without action
   */
  export type AdmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdmissionInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    mobile: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    designation: string | null
    department: string | null
    joiningDate: Date | null
    status: string | null
    avatar: string | null
    address: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    schoolId: string | null
    documents: string | null
    gender: string | null
    dateOfBirth: Date | null
    bloodGroup: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelation: string | null
    addressCity: string | null
    addressState: string | null
    addressZip: string | null
    addressCountry: string | null
    qualifications: string | null
    experience: string | null
    employmentType: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    facebook: string | null
    linkedin: string | null
    twitter: string | null
    instagram: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    mobile: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    designation: string | null
    department: string | null
    joiningDate: Date | null
    status: string | null
    avatar: string | null
    address: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    schoolId: string | null
    documents: string | null
    gender: string | null
    dateOfBirth: Date | null
    bloodGroup: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelation: string | null
    addressCity: string | null
    addressState: string | null
    addressZip: string | null
    addressCountry: string | null
    qualifications: string | null
    experience: string | null
    employmentType: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    facebook: string | null
    linkedin: string | null
    twitter: string | null
    instagram: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    mobile: number
    email: number
    firstName: number
    lastName: number
    designation: number
    department: number
    joiningDate: number
    status: number
    avatar: number
    address: number
    role: number
    createdAt: number
    updatedAt: number
    schoolId: number
    documents: number
    gender: number
    dateOfBirth: number
    bloodGroup: number
    emergencyContactName: number
    emergencyContactPhone: number
    emergencyContactRelation: number
    addressCity: number
    addressState: number
    addressZip: number
    addressCountry: number
    qualifications: number
    experience: number
    employmentType: number
    bankName: number
    bankAccountNo: number
    bankIfsc: number
    facebook: number
    linkedin: number
    twitter: number
    instagram: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    mobile?: true
    email?: true
    firstName?: true
    lastName?: true
    designation?: true
    department?: true
    joiningDate?: true
    status?: true
    avatar?: true
    address?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    documents?: true
    gender?: true
    dateOfBirth?: true
    bloodGroup?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelation?: true
    addressCity?: true
    addressState?: true
    addressZip?: true
    addressCountry?: true
    qualifications?: true
    experience?: true
    employmentType?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    facebook?: true
    linkedin?: true
    twitter?: true
    instagram?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    mobile?: true
    email?: true
    firstName?: true
    lastName?: true
    designation?: true
    department?: true
    joiningDate?: true
    status?: true
    avatar?: true
    address?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    documents?: true
    gender?: true
    dateOfBirth?: true
    bloodGroup?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelation?: true
    addressCity?: true
    addressState?: true
    addressZip?: true
    addressCountry?: true
    qualifications?: true
    experience?: true
    employmentType?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    facebook?: true
    linkedin?: true
    twitter?: true
    instagram?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    mobile?: true
    email?: true
    firstName?: true
    lastName?: true
    designation?: true
    department?: true
    joiningDate?: true
    status?: true
    avatar?: true
    address?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    documents?: true
    gender?: true
    dateOfBirth?: true
    bloodGroup?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelation?: true
    addressCity?: true
    addressState?: true
    addressZip?: true
    addressCountry?: true
    qualifications?: true
    experience?: true
    employmentType?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    facebook?: true
    linkedin?: true
    twitter?: true
    instagram?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    mobile: string
    email: string | null
    firstName: string | null
    lastName: string | null
    designation: string | null
    department: string | null
    joiningDate: Date | null
    status: string
    avatar: string | null
    address: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    schoolId: string | null
    documents: string | null
    gender: string | null
    dateOfBirth: Date | null
    bloodGroup: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelation: string | null
    addressCity: string | null
    addressState: string | null
    addressZip: string | null
    addressCountry: string | null
    qualifications: string | null
    experience: string | null
    employmentType: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    facebook: string | null
    linkedin: string | null
    twitter: string | null
    instagram: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobile?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    designation?: boolean
    department?: boolean
    joiningDate?: boolean
    status?: boolean
    avatar?: boolean
    address?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    documents?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    bloodGroup?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelation?: boolean
    addressCity?: boolean
    addressState?: boolean
    addressZip?: boolean
    addressCountry?: boolean
    qualifications?: boolean
    experience?: boolean
    employmentType?: boolean
    bankName?: boolean
    bankAccountNo?: boolean
    bankIfsc?: boolean
    facebook?: boolean
    linkedin?: boolean
    twitter?: boolean
    instagram?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
    managedClassrooms?: boolean | User$managedClassroomsArgs<ExtArgs>
    staffAttendance?: boolean | User$staffAttendanceArgs<ExtArgs>
    leaveRequests?: boolean | User$leaveRequestsArgs<ExtArgs>
    salaryRevisions?: boolean | User$salaryRevisionsArgs<ExtArgs>
    leaveBalances?: boolean | User$leaveBalancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    mobile?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    designation?: boolean
    department?: boolean
    joiningDate?: boolean
    status?: boolean
    avatar?: boolean
    address?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    documents?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    bloodGroup?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelation?: boolean
    addressCity?: boolean
    addressState?: boolean
    addressZip?: boolean
    addressCountry?: boolean
    qualifications?: boolean
    experience?: boolean
    employmentType?: boolean
    bankName?: boolean
    bankAccountNo?: boolean
    bankIfsc?: boolean
    facebook?: boolean
    linkedin?: boolean
    twitter?: boolean
    instagram?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
    managedClassrooms?: boolean | User$managedClassroomsArgs<ExtArgs>
    staffAttendance?: boolean | User$staffAttendanceArgs<ExtArgs>
    leaveRequests?: boolean | User$leaveRequestsArgs<ExtArgs>
    salaryRevisions?: boolean | User$salaryRevisionsArgs<ExtArgs>
    leaveBalances?: boolean | User$leaveBalancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs> | null
      managedClassrooms: Prisma.$ClassroomPayload<ExtArgs>[]
      staffAttendance: Prisma.$StaffAttendancePayload<ExtArgs>[]
      leaveRequests: Prisma.$LeaveRequestPayload<ExtArgs>[]
      salaryRevisions: Prisma.$SalaryRevisionPayload<ExtArgs>[]
      leaveBalances: Prisma.$LeaveBalancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mobile: string
      email: string | null
      firstName: string | null
      lastName: string | null
      designation: string | null
      department: string | null
      joiningDate: Date | null
      status: string
      avatar: string | null
      address: string | null
      role: string
      createdAt: Date
      updatedAt: Date
      schoolId: string | null
      documents: string | null
      gender: string | null
      dateOfBirth: Date | null
      bloodGroup: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      emergencyContactRelation: string | null
      addressCity: string | null
      addressState: string | null
      addressZip: string | null
      addressCountry: string | null
      qualifications: string | null
      experience: string | null
      employmentType: string | null
      bankName: string | null
      bankAccountNo: string | null
      bankIfsc: string | null
      facebook: string | null
      linkedin: string | null
      twitter: string | null
      instagram: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    managedClassrooms<T extends User$managedClassroomsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedClassroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findMany'> | Null>;

    staffAttendance<T extends User$staffAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$staffAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'findMany'> | Null>;

    leaveRequests<T extends User$leaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'findMany'> | Null>;

    salaryRevisions<T extends User$salaryRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'findMany'> | Null>;

    leaveBalances<T extends User$leaveBalancesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly mobile: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly designation: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly joiningDate: FieldRef<"User", 'DateTime'>
    readonly status: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly documents: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly bloodGroup: FieldRef<"User", 'String'>
    readonly emergencyContactName: FieldRef<"User", 'String'>
    readonly emergencyContactPhone: FieldRef<"User", 'String'>
    readonly emergencyContactRelation: FieldRef<"User", 'String'>
    readonly addressCity: FieldRef<"User", 'String'>
    readonly addressState: FieldRef<"User", 'String'>
    readonly addressZip: FieldRef<"User", 'String'>
    readonly addressCountry: FieldRef<"User", 'String'>
    readonly qualifications: FieldRef<"User", 'String'>
    readonly experience: FieldRef<"User", 'String'>
    readonly employmentType: FieldRef<"User", 'String'>
    readonly bankName: FieldRef<"User", 'String'>
    readonly bankAccountNo: FieldRef<"User", 'String'>
    readonly bankIfsc: FieldRef<"User", 'String'>
    readonly facebook: FieldRef<"User", 'String'>
    readonly linkedin: FieldRef<"User", 'String'>
    readonly twitter: FieldRef<"User", 'String'>
    readonly instagram: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }


  /**
   * User.managedClassrooms
   */
  export type User$managedClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }


  /**
   * User.staffAttendance
   */
  export type User$staffAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    where?: StaffAttendanceWhereInput
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    cursor?: StaffAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }


  /**
   * User.leaveRequests
   */
  export type User$leaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }


  /**
   * User.salaryRevisions
   */
  export type User$salaryRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    where?: SalaryRevisionWhereInput
    orderBy?: SalaryRevisionOrderByWithRelationInput | SalaryRevisionOrderByWithRelationInput[]
    cursor?: SalaryRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryRevisionScalarFieldEnum | SalaryRevisionScalarFieldEnum[]
  }


  /**
   * User.leaveBalances
   */
  export type User$leaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    cursor?: LeaveBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model LeavePolicy
   */

  export type AggregateLeavePolicy = {
    _count: LeavePolicyCountAggregateOutputType | null
    _avg: LeavePolicyAvgAggregateOutputType | null
    _sum: LeavePolicySumAggregateOutputType | null
    _min: LeavePolicyMinAggregateOutputType | null
    _max: LeavePolicyMaxAggregateOutputType | null
  }

  export type LeavePolicyAvgAggregateOutputType = {
    lateComingGrace: number | null
    lateComingMax: number | null
    earlyLeavingGrace: number | null
    earlyLeavingMax: number | null
    permissionMaxMins: number | null
    permissionMaxOccur: number | null
  }

  export type LeavePolicySumAggregateOutputType = {
    lateComingGrace: number | null
    lateComingMax: number | null
    earlyLeavingGrace: number | null
    earlyLeavingMax: number | null
    permissionMaxMins: number | null
    permissionMaxOccur: number | null
  }

  export type LeavePolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    isDefault: boolean | null
    schoolId: string | null
    lateComingGrace: number | null
    lateComingMax: number | null
    earlyLeavingGrace: number | null
    earlyLeavingMax: number | null
    permissionAllowed: boolean | null
    permissionMaxMins: number | null
    permissionMaxOccur: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeavePolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    isDefault: boolean | null
    schoolId: string | null
    lateComingGrace: number | null
    lateComingMax: number | null
    earlyLeavingGrace: number | null
    earlyLeavingMax: number | null
    permissionAllowed: boolean | null
    permissionMaxMins: number | null
    permissionMaxOccur: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeavePolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    effectiveFrom: number
    effectiveTo: number
    isDefault: number
    schoolId: number
    lateComingGrace: number
    lateComingMax: number
    earlyLeavingGrace: number
    earlyLeavingMax: number
    permissionAllowed: number
    permissionMaxMins: number
    permissionMaxOccur: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeavePolicyAvgAggregateInputType = {
    lateComingGrace?: true
    lateComingMax?: true
    earlyLeavingGrace?: true
    earlyLeavingMax?: true
    permissionMaxMins?: true
    permissionMaxOccur?: true
  }

  export type LeavePolicySumAggregateInputType = {
    lateComingGrace?: true
    lateComingMax?: true
    earlyLeavingGrace?: true
    earlyLeavingMax?: true
    permissionMaxMins?: true
    permissionMaxOccur?: true
  }

  export type LeavePolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    effectiveFrom?: true
    effectiveTo?: true
    isDefault?: true
    schoolId?: true
    lateComingGrace?: true
    lateComingMax?: true
    earlyLeavingGrace?: true
    earlyLeavingMax?: true
    permissionAllowed?: true
    permissionMaxMins?: true
    permissionMaxOccur?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeavePolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    effectiveFrom?: true
    effectiveTo?: true
    isDefault?: true
    schoolId?: true
    lateComingGrace?: true
    lateComingMax?: true
    earlyLeavingGrace?: true
    earlyLeavingMax?: true
    permissionAllowed?: true
    permissionMaxMins?: true
    permissionMaxOccur?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeavePolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    effectiveFrom?: true
    effectiveTo?: true
    isDefault?: true
    schoolId?: true
    lateComingGrace?: true
    lateComingMax?: true
    earlyLeavingGrace?: true
    earlyLeavingMax?: true
    permissionAllowed?: true
    permissionMaxMins?: true
    permissionMaxOccur?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeavePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeavePolicy to aggregate.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeavePolicies
    **/
    _count?: true | LeavePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeavePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeavePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeavePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeavePolicyMaxAggregateInputType
  }

  export type GetLeavePolicyAggregateType<T extends LeavePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateLeavePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeavePolicy[P]>
      : GetScalarType<T[P], AggregateLeavePolicy[P]>
  }




  export type LeavePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeavePolicyWhereInput
    orderBy?: LeavePolicyOrderByWithAggregationInput | LeavePolicyOrderByWithAggregationInput[]
    by: LeavePolicyScalarFieldEnum[] | LeavePolicyScalarFieldEnum
    having?: LeavePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeavePolicyCountAggregateInputType | true
    _avg?: LeavePolicyAvgAggregateInputType
    _sum?: LeavePolicySumAggregateInputType
    _min?: LeavePolicyMinAggregateInputType
    _max?: LeavePolicyMaxAggregateInputType
  }

  export type LeavePolicyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    effectiveFrom: Date
    effectiveTo: Date | null
    isDefault: boolean
    schoolId: string
    lateComingGrace: number
    lateComingMax: number
    earlyLeavingGrace: number
    earlyLeavingMax: number
    permissionAllowed: boolean
    permissionMaxMins: number
    permissionMaxOccur: number
    createdAt: Date
    updatedAt: Date
    _count: LeavePolicyCountAggregateOutputType | null
    _avg: LeavePolicyAvgAggregateOutputType | null
    _sum: LeavePolicySumAggregateOutputType | null
    _min: LeavePolicyMinAggregateOutputType | null
    _max: LeavePolicyMaxAggregateOutputType | null
  }

  type GetLeavePolicyGroupByPayload<T extends LeavePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeavePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeavePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeavePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], LeavePolicyGroupByOutputType[P]>
        }
      >
    >


  export type LeavePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    isDefault?: boolean
    schoolId?: boolean
    lateComingGrace?: boolean
    lateComingMax?: boolean
    earlyLeavingGrace?: boolean
    earlyLeavingMax?: boolean
    permissionAllowed?: boolean
    permissionMaxMins?: boolean
    permissionMaxOccur?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    leaveTypes?: boolean | LeavePolicy$leaveTypesArgs<ExtArgs>
    _count?: boolean | LeavePolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leavePolicy"]>

  export type LeavePolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    isDefault?: boolean
    schoolId?: boolean
    lateComingGrace?: boolean
    lateComingMax?: boolean
    earlyLeavingGrace?: boolean
    earlyLeavingMax?: boolean
    permissionAllowed?: boolean
    permissionMaxMins?: boolean
    permissionMaxOccur?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeavePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    leaveTypes?: boolean | LeavePolicy$leaveTypesArgs<ExtArgs>
    _count?: boolean | LeavePolicyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LeavePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeavePolicy"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      leaveTypes: Prisma.$LeaveTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      effectiveFrom: Date
      effectiveTo: Date | null
      isDefault: boolean
      schoolId: string
      lateComingGrace: number
      lateComingMax: number
      earlyLeavingGrace: number
      earlyLeavingMax: number
      permissionAllowed: boolean
      permissionMaxMins: number
      permissionMaxOccur: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leavePolicy"]>
    composites: {}
  }


  type LeavePolicyGetPayload<S extends boolean | null | undefined | LeavePolicyDefaultArgs> = $Result.GetResult<Prisma.$LeavePolicyPayload, S>

  type LeavePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeavePolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeavePolicyCountAggregateInputType | true
    }

  export interface LeavePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeavePolicy'], meta: { name: 'LeavePolicy' } }
    /**
     * Find zero or one LeavePolicy that matches the filter.
     * @param {LeavePolicyFindUniqueArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeavePolicyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeavePolicyFindUniqueArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LeavePolicy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeavePolicyFindUniqueOrThrowArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeavePolicyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeavePolicyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LeavePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyFindFirstArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeavePolicyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeavePolicyFindFirstArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LeavePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyFindFirstOrThrowArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeavePolicyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeavePolicyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LeavePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeavePolicies
     * const leavePolicies = await prisma.leavePolicy.findMany()
     * 
     * // Get first 10 LeavePolicies
     * const leavePolicies = await prisma.leavePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leavePolicyWithIdOnly = await prisma.leavePolicy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeavePolicyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeavePolicyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LeavePolicy.
     * @param {LeavePolicyCreateArgs} args - Arguments to create a LeavePolicy.
     * @example
     * // Create one LeavePolicy
     * const LeavePolicy = await prisma.leavePolicy.create({
     *   data: {
     *     // ... data to create a LeavePolicy
     *   }
     * })
     * 
    **/
    create<T extends LeavePolicyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeavePolicyCreateArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a LeavePolicy.
     * @param {LeavePolicyDeleteArgs} args - Arguments to delete one LeavePolicy.
     * @example
     * // Delete one LeavePolicy
     * const LeavePolicy = await prisma.leavePolicy.delete({
     *   where: {
     *     // ... filter to delete one LeavePolicy
     *   }
     * })
     * 
    **/
    delete<T extends LeavePolicyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeavePolicyDeleteArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LeavePolicy.
     * @param {LeavePolicyUpdateArgs} args - Arguments to update one LeavePolicy.
     * @example
     * // Update one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeavePolicyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeavePolicyUpdateArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LeavePolicies.
     * @param {LeavePolicyDeleteManyArgs} args - Arguments to filter LeavePolicies to delete.
     * @example
     * // Delete a few LeavePolicies
     * const { count } = await prisma.leavePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeavePolicyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeavePolicyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeavePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeavePolicies
     * const leavePolicy = await prisma.leavePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeavePolicyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeavePolicyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeavePolicy.
     * @param {LeavePolicyUpsertArgs} args - Arguments to update or create a LeavePolicy.
     * @example
     * // Update or create a LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.upsert({
     *   create: {
     *     // ... data to create a LeavePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeavePolicy we want to update
     *   }
     * })
    **/
    upsert<T extends LeavePolicyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeavePolicyUpsertArgs<ExtArgs>>
    ): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LeavePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyCountArgs} args - Arguments to filter LeavePolicies to count.
     * @example
     * // Count the number of LeavePolicies
     * const count = await prisma.leavePolicy.count({
     *   where: {
     *     // ... the filter for the LeavePolicies we want to count
     *   }
     * })
    **/
    count<T extends LeavePolicyCountArgs>(
      args?: Subset<T, LeavePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeavePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeavePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeavePolicyAggregateArgs>(args: Subset<T, LeavePolicyAggregateArgs>): Prisma.PrismaPromise<GetLeavePolicyAggregateType<T>>

    /**
     * Group by LeavePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeavePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeavePolicyGroupByArgs['orderBy'] }
        : { orderBy?: LeavePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeavePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeavePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeavePolicy model
   */
  readonly fields: LeavePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeavePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeavePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    leaveTypes<T extends LeavePolicy$leaveTypesArgs<ExtArgs> = {}>(args?: Subset<T, LeavePolicy$leaveTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LeavePolicy model
   */ 
  interface LeavePolicyFieldRefs {
    readonly id: FieldRef<"LeavePolicy", 'String'>
    readonly name: FieldRef<"LeavePolicy", 'String'>
    readonly description: FieldRef<"LeavePolicy", 'String'>
    readonly effectiveFrom: FieldRef<"LeavePolicy", 'DateTime'>
    readonly effectiveTo: FieldRef<"LeavePolicy", 'DateTime'>
    readonly isDefault: FieldRef<"LeavePolicy", 'Boolean'>
    readonly schoolId: FieldRef<"LeavePolicy", 'String'>
    readonly lateComingGrace: FieldRef<"LeavePolicy", 'Int'>
    readonly lateComingMax: FieldRef<"LeavePolicy", 'Int'>
    readonly earlyLeavingGrace: FieldRef<"LeavePolicy", 'Int'>
    readonly earlyLeavingMax: FieldRef<"LeavePolicy", 'Int'>
    readonly permissionAllowed: FieldRef<"LeavePolicy", 'Boolean'>
    readonly permissionMaxMins: FieldRef<"LeavePolicy", 'Int'>
    readonly permissionMaxOccur: FieldRef<"LeavePolicy", 'Int'>
    readonly createdAt: FieldRef<"LeavePolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"LeavePolicy", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * LeavePolicy findUnique
   */
  export type LeavePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where: LeavePolicyWhereUniqueInput
  }


  /**
   * LeavePolicy findUniqueOrThrow
   */
  export type LeavePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where: LeavePolicyWhereUniqueInput
  }


  /**
   * LeavePolicy findFirst
   */
  export type LeavePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeavePolicies.
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeavePolicies.
     */
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }


  /**
   * LeavePolicy findFirstOrThrow
   */
  export type LeavePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeavePolicies.
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeavePolicies.
     */
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }


  /**
   * LeavePolicy findMany
   */
  export type LeavePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicies to fetch.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeavePolicies.
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }


  /**
   * LeavePolicy create
   */
  export type LeavePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a LeavePolicy.
     */
    data: XOR<LeavePolicyCreateInput, LeavePolicyUncheckedCreateInput>
  }


  /**
   * LeavePolicy update
   */
  export type LeavePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a LeavePolicy.
     */
    data: XOR<LeavePolicyUpdateInput, LeavePolicyUncheckedUpdateInput>
    /**
     * Choose, which LeavePolicy to update.
     */
    where: LeavePolicyWhereUniqueInput
  }


  /**
   * LeavePolicy updateMany
   */
  export type LeavePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeavePolicies.
     */
    data: XOR<LeavePolicyUpdateManyMutationInput, LeavePolicyUncheckedUpdateManyInput>
    /**
     * Filter which LeavePolicies to update
     */
    where?: LeavePolicyWhereInput
  }


  /**
   * LeavePolicy upsert
   */
  export type LeavePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the LeavePolicy to update in case it exists.
     */
    where: LeavePolicyWhereUniqueInput
    /**
     * In case the LeavePolicy found by the `where` argument doesn't exist, create a new LeavePolicy with this data.
     */
    create: XOR<LeavePolicyCreateInput, LeavePolicyUncheckedCreateInput>
    /**
     * In case the LeavePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeavePolicyUpdateInput, LeavePolicyUncheckedUpdateInput>
  }


  /**
   * LeavePolicy delete
   */
  export type LeavePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter which LeavePolicy to delete.
     */
    where: LeavePolicyWhereUniqueInput
  }


  /**
   * LeavePolicy deleteMany
   */
  export type LeavePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeavePolicies to delete
     */
    where?: LeavePolicyWhereInput
  }


  /**
   * LeavePolicy.leaveTypes
   */
  export type LeavePolicy$leaveTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    cursor?: LeaveTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }


  /**
   * LeavePolicy without action
   */
  export type LeavePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeavePolicyInclude<ExtArgs> | null
  }



  /**
   * Model LeaveType
   */

  export type AggregateLeaveType = {
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  export type LeaveTypeAvgAggregateOutputType = {
    totalDays: number | null
    maxCarryForward: number | null
    minNoticePeriod: number | null
  }

  export type LeaveTypeSumAggregateOutputType = {
    totalDays: number | null
    maxCarryForward: number | null
    minNoticePeriod: number | null
  }

  export type LeaveTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    totalDays: number | null
    canCarryForward: boolean | null
    maxCarryForward: number | null
    isPaid: boolean | null
    allowHalfDay: boolean | null
    minNoticePeriod: number | null
    requiresApproval: boolean | null
    gender: string | null
    policyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    totalDays: number | null
    canCarryForward: boolean | null
    maxCarryForward: number | null
    isPaid: boolean | null
    allowHalfDay: boolean | null
    minNoticePeriod: number | null
    requiresApproval: boolean | null
    gender: string | null
    policyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveTypeCountAggregateOutputType = {
    id: number
    name: number
    code: number
    totalDays: number
    canCarryForward: number
    maxCarryForward: number
    isPaid: number
    allowHalfDay: number
    minNoticePeriod: number
    requiresApproval: number
    gender: number
    policyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveTypeAvgAggregateInputType = {
    totalDays?: true
    maxCarryForward?: true
    minNoticePeriod?: true
  }

  export type LeaveTypeSumAggregateInputType = {
    totalDays?: true
    maxCarryForward?: true
    minNoticePeriod?: true
  }

  export type LeaveTypeMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    totalDays?: true
    canCarryForward?: true
    maxCarryForward?: true
    isPaid?: true
    allowHalfDay?: true
    minNoticePeriod?: true
    requiresApproval?: true
    gender?: true
    policyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveTypeMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    totalDays?: true
    canCarryForward?: true
    maxCarryForward?: true
    isPaid?: true
    allowHalfDay?: true
    minNoticePeriod?: true
    requiresApproval?: true
    gender?: true
    policyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveTypeCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    totalDays?: true
    canCarryForward?: true
    maxCarryForward?: true
    isPaid?: true
    allowHalfDay?: true
    minNoticePeriod?: true
    requiresApproval?: true
    gender?: true
    policyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveType to aggregate.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveTypes
    **/
    _count?: true | LeaveTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type GetLeaveTypeAggregateType<T extends LeaveTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveType[P]>
      : GetScalarType<T[P], AggregateLeaveType[P]>
  }




  export type LeaveTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithAggregationInput | LeaveTypeOrderByWithAggregationInput[]
    by: LeaveTypeScalarFieldEnum[] | LeaveTypeScalarFieldEnum
    having?: LeaveTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveTypeCountAggregateInputType | true
    _avg?: LeaveTypeAvgAggregateInputType
    _sum?: LeaveTypeSumAggregateInputType
    _min?: LeaveTypeMinAggregateInputType
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type LeaveTypeGroupByOutputType = {
    id: string
    name: string
    code: string
    totalDays: number
    canCarryForward: boolean
    maxCarryForward: number
    isPaid: boolean
    allowHalfDay: boolean
    minNoticePeriod: number
    requiresApproval: boolean
    gender: string | null
    policyId: string
    createdAt: Date
    updatedAt: Date
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  type GetLeaveTypeGroupByPayload<T extends LeaveTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
        }
      >
    >


  export type LeaveTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    totalDays?: boolean
    canCarryForward?: boolean
    maxCarryForward?: boolean
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: boolean
    requiresApproval?: boolean
    gender?: boolean
    policyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    policy?: boolean | LeavePolicyDefaultArgs<ExtArgs>
    leaveBalances?: boolean | LeaveType$leaveBalancesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    totalDays?: boolean
    canCarryForward?: boolean
    maxCarryForward?: boolean
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: boolean
    requiresApproval?: boolean
    gender?: boolean
    policyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy?: boolean | LeavePolicyDefaultArgs<ExtArgs>
    leaveBalances?: boolean | LeaveType$leaveBalancesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LeaveTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveType"
    objects: {
      policy: Prisma.$LeavePolicyPayload<ExtArgs>
      leaveBalances: Prisma.$LeaveBalancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      totalDays: number
      canCarryForward: boolean
      maxCarryForward: number
      isPaid: boolean
      allowHalfDay: boolean
      minNoticePeriod: number
      requiresApproval: boolean
      gender: string | null
      policyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveType"]>
    composites: {}
  }


  type LeaveTypeGetPayload<S extends boolean | null | undefined | LeaveTypeDefaultArgs> = $Result.GetResult<Prisma.$LeaveTypePayload, S>

  type LeaveTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveTypeCountAggregateInputType | true
    }

  export interface LeaveTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveType'], meta: { name: 'LeaveType' } }
    /**
     * Find zero or one LeaveType that matches the filter.
     * @param {LeaveTypeFindUniqueArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaveTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LeaveType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaveTypeFindUniqueOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaveTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LeaveType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaveTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveTypeFindFirstArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LeaveType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaveTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LeaveTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany()
     * 
     * // Get first 10 LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaveTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LeaveType.
     * @param {LeaveTypeCreateArgs} args - Arguments to create a LeaveType.
     * @example
     * // Create one LeaveType
     * const LeaveType = await prisma.leaveType.create({
     *   data: {
     *     // ... data to create a LeaveType
     *   }
     * })
     * 
    **/
    create<T extends LeaveTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveTypeCreateArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a LeaveType.
     * @param {LeaveTypeDeleteArgs} args - Arguments to delete one LeaveType.
     * @example
     * // Delete one LeaveType
     * const LeaveType = await prisma.leaveType.delete({
     *   where: {
     *     // ... filter to delete one LeaveType
     *   }
     * })
     * 
    **/
    delete<T extends LeaveTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveTypeDeleteArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LeaveType.
     * @param {LeaveTypeUpdateArgs} args - Arguments to update one LeaveType.
     * @example
     * // Update one LeaveType
     * const leaveType = await prisma.leaveType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaveTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveTypeUpdateArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LeaveTypes.
     * @param {LeaveTypeDeleteManyArgs} args - Arguments to filter LeaveTypes to delete.
     * @example
     * // Delete a few LeaveTypes
     * const { count } = await prisma.leaveType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaveTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveTypes
     * const leaveType = await prisma.leaveType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaveTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveType.
     * @param {LeaveTypeUpsertArgs} args - Arguments to update or create a LeaveType.
     * @example
     * // Update or create a LeaveType
     * const leaveType = await prisma.leaveType.upsert({
     *   create: {
     *     // ... data to create a LeaveType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveType we want to update
     *   }
     * })
    **/
    upsert<T extends LeaveTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveTypeUpsertArgs<ExtArgs>>
    ): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeCountArgs} args - Arguments to filter LeaveTypes to count.
     * @example
     * // Count the number of LeaveTypes
     * const count = await prisma.leaveType.count({
     *   where: {
     *     // ... the filter for the LeaveTypes we want to count
     *   }
     * })
    **/
    count<T extends LeaveTypeCountArgs>(
      args?: Subset<T, LeaveTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveTypeAggregateArgs>(args: Subset<T, LeaveTypeAggregateArgs>): Prisma.PrismaPromise<GetLeaveTypeAggregateType<T>>

    /**
     * Group by LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveTypeGroupByArgs['orderBy'] }
        : { orderBy?: LeaveTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveType model
   */
  readonly fields: LeaveTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    policy<T extends LeavePolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeavePolicyDefaultArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    leaveBalances<T extends LeaveType$leaveBalancesArgs<ExtArgs> = {}>(args?: Subset<T, LeaveType$leaveBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LeaveType model
   */ 
  interface LeaveTypeFieldRefs {
    readonly id: FieldRef<"LeaveType", 'String'>
    readonly name: FieldRef<"LeaveType", 'String'>
    readonly code: FieldRef<"LeaveType", 'String'>
    readonly totalDays: FieldRef<"LeaveType", 'Float'>
    readonly canCarryForward: FieldRef<"LeaveType", 'Boolean'>
    readonly maxCarryForward: FieldRef<"LeaveType", 'Float'>
    readonly isPaid: FieldRef<"LeaveType", 'Boolean'>
    readonly allowHalfDay: FieldRef<"LeaveType", 'Boolean'>
    readonly minNoticePeriod: FieldRef<"LeaveType", 'Int'>
    readonly requiresApproval: FieldRef<"LeaveType", 'Boolean'>
    readonly gender: FieldRef<"LeaveType", 'String'>
    readonly policyId: FieldRef<"LeaveType", 'String'>
    readonly createdAt: FieldRef<"LeaveType", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveType", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * LeaveType findUnique
   */
  export type LeaveTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }


  /**
   * LeaveType findUniqueOrThrow
   */
  export type LeaveTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }


  /**
   * LeaveType findFirst
   */
  export type LeaveTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }


  /**
   * LeaveType findFirstOrThrow
   */
  export type LeaveTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }


  /**
   * LeaveType findMany
   */
  export type LeaveTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveTypes to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }


  /**
   * LeaveType create
   */
  export type LeaveTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveType.
     */
    data: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
  }


  /**
   * LeaveType update
   */
  export type LeaveTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveType.
     */
    data: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
    /**
     * Choose, which LeaveType to update.
     */
    where: LeaveTypeWhereUniqueInput
  }


  /**
   * LeaveType updateMany
   */
  export type LeaveTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveTypes.
     */
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaveTypes to update
     */
    where?: LeaveTypeWhereInput
  }


  /**
   * LeaveType upsert
   */
  export type LeaveTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveType to update in case it exists.
     */
    where: LeaveTypeWhereUniqueInput
    /**
     * In case the LeaveType found by the `where` argument doesn't exist, create a new LeaveType with this data.
     */
    create: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
    /**
     * In case the LeaveType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
  }


  /**
   * LeaveType delete
   */
  export type LeaveTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter which LeaveType to delete.
     */
    where: LeaveTypeWhereUniqueInput
  }


  /**
   * LeaveType deleteMany
   */
  export type LeaveTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveTypes to delete
     */
    where?: LeaveTypeWhereInput
  }


  /**
   * LeaveType.leaveBalances
   */
  export type LeaveType$leaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    cursor?: LeaveBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }


  /**
   * LeaveType without action
   */
  export type LeaveTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveTypeInclude<ExtArgs> | null
  }



  /**
   * Model LeaveBalance
   */

  export type AggregateLeaveBalance = {
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  export type LeaveBalanceAvgAggregateOutputType = {
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
    year: number | null
  }

  export type LeaveBalanceSumAggregateOutputType = {
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
    year: number | null
  }

  export type LeaveBalanceMinAggregateOutputType = {
    id: string | null
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
    userId: string | null
    leaveTypeId: string | null
    year: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveBalanceMaxAggregateOutputType = {
    id: string | null
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
    userId: string | null
    leaveTypeId: string | null
    year: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveBalanceCountAggregateOutputType = {
    id: number
    total: number
    used: number
    pending: number
    remaining: number
    userId: number
    leaveTypeId: number
    year: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveBalanceAvgAggregateInputType = {
    total?: true
    used?: true
    pending?: true
    remaining?: true
    year?: true
  }

  export type LeaveBalanceSumAggregateInputType = {
    total?: true
    used?: true
    pending?: true
    remaining?: true
    year?: true
  }

  export type LeaveBalanceMinAggregateInputType = {
    id?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
    userId?: true
    leaveTypeId?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveBalanceMaxAggregateInputType = {
    id?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
    userId?: true
    leaveTypeId?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveBalanceCountAggregateInputType = {
    id?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
    userId?: true
    leaveTypeId?: true
    year?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalance to aggregate.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveBalances
    **/
    _count?: true | LeaveBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type GetLeaveBalanceAggregateType<T extends LeaveBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveBalance[P]>
      : GetScalarType<T[P], AggregateLeaveBalance[P]>
  }




  export type LeaveBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithAggregationInput | LeaveBalanceOrderByWithAggregationInput[]
    by: LeaveBalanceScalarFieldEnum[] | LeaveBalanceScalarFieldEnum
    having?: LeaveBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveBalanceCountAggregateInputType | true
    _avg?: LeaveBalanceAvgAggregateInputType
    _sum?: LeaveBalanceSumAggregateInputType
    _min?: LeaveBalanceMinAggregateInputType
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type LeaveBalanceGroupByOutputType = {
    id: string
    total: number
    used: number
    pending: number
    remaining: number
    userId: string
    leaveTypeId: string
    year: number
    createdAt: Date
    updatedAt: Date
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  type GetLeaveBalanceGroupByPayload<T extends LeaveBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
        }
      >
    >


  export type LeaveBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    used?: boolean
    pending?: boolean
    remaining?: boolean
    userId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectScalar = {
    id?: boolean
    total?: boolean
    used?: boolean
    pending?: boolean
    remaining?: boolean
    userId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }


  export type $LeaveBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveBalance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      leaveType: Prisma.$LeaveTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      total: number
      used: number
      pending: number
      remaining: number
      userId: string
      leaveTypeId: string
      year: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveBalance"]>
    composites: {}
  }


  type LeaveBalanceGetPayload<S extends boolean | null | undefined | LeaveBalanceDefaultArgs> = $Result.GetResult<Prisma.$LeaveBalancePayload, S>

  type LeaveBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveBalanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveBalanceCountAggregateInputType | true
    }

  export interface LeaveBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveBalance'], meta: { name: 'LeaveBalance' } }
    /**
     * Find zero or one LeaveBalance that matches the filter.
     * @param {LeaveBalanceFindUniqueArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaveBalanceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveBalanceFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LeaveBalance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaveBalanceFindUniqueOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LeaveBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaveBalanceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveBalanceFindFirstArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LeaveBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaveBalanceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveBalanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LeaveBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany()
     * 
     * // Get first 10 LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaveBalanceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveBalanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LeaveBalance.
     * @param {LeaveBalanceCreateArgs} args - Arguments to create a LeaveBalance.
     * @example
     * // Create one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.create({
     *   data: {
     *     // ... data to create a LeaveBalance
     *   }
     * })
     * 
    **/
    create<T extends LeaveBalanceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveBalanceCreateArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a LeaveBalance.
     * @param {LeaveBalanceDeleteArgs} args - Arguments to delete one LeaveBalance.
     * @example
     * // Delete one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.delete({
     *   where: {
     *     // ... filter to delete one LeaveBalance
     *   }
     * })
     * 
    **/
    delete<T extends LeaveBalanceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveBalanceDeleteArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LeaveBalance.
     * @param {LeaveBalanceUpdateArgs} args - Arguments to update one LeaveBalance.
     * @example
     * // Update one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaveBalanceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveBalanceUpdateArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LeaveBalances.
     * @param {LeaveBalanceDeleteManyArgs} args - Arguments to filter LeaveBalances to delete.
     * @example
     * // Delete a few LeaveBalances
     * const { count } = await prisma.leaveBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaveBalanceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveBalanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaveBalanceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveBalanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveBalance.
     * @param {LeaveBalanceUpsertArgs} args - Arguments to update or create a LeaveBalance.
     * @example
     * // Update or create a LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.upsert({
     *   create: {
     *     // ... data to create a LeaveBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveBalance we want to update
     *   }
     * })
    **/
    upsert<T extends LeaveBalanceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveBalanceUpsertArgs<ExtArgs>>
    ): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceCountArgs} args - Arguments to filter LeaveBalances to count.
     * @example
     * // Count the number of LeaveBalances
     * const count = await prisma.leaveBalance.count({
     *   where: {
     *     // ... the filter for the LeaveBalances we want to count
     *   }
     * })
    **/
    count<T extends LeaveBalanceCountArgs>(
      args?: Subset<T, LeaveBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveBalanceAggregateArgs>(args: Subset<T, LeaveBalanceAggregateArgs>): Prisma.PrismaPromise<GetLeaveBalanceAggregateType<T>>

    /**
     * Group by LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveBalanceGroupByArgs['orderBy'] }
        : { orderBy?: LeaveBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveBalance model
   */
  readonly fields: LeaveBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    leaveType<T extends LeaveTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveTypeDefaultArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LeaveBalance model
   */ 
  interface LeaveBalanceFieldRefs {
    readonly id: FieldRef<"LeaveBalance", 'String'>
    readonly total: FieldRef<"LeaveBalance", 'Float'>
    readonly used: FieldRef<"LeaveBalance", 'Float'>
    readonly pending: FieldRef<"LeaveBalance", 'Float'>
    readonly remaining: FieldRef<"LeaveBalance", 'Float'>
    readonly userId: FieldRef<"LeaveBalance", 'String'>
    readonly leaveTypeId: FieldRef<"LeaveBalance", 'String'>
    readonly year: FieldRef<"LeaveBalance", 'Int'>
    readonly createdAt: FieldRef<"LeaveBalance", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveBalance", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * LeaveBalance findUnique
   */
  export type LeaveBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }


  /**
   * LeaveBalance findUniqueOrThrow
   */
  export type LeaveBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }


  /**
   * LeaveBalance findFirst
   */
  export type LeaveBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }


  /**
   * LeaveBalance findFirstOrThrow
   */
  export type LeaveBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }


  /**
   * LeaveBalance findMany
   */
  export type LeaveBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalances to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }


  /**
   * LeaveBalance create
   */
  export type LeaveBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveBalance.
     */
    data: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
  }


  /**
   * LeaveBalance update
   */
  export type LeaveBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveBalance.
     */
    data: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
    /**
     * Choose, which LeaveBalance to update.
     */
    where: LeaveBalanceWhereUniqueInput
  }


  /**
   * LeaveBalance updateMany
   */
  export type LeaveBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveBalances.
     */
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyInput>
    /**
     * Filter which LeaveBalances to update
     */
    where?: LeaveBalanceWhereInput
  }


  /**
   * LeaveBalance upsert
   */
  export type LeaveBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveBalance to update in case it exists.
     */
    where: LeaveBalanceWhereUniqueInput
    /**
     * In case the LeaveBalance found by the `where` argument doesn't exist, create a new LeaveBalance with this data.
     */
    create: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
    /**
     * In case the LeaveBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
  }


  /**
   * LeaveBalance delete
   */
  export type LeaveBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter which LeaveBalance to delete.
     */
    where: LeaveBalanceWhereUniqueInput
  }


  /**
   * LeaveBalance deleteMany
   */
  export type LeaveBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalances to delete
     */
    where?: LeaveBalanceWhereInput
  }


  /**
   * LeaveBalance without action
   */
  export type LeaveBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
  }



  /**
   * Model SalaryRevision
   */

  export type AggregateSalaryRevision = {
    _count: SalaryRevisionCountAggregateOutputType | null
    _avg: SalaryRevisionAvgAggregateOutputType | null
    _sum: SalaryRevisionSumAggregateOutputType | null
    _min: SalaryRevisionMinAggregateOutputType | null
    _max: SalaryRevisionMaxAggregateOutputType | null
  }

  export type SalaryRevisionAvgAggregateOutputType = {
    amount: number | null
    basic: number | null
    hra: number | null
    allowance: number | null
    tax: number | null
    pf: number | null
    insurance: number | null
    otherDeductions: number | null
    netSalary: number | null
  }

  export type SalaryRevisionSumAggregateOutputType = {
    amount: number | null
    basic: number | null
    hra: number | null
    allowance: number | null
    tax: number | null
    pf: number | null
    insurance: number | null
    otherDeductions: number | null
    netSalary: number | null
  }

  export type SalaryRevisionMinAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    revisionDate: Date | null
    effectiveDate: Date | null
    reason: string | null
    type: string | null
    basic: number | null
    hra: number | null
    allowance: number | null
    tax: number | null
    pf: number | null
    insurance: number | null
    otherDeductions: number | null
    netSalary: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryRevisionMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    revisionDate: Date | null
    effectiveDate: Date | null
    reason: string | null
    type: string | null
    basic: number | null
    hra: number | null
    allowance: number | null
    tax: number | null
    pf: number | null
    insurance: number | null
    otherDeductions: number | null
    netSalary: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryRevisionCountAggregateOutputType = {
    id: number
    amount: number
    currency: number
    revisionDate: number
    effectiveDate: number
    reason: number
    type: number
    basic: number
    hra: number
    allowance: number
    tax: number
    pf: number
    insurance: number
    otherDeductions: number
    netSalary: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalaryRevisionAvgAggregateInputType = {
    amount?: true
    basic?: true
    hra?: true
    allowance?: true
    tax?: true
    pf?: true
    insurance?: true
    otherDeductions?: true
    netSalary?: true
  }

  export type SalaryRevisionSumAggregateInputType = {
    amount?: true
    basic?: true
    hra?: true
    allowance?: true
    tax?: true
    pf?: true
    insurance?: true
    otherDeductions?: true
    netSalary?: true
  }

  export type SalaryRevisionMinAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    revisionDate?: true
    effectiveDate?: true
    reason?: true
    type?: true
    basic?: true
    hra?: true
    allowance?: true
    tax?: true
    pf?: true
    insurance?: true
    otherDeductions?: true
    netSalary?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryRevisionMaxAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    revisionDate?: true
    effectiveDate?: true
    reason?: true
    type?: true
    basic?: true
    hra?: true
    allowance?: true
    tax?: true
    pf?: true
    insurance?: true
    otherDeductions?: true
    netSalary?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryRevisionCountAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    revisionDate?: true
    effectiveDate?: true
    reason?: true
    type?: true
    basic?: true
    hra?: true
    allowance?: true
    tax?: true
    pf?: true
    insurance?: true
    otherDeductions?: true
    netSalary?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalaryRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRevision to aggregate.
     */
    where?: SalaryRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRevisions to fetch.
     */
    orderBy?: SalaryRevisionOrderByWithRelationInput | SalaryRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryRevisions
    **/
    _count?: true | SalaryRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryRevisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryRevisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryRevisionMaxAggregateInputType
  }

  export type GetSalaryRevisionAggregateType<T extends SalaryRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryRevision[P]>
      : GetScalarType<T[P], AggregateSalaryRevision[P]>
  }




  export type SalaryRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRevisionWhereInput
    orderBy?: SalaryRevisionOrderByWithAggregationInput | SalaryRevisionOrderByWithAggregationInput[]
    by: SalaryRevisionScalarFieldEnum[] | SalaryRevisionScalarFieldEnum
    having?: SalaryRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryRevisionCountAggregateInputType | true
    _avg?: SalaryRevisionAvgAggregateInputType
    _sum?: SalaryRevisionSumAggregateInputType
    _min?: SalaryRevisionMinAggregateInputType
    _max?: SalaryRevisionMaxAggregateInputType
  }

  export type SalaryRevisionGroupByOutputType = {
    id: string
    amount: number
    currency: string
    revisionDate: Date
    effectiveDate: Date
    reason: string | null
    type: string
    basic: number
    hra: number
    allowance: number
    tax: number
    pf: number
    insurance: number
    otherDeductions: number
    netSalary: number
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: SalaryRevisionCountAggregateOutputType | null
    _avg: SalaryRevisionAvgAggregateOutputType | null
    _sum: SalaryRevisionSumAggregateOutputType | null
    _min: SalaryRevisionMinAggregateOutputType | null
    _max: SalaryRevisionMaxAggregateOutputType | null
  }

  type GetSalaryRevisionGroupByPayload<T extends SalaryRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryRevisionGroupByOutputType[P]>
        }
      >
    >


  export type SalaryRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    revisionDate?: boolean
    effectiveDate?: boolean
    reason?: boolean
    type?: boolean
    basic?: boolean
    hra?: boolean
    allowance?: boolean
    tax?: boolean
    pf?: boolean
    insurance?: boolean
    otherDeductions?: boolean
    netSalary?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryRevision"]>

  export type SalaryRevisionSelectScalar = {
    id?: boolean
    amount?: boolean
    currency?: boolean
    revisionDate?: boolean
    effectiveDate?: boolean
    reason?: boolean
    type?: boolean
    basic?: boolean
    hra?: boolean
    allowance?: boolean
    tax?: boolean
    pf?: boolean
    insurance?: boolean
    otherDeductions?: boolean
    netSalary?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalaryRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $SalaryRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryRevision"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      currency: string
      revisionDate: Date
      effectiveDate: Date
      reason: string | null
      type: string
      basic: number
      hra: number
      allowance: number
      tax: number
      pf: number
      insurance: number
      otherDeductions: number
      netSalary: number
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salaryRevision"]>
    composites: {}
  }


  type SalaryRevisionGetPayload<S extends boolean | null | undefined | SalaryRevisionDefaultArgs> = $Result.GetResult<Prisma.$SalaryRevisionPayload, S>

  type SalaryRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryRevisionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryRevisionCountAggregateInputType | true
    }

  export interface SalaryRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryRevision'], meta: { name: 'SalaryRevision' } }
    /**
     * Find zero or one SalaryRevision that matches the filter.
     * @param {SalaryRevisionFindUniqueArgs} args - Arguments to find a SalaryRevision
     * @example
     * // Get one SalaryRevision
     * const salaryRevision = await prisma.salaryRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalaryRevisionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SalaryRevisionFindUniqueArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SalaryRevision that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SalaryRevisionFindUniqueOrThrowArgs} args - Arguments to find a SalaryRevision
     * @example
     * // Get one SalaryRevision
     * const salaryRevision = await prisma.salaryRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalaryRevisionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SalaryRevisionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SalaryRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRevisionFindFirstArgs} args - Arguments to find a SalaryRevision
     * @example
     * // Get one SalaryRevision
     * const salaryRevision = await prisma.salaryRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalaryRevisionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SalaryRevisionFindFirstArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SalaryRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRevisionFindFirstOrThrowArgs} args - Arguments to find a SalaryRevision
     * @example
     * // Get one SalaryRevision
     * const salaryRevision = await prisma.salaryRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalaryRevisionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SalaryRevisionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SalaryRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRevisionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryRevisions
     * const salaryRevisions = await prisma.salaryRevision.findMany()
     * 
     * // Get first 10 SalaryRevisions
     * const salaryRevisions = await prisma.salaryRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryRevisionWithIdOnly = await prisma.salaryRevision.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalaryRevisionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SalaryRevisionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SalaryRevision.
     * @param {SalaryRevisionCreateArgs} args - Arguments to create a SalaryRevision.
     * @example
     * // Create one SalaryRevision
     * const SalaryRevision = await prisma.salaryRevision.create({
     *   data: {
     *     // ... data to create a SalaryRevision
     *   }
     * })
     * 
    **/
    create<T extends SalaryRevisionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SalaryRevisionCreateArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a SalaryRevision.
     * @param {SalaryRevisionDeleteArgs} args - Arguments to delete one SalaryRevision.
     * @example
     * // Delete one SalaryRevision
     * const SalaryRevision = await prisma.salaryRevision.delete({
     *   where: {
     *     // ... filter to delete one SalaryRevision
     *   }
     * })
     * 
    **/
    delete<T extends SalaryRevisionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SalaryRevisionDeleteArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SalaryRevision.
     * @param {SalaryRevisionUpdateArgs} args - Arguments to update one SalaryRevision.
     * @example
     * // Update one SalaryRevision
     * const salaryRevision = await prisma.salaryRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalaryRevisionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SalaryRevisionUpdateArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SalaryRevisions.
     * @param {SalaryRevisionDeleteManyArgs} args - Arguments to filter SalaryRevisions to delete.
     * @example
     * // Delete a few SalaryRevisions
     * const { count } = await prisma.salaryRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalaryRevisionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SalaryRevisionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryRevisions
     * const salaryRevision = await prisma.salaryRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalaryRevisionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SalaryRevisionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryRevision.
     * @param {SalaryRevisionUpsertArgs} args - Arguments to update or create a SalaryRevision.
     * @example
     * // Update or create a SalaryRevision
     * const salaryRevision = await prisma.salaryRevision.upsert({
     *   create: {
     *     // ... data to create a SalaryRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryRevision we want to update
     *   }
     * })
    **/
    upsert<T extends SalaryRevisionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SalaryRevisionUpsertArgs<ExtArgs>>
    ): Prisma__SalaryRevisionClient<$Result.GetResult<Prisma.$SalaryRevisionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SalaryRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRevisionCountArgs} args - Arguments to filter SalaryRevisions to count.
     * @example
     * // Count the number of SalaryRevisions
     * const count = await prisma.salaryRevision.count({
     *   where: {
     *     // ... the filter for the SalaryRevisions we want to count
     *   }
     * })
    **/
    count<T extends SalaryRevisionCountArgs>(
      args?: Subset<T, SalaryRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryRevisionAggregateArgs>(args: Subset<T, SalaryRevisionAggregateArgs>): Prisma.PrismaPromise<GetSalaryRevisionAggregateType<T>>

    /**
     * Group by SalaryRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryRevisionGroupByArgs['orderBy'] }
        : { orderBy?: SalaryRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryRevision model
   */
  readonly fields: SalaryRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SalaryRevision model
   */ 
  interface SalaryRevisionFieldRefs {
    readonly id: FieldRef<"SalaryRevision", 'String'>
    readonly amount: FieldRef<"SalaryRevision", 'Float'>
    readonly currency: FieldRef<"SalaryRevision", 'String'>
    readonly revisionDate: FieldRef<"SalaryRevision", 'DateTime'>
    readonly effectiveDate: FieldRef<"SalaryRevision", 'DateTime'>
    readonly reason: FieldRef<"SalaryRevision", 'String'>
    readonly type: FieldRef<"SalaryRevision", 'String'>
    readonly basic: FieldRef<"SalaryRevision", 'Float'>
    readonly hra: FieldRef<"SalaryRevision", 'Float'>
    readonly allowance: FieldRef<"SalaryRevision", 'Float'>
    readonly tax: FieldRef<"SalaryRevision", 'Float'>
    readonly pf: FieldRef<"SalaryRevision", 'Float'>
    readonly insurance: FieldRef<"SalaryRevision", 'Float'>
    readonly otherDeductions: FieldRef<"SalaryRevision", 'Float'>
    readonly netSalary: FieldRef<"SalaryRevision", 'Float'>
    readonly userId: FieldRef<"SalaryRevision", 'String'>
    readonly createdAt: FieldRef<"SalaryRevision", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryRevision", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SalaryRevision findUnique
   */
  export type SalaryRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRevision to fetch.
     */
    where: SalaryRevisionWhereUniqueInput
  }


  /**
   * SalaryRevision findUniqueOrThrow
   */
  export type SalaryRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRevision to fetch.
     */
    where: SalaryRevisionWhereUniqueInput
  }


  /**
   * SalaryRevision findFirst
   */
  export type SalaryRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRevision to fetch.
     */
    where?: SalaryRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRevisions to fetch.
     */
    orderBy?: SalaryRevisionOrderByWithRelationInput | SalaryRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRevisions.
     */
    cursor?: SalaryRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRevisions.
     */
    distinct?: SalaryRevisionScalarFieldEnum | SalaryRevisionScalarFieldEnum[]
  }


  /**
   * SalaryRevision findFirstOrThrow
   */
  export type SalaryRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRevision to fetch.
     */
    where?: SalaryRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRevisions to fetch.
     */
    orderBy?: SalaryRevisionOrderByWithRelationInput | SalaryRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRevisions.
     */
    cursor?: SalaryRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRevisions.
     */
    distinct?: SalaryRevisionScalarFieldEnum | SalaryRevisionScalarFieldEnum[]
  }


  /**
   * SalaryRevision findMany
   */
  export type SalaryRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRevisions to fetch.
     */
    where?: SalaryRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRevisions to fetch.
     */
    orderBy?: SalaryRevisionOrderByWithRelationInput | SalaryRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryRevisions.
     */
    cursor?: SalaryRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRevisions.
     */
    skip?: number
    distinct?: SalaryRevisionScalarFieldEnum | SalaryRevisionScalarFieldEnum[]
  }


  /**
   * SalaryRevision create
   */
  export type SalaryRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryRevision.
     */
    data: XOR<SalaryRevisionCreateInput, SalaryRevisionUncheckedCreateInput>
  }


  /**
   * SalaryRevision update
   */
  export type SalaryRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryRevision.
     */
    data: XOR<SalaryRevisionUpdateInput, SalaryRevisionUncheckedUpdateInput>
    /**
     * Choose, which SalaryRevision to update.
     */
    where: SalaryRevisionWhereUniqueInput
  }


  /**
   * SalaryRevision updateMany
   */
  export type SalaryRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryRevisions.
     */
    data: XOR<SalaryRevisionUpdateManyMutationInput, SalaryRevisionUncheckedUpdateManyInput>
    /**
     * Filter which SalaryRevisions to update
     */
    where?: SalaryRevisionWhereInput
  }


  /**
   * SalaryRevision upsert
   */
  export type SalaryRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryRevision to update in case it exists.
     */
    where: SalaryRevisionWhereUniqueInput
    /**
     * In case the SalaryRevision found by the `where` argument doesn't exist, create a new SalaryRevision with this data.
     */
    create: XOR<SalaryRevisionCreateInput, SalaryRevisionUncheckedCreateInput>
    /**
     * In case the SalaryRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryRevisionUpdateInput, SalaryRevisionUncheckedUpdateInput>
  }


  /**
   * SalaryRevision delete
   */
  export type SalaryRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
    /**
     * Filter which SalaryRevision to delete.
     */
    where: SalaryRevisionWhereUniqueInput
  }


  /**
   * SalaryRevision deleteMany
   */
  export type SalaryRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRevisions to delete
     */
    where?: SalaryRevisionWhereInput
  }


  /**
   * SalaryRevision without action
   */
  export type SalaryRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRevision
     */
    select?: SalaryRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalaryRevisionInclude<ExtArgs> | null
  }



  /**
   * Model Classroom
   */

  export type AggregateClassroom = {
    _count: ClassroomCountAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  export type ClassroomMinAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomCountAggregateOutputType = {
    id: number
    name: number
    schoolId: number
    teacherId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassroomMinAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomMaxAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomCountAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classroom to aggregate.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classrooms
    **/
    _count?: true | ClassroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomMaxAggregateInputType
  }

  export type GetClassroomAggregateType<T extends ClassroomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroom[P]>
      : GetScalarType<T[P], AggregateClassroom[P]>
  }




  export type ClassroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithAggregationInput | ClassroomOrderByWithAggregationInput[]
    by: ClassroomScalarFieldEnum[] | ClassroomScalarFieldEnum
    having?: ClassroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomCountAggregateInputType | true
    _min?: ClassroomMinAggregateInputType
    _max?: ClassroomMaxAggregateInputType
  }

  export type ClassroomGroupByOutputType = {
    id: string
    name: string
    schoolId: string
    teacherId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClassroomCountAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  type GetClassroomGroupByPayload<T extends ClassroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
    students?: boolean | Classroom$studentsArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectScalar = {
    id?: boolean
    name?: boolean
    schoolId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
    students?: boolean | Classroom$studentsArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClassroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classroom"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      teacher: Prisma.$UserPayload<ExtArgs> | null
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      schoolId: string
      teacherId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classroom"]>
    composites: {}
  }


  type ClassroomGetPayload<S extends boolean | null | undefined | ClassroomDefaultArgs> = $Result.GetResult<Prisma.$ClassroomPayload, S>

  type ClassroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassroomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassroomCountAggregateInputType | true
    }

  export interface ClassroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classroom'], meta: { name: 'Classroom' } }
    /**
     * Find zero or one Classroom that matches the filter.
     * @param {ClassroomFindUniqueArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassroomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClassroomFindUniqueArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Classroom that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClassroomFindUniqueOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClassroomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassroomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Classroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassroomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassroomFindFirstArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Classroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClassroomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassroomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Classrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classrooms
     * const classrooms = await prisma.classroom.findMany()
     * 
     * // Get first 10 Classrooms
     * const classrooms = await prisma.classroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomWithIdOnly = await prisma.classroom.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassroomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassroomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Classroom.
     * @param {ClassroomCreateArgs} args - Arguments to create a Classroom.
     * @example
     * // Create one Classroom
     * const Classroom = await prisma.classroom.create({
     *   data: {
     *     // ... data to create a Classroom
     *   }
     * })
     * 
    **/
    create<T extends ClassroomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClassroomCreateArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Classroom.
     * @param {ClassroomDeleteArgs} args - Arguments to delete one Classroom.
     * @example
     * // Delete one Classroom
     * const Classroom = await prisma.classroom.delete({
     *   where: {
     *     // ... filter to delete one Classroom
     *   }
     * })
     * 
    **/
    delete<T extends ClassroomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClassroomDeleteArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Classroom.
     * @param {ClassroomUpdateArgs} args - Arguments to update one Classroom.
     * @example
     * // Update one Classroom
     * const classroom = await prisma.classroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassroomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClassroomUpdateArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Classrooms.
     * @param {ClassroomDeleteManyArgs} args - Arguments to filter Classrooms to delete.
     * @example
     * // Delete a few Classrooms
     * const { count } = await prisma.classroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassroomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassroomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassroomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClassroomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Classroom.
     * @param {ClassroomUpsertArgs} args - Arguments to update or create a Classroom.
     * @example
     * // Update or create a Classroom
     * const classroom = await prisma.classroom.upsert({
     *   create: {
     *     // ... data to create a Classroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classroom we want to update
     *   }
     * })
    **/
    upsert<T extends ClassroomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClassroomUpsertArgs<ExtArgs>>
    ): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCountArgs} args - Arguments to filter Classrooms to count.
     * @example
     * // Count the number of Classrooms
     * const count = await prisma.classroom.count({
     *   where: {
     *     // ... the filter for the Classrooms we want to count
     *   }
     * })
    **/
    count<T extends ClassroomCountArgs>(
      args?: Subset<T, ClassroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomAggregateArgs>(args: Subset<T, ClassroomAggregateArgs>): Prisma.PrismaPromise<GetClassroomAggregateType<T>>

    /**
     * Group by Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classroom model
   */
  readonly fields: ClassroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    teacher<T extends Classroom$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$teacherArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    students<T extends Classroom$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Classroom model
   */ 
  interface ClassroomFieldRefs {
    readonly id: FieldRef<"Classroom", 'String'>
    readonly name: FieldRef<"Classroom", 'String'>
    readonly schoolId: FieldRef<"Classroom", 'String'>
    readonly teacherId: FieldRef<"Classroom", 'String'>
    readonly createdAt: FieldRef<"Classroom", 'DateTime'>
    readonly updatedAt: FieldRef<"Classroom", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Classroom findUnique
   */
  export type ClassroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }


  /**
   * Classroom findUniqueOrThrow
   */
  export type ClassroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }


  /**
   * Classroom findFirst
   */
  export type ClassroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }


  /**
   * Classroom findFirstOrThrow
   */
  export type ClassroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }


  /**
   * Classroom findMany
   */
  export type ClassroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classrooms to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }


  /**
   * Classroom create
   */
  export type ClassroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to create a Classroom.
     */
    data: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
  }


  /**
   * Classroom update
   */
  export type ClassroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to update a Classroom.
     */
    data: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
    /**
     * Choose, which Classroom to update.
     */
    where: ClassroomWhereUniqueInput
  }


  /**
   * Classroom updateMany
   */
  export type ClassroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classrooms.
     */
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyInput>
    /**
     * Filter which Classrooms to update
     */
    where?: ClassroomWhereInput
  }


  /**
   * Classroom upsert
   */
  export type ClassroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The filter to search for the Classroom to update in case it exists.
     */
    where: ClassroomWhereUniqueInput
    /**
     * In case the Classroom found by the `where` argument doesn't exist, create a new Classroom with this data.
     */
    create: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
    /**
     * In case the Classroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
  }


  /**
   * Classroom delete
   */
  export type ClassroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter which Classroom to delete.
     */
    where: ClassroomWhereUniqueInput
  }


  /**
   * Classroom deleteMany
   */
  export type ClassroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classrooms to delete
     */
    where?: ClassroomWhereInput
  }


  /**
   * Classroom.teacher
   */
  export type Classroom$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Classroom.students
   */
  export type Classroom$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Classroom without action
   */
  export type ClassroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
  }



  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    age: number | null
  }

  export type StudentSumAggregateOutputType = {
    age: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    age: number | null
    gender: string | null
    dateOfBirth: Date | null
    grade: string | null
    status: string | null
    parentName: string | null
    parentMobile: string | null
    parentEmail: string | null
    bloodGroup: string | null
    medicalConditions: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    classroomId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    age: number | null
    gender: string | null
    dateOfBirth: Date | null
    grade: string | null
    status: string | null
    parentName: string | null
    parentMobile: string | null
    parentEmail: string | null
    bloodGroup: string | null
    medicalConditions: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    classroomId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    avatar: number
    age: number
    gender: number
    dateOfBirth: number
    grade: number
    status: number
    parentName: number
    parentMobile: number
    parentEmail: number
    bloodGroup: number
    medicalConditions: number
    allergies: number
    emergencyContactName: number
    emergencyContactPhone: number
    classroomId: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    age?: true
  }

  export type StudentSumAggregateInputType = {
    age?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    avatar?: true
    age?: true
    gender?: true
    dateOfBirth?: true
    grade?: true
    status?: true
    parentName?: true
    parentMobile?: true
    parentEmail?: true
    bloodGroup?: true
    medicalConditions?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    classroomId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    avatar?: true
    age?: true
    gender?: true
    dateOfBirth?: true
    grade?: true
    status?: true
    parentName?: true
    parentMobile?: true
    parentEmail?: true
    bloodGroup?: true
    medicalConditions?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    classroomId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    avatar?: true
    age?: true
    gender?: true
    dateOfBirth?: true
    grade?: true
    status?: true
    parentName?: true
    parentMobile?: true
    parentEmail?: true
    bloodGroup?: true
    medicalConditions?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    classroomId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    avatar: string | null
    age: number | null
    gender: string | null
    dateOfBirth: Date | null
    grade: string | null
    status: string
    parentName: string | null
    parentMobile: string | null
    parentEmail: string | null
    bloodGroup: string | null
    medicalConditions: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    classroomId: string | null
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    age?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    grade?: boolean
    status?: boolean
    parentName?: boolean
    parentMobile?: boolean
    parentEmail?: boolean
    bloodGroup?: boolean
    medicalConditions?: boolean
    allergies?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    classroomId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classroom?: boolean | Student$classroomArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    reports?: boolean | Student$reportsArgs<ExtArgs>
    fees?: boolean | Student$feesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    age?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    grade?: boolean
    status?: boolean
    parentName?: boolean
    parentMobile?: boolean
    parentEmail?: boolean
    bloodGroup?: boolean
    medicalConditions?: boolean
    allergies?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    classroomId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | Student$classroomArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    reports?: boolean | Student$reportsArgs<ExtArgs>
    fees?: boolean | Student$feesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      classroom: Prisma.$ClassroomPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      reports: Prisma.$ReportCardPayload<ExtArgs>[]
      fees: Prisma.$FeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      avatar: string | null
      age: number | null
      gender: string | null
      dateOfBirth: Date | null
      grade: string | null
      status: string
      parentName: string | null
      parentMobile: string | null
      parentEmail: string | null
      bloodGroup: string | null
      medicalConditions: string | null
      allergies: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      classroomId: string | null
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }


  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentCreateArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    classroom<T extends Student$classroomArgs<ExtArgs> = {}>(args?: Subset<T, Student$classroomArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    attendance<T extends Student$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findMany'> | Null>;

    reports<T extends Student$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Student$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'findMany'> | Null>;

    fees<T extends Student$feesArgs<ExtArgs> = {}>(args?: Subset<T, Student$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly avatar: FieldRef<"Student", 'String'>
    readonly age: FieldRef<"Student", 'Int'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly grade: FieldRef<"Student", 'String'>
    readonly status: FieldRef<"Student", 'String'>
    readonly parentName: FieldRef<"Student", 'String'>
    readonly parentMobile: FieldRef<"Student", 'String'>
    readonly parentEmail: FieldRef<"Student", 'String'>
    readonly bloodGroup: FieldRef<"Student", 'String'>
    readonly medicalConditions: FieldRef<"Student", 'String'>
    readonly allergies: FieldRef<"Student", 'String'>
    readonly emergencyContactName: FieldRef<"Student", 'String'>
    readonly emergencyContactPhone: FieldRef<"Student", 'String'>
    readonly classroomId: FieldRef<"Student", 'String'>
    readonly schoolId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }


  /**
   * Student.classroom
   */
  export type Student$classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
  }


  /**
   * Student.attendance
   */
  export type Student$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }


  /**
   * Student.reports
   */
  export type Student$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    cursor?: ReportCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }


  /**
   * Student.fees
   */
  export type Student$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    where?: FeeWhereInput
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    cursor?: FeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }


  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
  }



  /**
   * Model Fee
   */

  export type AggregateFee = {
    _count: FeeCountAggregateOutputType | null
    _avg: FeeAvgAggregateOutputType | null
    _sum: FeeSumAggregateOutputType | null
    _min: FeeMinAggregateOutputType | null
    _max: FeeMaxAggregateOutputType | null
  }

  export type FeeAvgAggregateOutputType = {
    amount: number | null
  }

  export type FeeSumAggregateOutputType = {
    amount: number | null
  }

  export type FeeMinAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeCountAggregateOutputType = {
    id: number
    title: number
    amount: number
    dueDate: number
    status: number
    studentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeAvgAggregateInputType = {
    amount?: true
  }

  export type FeeSumAggregateInputType = {
    amount?: true
  }

  export type FeeMinAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    dueDate?: true
    status?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeMaxAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    dueDate?: true
    status?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeCountAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    dueDate?: true
    status?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fee to aggregate.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fees
    **/
    _count?: true | FeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeMaxAggregateInputType
  }

  export type GetFeeAggregateType<T extends FeeAggregateArgs> = {
        [P in keyof T & keyof AggregateFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFee[P]>
      : GetScalarType<T[P], AggregateFee[P]>
  }




  export type FeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
    orderBy?: FeeOrderByWithAggregationInput | FeeOrderByWithAggregationInput[]
    by: FeeScalarFieldEnum[] | FeeScalarFieldEnum
    having?: FeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeCountAggregateInputType | true
    _avg?: FeeAvgAggregateInputType
    _sum?: FeeSumAggregateInputType
    _min?: FeeMinAggregateInputType
    _max?: FeeMaxAggregateInputType
  }

  export type FeeGroupByOutputType = {
    id: string
    title: string
    amount: number
    dueDate: Date
    status: string
    studentId: string
    createdAt: Date
    updatedAt: Date
    _count: FeeCountAggregateOutputType | null
    _avg: FeeAvgAggregateOutputType | null
    _sum: FeeSumAggregateOutputType | null
    _min: FeeMinAggregateOutputType | null
    _max: FeeMaxAggregateOutputType | null
  }

  type GetFeeGroupByPayload<T extends FeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeGroupByOutputType[P]>
            : GetScalarType<T[P], FeeGroupByOutputType[P]>
        }
      >
    >


  export type FeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    payments?: boolean | Fee$paymentsArgs<ExtArgs>
    _count?: boolean | FeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fee"]>

  export type FeeSelectScalar = {
    id?: boolean
    title?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    payments?: boolean | Fee$paymentsArgs<ExtArgs>
    _count?: boolean | FeeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fee"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      payments: Prisma.$FeePaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      amount: number
      dueDate: Date
      status: string
      studentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fee"]>
    composites: {}
  }


  type FeeGetPayload<S extends boolean | null | undefined | FeeDefaultArgs> = $Result.GetResult<Prisma.$FeePayload, S>

  type FeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeeCountAggregateInputType | true
    }

  export interface FeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fee'], meta: { name: 'Fee' } }
    /**
     * Find zero or one Fee that matches the filter.
     * @param {FeeFindUniqueArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeeFindUniqueArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Fee that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeeFindUniqueOrThrowArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Fee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindFirstArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeFindFirstArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Fee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindFirstOrThrowArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fees
     * const fees = await prisma.fee.findMany()
     * 
     * // Get first 10 Fees
     * const fees = await prisma.fee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeWithIdOnly = await prisma.fee.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Fee.
     * @param {FeeCreateArgs} args - Arguments to create a Fee.
     * @example
     * // Create one Fee
     * const Fee = await prisma.fee.create({
     *   data: {
     *     // ... data to create a Fee
     *   }
     * })
     * 
    **/
    create<T extends FeeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeCreateArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Fee.
     * @param {FeeDeleteArgs} args - Arguments to delete one Fee.
     * @example
     * // Delete one Fee
     * const Fee = await prisma.fee.delete({
     *   where: {
     *     // ... filter to delete one Fee
     *   }
     * })
     * 
    **/
    delete<T extends FeeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeeDeleteArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Fee.
     * @param {FeeUpdateArgs} args - Arguments to update one Fee.
     * @example
     * // Update one Fee
     * const fee = await prisma.fee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeUpdateArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fees.
     * @param {FeeDeleteManyArgs} args - Arguments to filter Fees to delete.
     * @example
     * // Delete a few Fees
     * const { count } = await prisma.fee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fees
     * const fee = await prisma.fee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fee.
     * @param {FeeUpsertArgs} args - Arguments to update or create a Fee.
     * @example
     * // Update or create a Fee
     * const fee = await prisma.fee.upsert({
     *   create: {
     *     // ... data to create a Fee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fee we want to update
     *   }
     * })
    **/
    upsert<T extends FeeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeeUpsertArgs<ExtArgs>>
    ): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCountArgs} args - Arguments to filter Fees to count.
     * @example
     * // Count the number of Fees
     * const count = await prisma.fee.count({
     *   where: {
     *     // ... the filter for the Fees we want to count
     *   }
     * })
    **/
    count<T extends FeeCountArgs>(
      args?: Subset<T, FeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeAggregateArgs>(args: Subset<T, FeeAggregateArgs>): Prisma.PrismaPromise<GetFeeAggregateType<T>>

    /**
     * Group by Fee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeGroupByArgs['orderBy'] }
        : { orderBy?: FeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fee model
   */
  readonly fields: FeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    payments<T extends Fee$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Fee$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Fee model
   */ 
  interface FeeFieldRefs {
    readonly id: FieldRef<"Fee", 'String'>
    readonly title: FieldRef<"Fee", 'String'>
    readonly amount: FieldRef<"Fee", 'Float'>
    readonly dueDate: FieldRef<"Fee", 'DateTime'>
    readonly status: FieldRef<"Fee", 'String'>
    readonly studentId: FieldRef<"Fee", 'String'>
    readonly createdAt: FieldRef<"Fee", 'DateTime'>
    readonly updatedAt: FieldRef<"Fee", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Fee findUnique
   */
  export type FeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where: FeeWhereUniqueInput
  }


  /**
   * Fee findUniqueOrThrow
   */
  export type FeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where: FeeWhereUniqueInput
  }


  /**
   * Fee findFirst
   */
  export type FeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }


  /**
   * Fee findFirstOrThrow
   */
  export type FeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }


  /**
   * Fee findMany
   */
  export type FeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }


  /**
   * Fee create
   */
  export type FeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Fee.
     */
    data: XOR<FeeCreateInput, FeeUncheckedCreateInput>
  }


  /**
   * Fee update
   */
  export type FeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Fee.
     */
    data: XOR<FeeUpdateInput, FeeUncheckedUpdateInput>
    /**
     * Choose, which Fee to update.
     */
    where: FeeWhereUniqueInput
  }


  /**
   * Fee updateMany
   */
  export type FeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fees.
     */
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeeWhereInput
  }


  /**
   * Fee upsert
   */
  export type FeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Fee to update in case it exists.
     */
    where: FeeWhereUniqueInput
    /**
     * In case the Fee found by the `where` argument doesn't exist, create a new Fee with this data.
     */
    create: XOR<FeeCreateInput, FeeUncheckedCreateInput>
    /**
     * In case the Fee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeUpdateInput, FeeUncheckedUpdateInput>
  }


  /**
   * Fee delete
   */
  export type FeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter which Fee to delete.
     */
    where: FeeWhereUniqueInput
  }


  /**
   * Fee deleteMany
   */
  export type FeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fees to delete
     */
    where?: FeeWhereInput
  }


  /**
   * Fee.payments
   */
  export type Fee$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    cursor?: FeePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }


  /**
   * Fee without action
   */
  export type FeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
  }



  /**
   * Model FeePayment
   */

  export type AggregateFeePayment = {
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  export type FeePaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type FeePaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type FeePaymentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    date: Date | null
    method: string | null
    reference: string | null
    feeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeePaymentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    date: Date | null
    method: string | null
    reference: string | null
    feeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeePaymentCountAggregateOutputType = {
    id: number
    amount: number
    date: number
    method: number
    reference: number
    feeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeePaymentAvgAggregateInputType = {
    amount?: true
  }

  export type FeePaymentSumAggregateInputType = {
    amount?: true
  }

  export type FeePaymentMinAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    method?: true
    reference?: true
    feeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeePaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    method?: true
    reference?: true
    feeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeePaymentCountAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    method?: true
    reference?: true
    feeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayment to aggregate.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeePayments
    **/
    _count?: true | FeePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeePaymentMaxAggregateInputType
  }

  export type GetFeePaymentAggregateType<T extends FeePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeePayment[P]>
      : GetScalarType<T[P], AggregateFeePayment[P]>
  }




  export type FeePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithAggregationInput | FeePaymentOrderByWithAggregationInput[]
    by: FeePaymentScalarFieldEnum[] | FeePaymentScalarFieldEnum
    having?: FeePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeePaymentCountAggregateInputType | true
    _avg?: FeePaymentAvgAggregateInputType
    _sum?: FeePaymentSumAggregateInputType
    _min?: FeePaymentMinAggregateInputType
    _max?: FeePaymentMaxAggregateInputType
  }

  export type FeePaymentGroupByOutputType = {
    id: string
    amount: number
    date: Date
    method: string
    reference: string | null
    feeId: string
    createdAt: Date
    updatedAt: Date
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  type GetFeePaymentGroupByPayload<T extends FeePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
        }
      >
    >


  export type FeePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    date?: boolean
    method?: boolean
    reference?: boolean
    feeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fee?: boolean | FeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    date?: boolean
    method?: boolean
    reference?: boolean
    feeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | FeeDefaultArgs<ExtArgs>
  }


  export type $FeePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeePayment"
    objects: {
      fee: Prisma.$FeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      date: Date
      method: string
      reference: string | null
      feeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feePayment"]>
    composites: {}
  }


  type FeePaymentGetPayload<S extends boolean | null | undefined | FeePaymentDefaultArgs> = $Result.GetResult<Prisma.$FeePaymentPayload, S>

  type FeePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeePaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeePaymentCountAggregateInputType | true
    }

  export interface FeePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeePayment'], meta: { name: 'FeePayment' } }
    /**
     * Find zero or one FeePayment that matches the filter.
     * @param {FeePaymentFindUniqueArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeePaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeePaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeePayment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeePaymentFindUniqueOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeePaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeePaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeePaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeePaymentFindFirstArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeePaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeePaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeePayments
     * const feePayments = await prisma.feePayment.findMany()
     * 
     * // Get first 10 FeePayments
     * const feePayments = await prisma.feePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeePaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeePaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeePayment.
     * @param {FeePaymentCreateArgs} args - Arguments to create a FeePayment.
     * @example
     * // Create one FeePayment
     * const FeePayment = await prisma.feePayment.create({
     *   data: {
     *     // ... data to create a FeePayment
     *   }
     * })
     * 
    **/
    create<T extends FeePaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeePaymentCreateArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a FeePayment.
     * @param {FeePaymentDeleteArgs} args - Arguments to delete one FeePayment.
     * @example
     * // Delete one FeePayment
     * const FeePayment = await prisma.feePayment.delete({
     *   where: {
     *     // ... filter to delete one FeePayment
     *   }
     * })
     * 
    **/
    delete<T extends FeePaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeePaymentDeleteArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeePayment.
     * @param {FeePaymentUpdateArgs} args - Arguments to update one FeePayment.
     * @example
     * // Update one FeePayment
     * const feePayment = await prisma.feePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeePaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeePaymentUpdateArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeePayments.
     * @param {FeePaymentDeleteManyArgs} args - Arguments to filter FeePayments to delete.
     * @example
     * // Delete a few FeePayments
     * const { count } = await prisma.feePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeePaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeePaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeePayments
     * const feePayment = await prisma.feePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeePaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeePaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeePayment.
     * @param {FeePaymentUpsertArgs} args - Arguments to update or create a FeePayment.
     * @example
     * // Update or create a FeePayment
     * const feePayment = await prisma.feePayment.upsert({
     *   create: {
     *     // ... data to create a FeePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeePayment we want to update
     *   }
     * })
    **/
    upsert<T extends FeePaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeePaymentUpsertArgs<ExtArgs>>
    ): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentCountArgs} args - Arguments to filter FeePayments to count.
     * @example
     * // Count the number of FeePayments
     * const count = await prisma.feePayment.count({
     *   where: {
     *     // ... the filter for the FeePayments we want to count
     *   }
     * })
    **/
    count<T extends FeePaymentCountArgs>(
      args?: Subset<T, FeePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeePaymentAggregateArgs>(args: Subset<T, FeePaymentAggregateArgs>): Prisma.PrismaPromise<GetFeePaymentAggregateType<T>>

    /**
     * Group by FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeePaymentGroupByArgs['orderBy'] }
        : { orderBy?: FeePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeePayment model
   */
  readonly fields: FeePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fee<T extends FeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeDefaultArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeePayment model
   */ 
  interface FeePaymentFieldRefs {
    readonly id: FieldRef<"FeePayment", 'String'>
    readonly amount: FieldRef<"FeePayment", 'Float'>
    readonly date: FieldRef<"FeePayment", 'DateTime'>
    readonly method: FieldRef<"FeePayment", 'String'>
    readonly reference: FieldRef<"FeePayment", 'String'>
    readonly feeId: FieldRef<"FeePayment", 'String'>
    readonly createdAt: FieldRef<"FeePayment", 'DateTime'>
    readonly updatedAt: FieldRef<"FeePayment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * FeePayment findUnique
   */
  export type FeePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }


  /**
   * FeePayment findUniqueOrThrow
   */
  export type FeePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }


  /**
   * FeePayment findFirst
   */
  export type FeePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }


  /**
   * FeePayment findFirstOrThrow
   */
  export type FeePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }


  /**
   * FeePayment findMany
   */
  export type FeePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayments to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }


  /**
   * FeePayment create
   */
  export type FeePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeePayment.
     */
    data: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
  }


  /**
   * FeePayment update
   */
  export type FeePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeePayment.
     */
    data: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
    /**
     * Choose, which FeePayment to update.
     */
    where: FeePaymentWhereUniqueInput
  }


  /**
   * FeePayment updateMany
   */
  export type FeePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeePayments.
     */
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyInput>
    /**
     * Filter which FeePayments to update
     */
    where?: FeePaymentWhereInput
  }


  /**
   * FeePayment upsert
   */
  export type FeePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeePayment to update in case it exists.
     */
    where: FeePaymentWhereUniqueInput
    /**
     * In case the FeePayment found by the `where` argument doesn't exist, create a new FeePayment with this data.
     */
    create: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
    /**
     * In case the FeePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
  }


  /**
   * FeePayment delete
   */
  export type FeePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter which FeePayment to delete.
     */
    where: FeePaymentWhereUniqueInput
  }


  /**
   * FeePayment deleteMany
   */
  export type FeePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayments to delete
     */
    where?: FeePaymentWhereInput
  }


  /**
   * FeePayment without action
   */
  export type FeePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeePaymentInclude<ExtArgs> | null
  }



  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    date: Date | null
    status: string | null
    notes: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    status: string | null
    notes: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    date: number
    status: number
    notes: number
    studentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    date?: true
    status?: true
    notes?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    date?: true
    status?: true
    notes?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    date?: true
    status?: true
    notes?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    date: Date
    status: string
    notes: string | null
    studentId: string
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }


  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      status: string
      notes: string | null
      studentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }


  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttendanceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Attendance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttendanceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttendanceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
    **/
    create<T extends AttendanceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
    **/
    delete<T extends AttendanceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttendanceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttendanceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttendanceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
    **/
    upsert<T extends AttendanceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>
    ): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Attendance model
   */ 
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'String'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly studentId: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }


  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }


  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }


  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }


  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }


  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }


  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }


  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
  }


  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }


  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }


  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
  }


  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceInclude<ExtArgs> | null
  }



  /**
   * Model ReportCard
   */

  export type AggregateReportCard = {
    _count: ReportCardCountAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  export type ReportCardMinAggregateOutputType = {
    id: string | null
    term: string | null
    marks: string | null
    comments: string | null
    published: boolean | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCardMaxAggregateOutputType = {
    id: string | null
    term: string | null
    marks: string | null
    comments: string | null
    published: boolean | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCardCountAggregateOutputType = {
    id: number
    term: number
    marks: number
    comments: number
    published: number
    studentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportCardMinAggregateInputType = {
    id?: true
    term?: true
    marks?: true
    comments?: true
    published?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCardMaxAggregateInputType = {
    id?: true
    term?: true
    marks?: true
    comments?: true
    published?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCardCountAggregateInputType = {
    id?: true
    term?: true
    marks?: true
    comments?: true
    published?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCard to aggregate.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportCards
    **/
    _count?: true | ReportCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportCardMaxAggregateInputType
  }

  export type GetReportCardAggregateType<T extends ReportCardAggregateArgs> = {
        [P in keyof T & keyof AggregateReportCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportCard[P]>
      : GetScalarType<T[P], AggregateReportCard[P]>
  }




  export type ReportCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithAggregationInput | ReportCardOrderByWithAggregationInput[]
    by: ReportCardScalarFieldEnum[] | ReportCardScalarFieldEnum
    having?: ReportCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCardCountAggregateInputType | true
    _min?: ReportCardMinAggregateInputType
    _max?: ReportCardMaxAggregateInputType
  }

  export type ReportCardGroupByOutputType = {
    id: string
    term: string
    marks: string
    comments: string | null
    published: boolean
    studentId: string
    createdAt: Date
    updatedAt: Date
    _count: ReportCardCountAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  type GetReportCardGroupByPayload<T extends ReportCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
            : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
        }
      >
    >


  export type ReportCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    marks?: boolean
    comments?: boolean
    published?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectScalar = {
    id?: boolean
    term?: boolean
    marks?: boolean
    comments?: boolean
    published?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }


  export type $ReportCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportCard"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      term: string
      marks: string
      comments: string | null
      published: boolean
      studentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportCard"]>
    composites: {}
  }


  type ReportCardGetPayload<S extends boolean | null | undefined | ReportCardDefaultArgs> = $Result.GetResult<Prisma.$ReportCardPayload, S>

  type ReportCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCardCountAggregateInputType | true
    }

  export interface ReportCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportCard'], meta: { name: 'ReportCard' } }
    /**
     * Find zero or one ReportCard that matches the filter.
     * @param {ReportCardFindUniqueArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportCardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCardFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReportCard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportCardFindUniqueOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportCardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReportCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportCardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCardFindFirstArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReportCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportCardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReportCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportCards
     * const reportCards = await prisma.reportCard.findMany()
     * 
     * // Get first 10 ReportCards
     * const reportCards = await prisma.reportCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportCardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReportCard.
     * @param {ReportCardCreateArgs} args - Arguments to create a ReportCard.
     * @example
     * // Create one ReportCard
     * const ReportCard = await prisma.reportCard.create({
     *   data: {
     *     // ... data to create a ReportCard
     *   }
     * })
     * 
    **/
    create<T extends ReportCardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCardCreateArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a ReportCard.
     * @param {ReportCardDeleteArgs} args - Arguments to delete one ReportCard.
     * @example
     * // Delete one ReportCard
     * const ReportCard = await prisma.reportCard.delete({
     *   where: {
     *     // ... filter to delete one ReportCard
     *   }
     * })
     * 
    **/
    delete<T extends ReportCardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCardDeleteArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReportCard.
     * @param {ReportCardUpdateArgs} args - Arguments to update one ReportCard.
     * @example
     * // Update one ReportCard
     * const reportCard = await prisma.reportCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportCardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCardUpdateArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReportCards.
     * @param {ReportCardDeleteManyArgs} args - Arguments to filter ReportCards to delete.
     * @example
     * // Delete a few ReportCards
     * const { count } = await prisma.reportCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportCardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportCards
     * const reportCard = await prisma.reportCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportCardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportCard.
     * @param {ReportCardUpsertArgs} args - Arguments to update or create a ReportCard.
     * @example
     * // Update or create a ReportCard
     * const reportCard = await prisma.reportCard.upsert({
     *   create: {
     *     // ... data to create a ReportCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportCard we want to update
     *   }
     * })
    **/
    upsert<T extends ReportCardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCardUpsertArgs<ExtArgs>>
    ): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardCountArgs} args - Arguments to filter ReportCards to count.
     * @example
     * // Count the number of ReportCards
     * const count = await prisma.reportCard.count({
     *   where: {
     *     // ... the filter for the ReportCards we want to count
     *   }
     * })
    **/
    count<T extends ReportCardCountArgs>(
      args?: Subset<T, ReportCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportCardAggregateArgs>(args: Subset<T, ReportCardAggregateArgs>): Prisma.PrismaPromise<GetReportCardAggregateType<T>>

    /**
     * Group by ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportCardGroupByArgs['orderBy'] }
        : { orderBy?: ReportCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportCard model
   */
  readonly fields: ReportCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ReportCard model
   */ 
  interface ReportCardFieldRefs {
    readonly id: FieldRef<"ReportCard", 'String'>
    readonly term: FieldRef<"ReportCard", 'String'>
    readonly marks: FieldRef<"ReportCard", 'String'>
    readonly comments: FieldRef<"ReportCard", 'String'>
    readonly published: FieldRef<"ReportCard", 'Boolean'>
    readonly studentId: FieldRef<"ReportCard", 'String'>
    readonly createdAt: FieldRef<"ReportCard", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportCard", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ReportCard findUnique
   */
  export type ReportCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }


  /**
   * ReportCard findUniqueOrThrow
   */
  export type ReportCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }


  /**
   * ReportCard findFirst
   */
  export type ReportCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }


  /**
   * ReportCard findFirstOrThrow
   */
  export type ReportCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }


  /**
   * ReportCard findMany
   */
  export type ReportCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCards to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }


  /**
   * ReportCard create
   */
  export type ReportCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportCard.
     */
    data: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
  }


  /**
   * ReportCard update
   */
  export type ReportCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportCard.
     */
    data: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
    /**
     * Choose, which ReportCard to update.
     */
    where: ReportCardWhereUniqueInput
  }


  /**
   * ReportCard updateMany
   */
  export type ReportCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportCards.
     */
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyInput>
    /**
     * Filter which ReportCards to update
     */
    where?: ReportCardWhereInput
  }


  /**
   * ReportCard upsert
   */
  export type ReportCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportCard to update in case it exists.
     */
    where: ReportCardWhereUniqueInput
    /**
     * In case the ReportCard found by the `where` argument doesn't exist, create a new ReportCard with this data.
     */
    create: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
    /**
     * In case the ReportCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
  }


  /**
   * ReportCard delete
   */
  export type ReportCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter which ReportCard to delete.
     */
    where: ReportCardWhereUniqueInput
  }


  /**
   * ReportCard deleteMany
   */
  export type ReportCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCards to delete
     */
    where?: ReportCardWhereInput
  }


  /**
   * ReportCard without action
   */
  export type ReportCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportCardInclude<ExtArgs> | null
  }



  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    mobile: string | null
    code: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    mobile: string | null
    code: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    mobile: number
    code: number
    expiresAt: number
    verified: number
    createdAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    mobile?: true
    code?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    mobile?: true
    code?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    mobile?: true
    code?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    mobile: string
    code: string
    expiresAt: Date
    verified: boolean
    createdAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobile?: boolean
    code?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    mobile?: boolean
    code?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }


  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mobile: string
      code: string
      expiresAt: Date
      verified: boolean
      createdAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }


  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OtpFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Otp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OtpFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OtpFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
    **/
    create<T extends OtpCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OtpCreateArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
    **/
    delete<T extends OtpDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OtpUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OtpDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OtpUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
    **/
    upsert<T extends OtpUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>
    ): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Otp model
   */ 
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly mobile: FieldRef<"Otp", 'String'>
    readonly code: FieldRef<"Otp", 'String'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
    readonly verified: FieldRef<"Otp", 'Boolean'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }


  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }


  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }


  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }


  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
  }


  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }


  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
  }


  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
  }



  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    planId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    schoolId: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    schoolId: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    planId: number
    status: number
    startDate: number
    endDate: number
    schoolId: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    planId?: true
    status?: true
    startDate?: true
    endDate?: true
    schoolId?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    planId?: true
    status?: true
    startDate?: true
    endDate?: true
    schoolId?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    planId?: true
    status?: true
    startDate?: true
    endDate?: true
    schoolId?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    planId: string
    status: string
    startDate: Date
    endDate: Date | null
    schoolId: string
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    schoolId?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }


  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      status: string
      startDate: Date
      endDate: Date | null
      schoolId: string
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }


  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly schoolId: FieldRef<"Subscription", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }



  /**
   * Model MasterData
   */

  export type AggregateMasterData = {
    _count: MasterDataCountAggregateOutputType | null
    _min: MasterDataMinAggregateOutputType | null
    _max: MasterDataMaxAggregateOutputType | null
  }

  export type MasterDataMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    code: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MasterDataMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    code: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MasterDataCountAggregateOutputType = {
    id: number
    type: number
    name: number
    code: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MasterDataMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    code?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MasterDataMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    code?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MasterDataCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    code?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MasterDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterData to aggregate.
     */
    where?: MasterDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterData to fetch.
     */
    orderBy?: MasterDataOrderByWithRelationInput | MasterDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterData
    **/
    _count?: true | MasterDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterDataMaxAggregateInputType
  }

  export type GetMasterDataAggregateType<T extends MasterDataAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterData[P]>
      : GetScalarType<T[P], AggregateMasterData[P]>
  }




  export type MasterDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterDataWhereInput
    orderBy?: MasterDataOrderByWithAggregationInput | MasterDataOrderByWithAggregationInput[]
    by: MasterDataScalarFieldEnum[] | MasterDataScalarFieldEnum
    having?: MasterDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterDataCountAggregateInputType | true
    _min?: MasterDataMinAggregateInputType
    _max?: MasterDataMaxAggregateInputType
  }

  export type MasterDataGroupByOutputType = {
    id: string
    type: string
    name: string
    code: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MasterDataCountAggregateOutputType | null
    _min: MasterDataMinAggregateOutputType | null
    _max: MasterDataMaxAggregateOutputType | null
  }

  type GetMasterDataGroupByPayload<T extends MasterDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterDataGroupByOutputType[P]>
            : GetScalarType<T[P], MasterDataGroupByOutputType[P]>
        }
      >
    >


  export type MasterDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    code?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | MasterData$parentArgs<ExtArgs>
    children?: boolean | MasterData$childrenArgs<ExtArgs>
    _count?: boolean | MasterDataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterData"]>

  export type MasterDataSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    code?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MasterDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | MasterData$parentArgs<ExtArgs>
    children?: boolean | MasterData$childrenArgs<ExtArgs>
    _count?: boolean | MasterDataCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MasterDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterData"
    objects: {
      parent: Prisma.$MasterDataPayload<ExtArgs> | null
      children: Prisma.$MasterDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      name: string
      code: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["masterData"]>
    composites: {}
  }


  type MasterDataGetPayload<S extends boolean | null | undefined | MasterDataDefaultArgs> = $Result.GetResult<Prisma.$MasterDataPayload, S>

  type MasterDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MasterDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MasterDataCountAggregateInputType | true
    }

  export interface MasterDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterData'], meta: { name: 'MasterData' } }
    /**
     * Find zero or one MasterData that matches the filter.
     * @param {MasterDataFindUniqueArgs} args - Arguments to find a MasterData
     * @example
     * // Get one MasterData
     * const masterData = await prisma.masterData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MasterDataFindUniqueArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MasterData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterDataFindUniqueOrThrowArgs} args - Arguments to find a MasterData
     * @example
     * // Get one MasterData
     * const masterData = await prisma.masterData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MasterData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDataFindFirstArgs} args - Arguments to find a MasterData
     * @example
     * // Get one MasterData
     * const masterData = await prisma.masterData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterDataFindFirstArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MasterData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDataFindFirstOrThrowArgs} args - Arguments to find a MasterData
     * @example
     * // Get one MasterData
     * const masterData = await prisma.masterData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MasterData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterData
     * const masterData = await prisma.masterData.findMany()
     * 
     * // Get first 10 MasterData
     * const masterData = await prisma.masterData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterDataWithIdOnly = await prisma.masterData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MasterDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MasterData.
     * @param {MasterDataCreateArgs} args - Arguments to create a MasterData.
     * @example
     * // Create one MasterData
     * const MasterData = await prisma.masterData.create({
     *   data: {
     *     // ... data to create a MasterData
     *   }
     * })
     * 
    **/
    create<T extends MasterDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MasterDataCreateArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a MasterData.
     * @param {MasterDataDeleteArgs} args - Arguments to delete one MasterData.
     * @example
     * // Delete one MasterData
     * const MasterData = await prisma.masterData.delete({
     *   where: {
     *     // ... filter to delete one MasterData
     *   }
     * })
     * 
    **/
    delete<T extends MasterDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MasterDataDeleteArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MasterData.
     * @param {MasterDataUpdateArgs} args - Arguments to update one MasterData.
     * @example
     * // Update one MasterData
     * const masterData = await prisma.masterData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MasterDataUpdateArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MasterData.
     * @param {MasterDataDeleteManyArgs} args - Arguments to filter MasterData to delete.
     * @example
     * // Delete a few MasterData
     * const { count } = await prisma.masterData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterData
     * const masterData = await prisma.masterData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MasterDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterData.
     * @param {MasterDataUpsertArgs} args - Arguments to update or create a MasterData.
     * @example
     * // Update or create a MasterData
     * const masterData = await prisma.masterData.upsert({
     *   create: {
     *     // ... data to create a MasterData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterData we want to update
     *   }
     * })
    **/
    upsert<T extends MasterDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MasterDataUpsertArgs<ExtArgs>>
    ): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MasterData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDataCountArgs} args - Arguments to filter MasterData to count.
     * @example
     * // Count the number of MasterData
     * const count = await prisma.masterData.count({
     *   where: {
     *     // ... the filter for the MasterData we want to count
     *   }
     * })
    **/
    count<T extends MasterDataCountArgs>(
      args?: Subset<T, MasterDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterDataAggregateArgs>(args: Subset<T, MasterDataAggregateArgs>): Prisma.PrismaPromise<GetMasterDataAggregateType<T>>

    /**
     * Group by MasterData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterDataGroupByArgs['orderBy'] }
        : { orderBy?: MasterDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterData model
   */
  readonly fields: MasterDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parent<T extends MasterData$parentArgs<ExtArgs> = {}>(args?: Subset<T, MasterData$parentArgs<ExtArgs>>): Prisma__MasterDataClient<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    children<T extends MasterData$childrenArgs<ExtArgs> = {}>(args?: Subset<T, MasterData$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterDataPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MasterData model
   */ 
  interface MasterDataFieldRefs {
    readonly id: FieldRef<"MasterData", 'String'>
    readonly type: FieldRef<"MasterData", 'String'>
    readonly name: FieldRef<"MasterData", 'String'>
    readonly code: FieldRef<"MasterData", 'String'>
    readonly parentId: FieldRef<"MasterData", 'String'>
    readonly createdAt: FieldRef<"MasterData", 'DateTime'>
    readonly updatedAt: FieldRef<"MasterData", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MasterData findUnique
   */
  export type MasterDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * Filter, which MasterData to fetch.
     */
    where: MasterDataWhereUniqueInput
  }


  /**
   * MasterData findUniqueOrThrow
   */
  export type MasterDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * Filter, which MasterData to fetch.
     */
    where: MasterDataWhereUniqueInput
  }


  /**
   * MasterData findFirst
   */
  export type MasterDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * Filter, which MasterData to fetch.
     */
    where?: MasterDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterData to fetch.
     */
    orderBy?: MasterDataOrderByWithRelationInput | MasterDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterData.
     */
    cursor?: MasterDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterData.
     */
    distinct?: MasterDataScalarFieldEnum | MasterDataScalarFieldEnum[]
  }


  /**
   * MasterData findFirstOrThrow
   */
  export type MasterDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * Filter, which MasterData to fetch.
     */
    where?: MasterDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterData to fetch.
     */
    orderBy?: MasterDataOrderByWithRelationInput | MasterDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterData.
     */
    cursor?: MasterDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterData.
     */
    distinct?: MasterDataScalarFieldEnum | MasterDataScalarFieldEnum[]
  }


  /**
   * MasterData findMany
   */
  export type MasterDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * Filter, which MasterData to fetch.
     */
    where?: MasterDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterData to fetch.
     */
    orderBy?: MasterDataOrderByWithRelationInput | MasterDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterData.
     */
    cursor?: MasterDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterData.
     */
    skip?: number
    distinct?: MasterDataScalarFieldEnum | MasterDataScalarFieldEnum[]
  }


  /**
   * MasterData create
   */
  export type MasterDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * The data needed to create a MasterData.
     */
    data: XOR<MasterDataCreateInput, MasterDataUncheckedCreateInput>
  }


  /**
   * MasterData update
   */
  export type MasterDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * The data needed to update a MasterData.
     */
    data: XOR<MasterDataUpdateInput, MasterDataUncheckedUpdateInput>
    /**
     * Choose, which MasterData to update.
     */
    where: MasterDataWhereUniqueInput
  }


  /**
   * MasterData updateMany
   */
  export type MasterDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterData.
     */
    data: XOR<MasterDataUpdateManyMutationInput, MasterDataUncheckedUpdateManyInput>
    /**
     * Filter which MasterData to update
     */
    where?: MasterDataWhereInput
  }


  /**
   * MasterData upsert
   */
  export type MasterDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * The filter to search for the MasterData to update in case it exists.
     */
    where: MasterDataWhereUniqueInput
    /**
     * In case the MasterData found by the `where` argument doesn't exist, create a new MasterData with this data.
     */
    create: XOR<MasterDataCreateInput, MasterDataUncheckedCreateInput>
    /**
     * In case the MasterData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterDataUpdateInput, MasterDataUncheckedUpdateInput>
  }


  /**
   * MasterData delete
   */
  export type MasterDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    /**
     * Filter which MasterData to delete.
     */
    where: MasterDataWhereUniqueInput
  }


  /**
   * MasterData deleteMany
   */
  export type MasterDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterData to delete
     */
    where?: MasterDataWhereInput
  }


  /**
   * MasterData.parent
   */
  export type MasterData$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    where?: MasterDataWhereInput
  }


  /**
   * MasterData.children
   */
  export type MasterData$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
    where?: MasterDataWhereInput
    orderBy?: MasterDataOrderByWithRelationInput | MasterDataOrderByWithRelationInput[]
    cursor?: MasterDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MasterDataScalarFieldEnum | MasterDataScalarFieldEnum[]
  }


  /**
   * MasterData without action
   */
  export type MasterDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterData
     */
    select?: MasterDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MasterDataInclude<ExtArgs> | null
  }



  /**
   * Model StaffAttendance
   */

  export type AggregateStaffAttendance = {
    _count: StaffAttendanceCountAggregateOutputType | null
    _avg: StaffAttendanceAvgAggregateOutputType | null
    _sum: StaffAttendanceSumAggregateOutputType | null
    _min: StaffAttendanceMinAggregateOutputType | null
    _max: StaffAttendanceMaxAggregateOutputType | null
  }

  export type StaffAttendanceAvgAggregateOutputType = {
    totalHours: number | null
  }

  export type StaffAttendanceSumAggregateOutputType = {
    totalHours: number | null
  }

  export type StaffAttendanceMinAggregateOutputType = {
    id: string | null
    date: Date | null
    status: string | null
    notes: string | null
    totalHours: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffAttendanceMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    status: string | null
    notes: string | null
    totalHours: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffAttendanceCountAggregateOutputType = {
    id: number
    date: number
    status: number
    notes: number
    totalHours: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffAttendanceAvgAggregateInputType = {
    totalHours?: true
  }

  export type StaffAttendanceSumAggregateInputType = {
    totalHours?: true
  }

  export type StaffAttendanceMinAggregateInputType = {
    id?: true
    date?: true
    status?: true
    notes?: true
    totalHours?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffAttendanceMaxAggregateInputType = {
    id?: true
    date?: true
    status?: true
    notes?: true
    totalHours?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffAttendanceCountAggregateInputType = {
    id?: true
    date?: true
    status?: true
    notes?: true
    totalHours?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffAttendance to aggregate.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffAttendances
    **/
    _count?: true | StaffAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffAttendanceMaxAggregateInputType
  }

  export type GetStaffAttendanceAggregateType<T extends StaffAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffAttendance[P]>
      : GetScalarType<T[P], AggregateStaffAttendance[P]>
  }




  export type StaffAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffAttendanceWhereInput
    orderBy?: StaffAttendanceOrderByWithAggregationInput | StaffAttendanceOrderByWithAggregationInput[]
    by: StaffAttendanceScalarFieldEnum[] | StaffAttendanceScalarFieldEnum
    having?: StaffAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffAttendanceCountAggregateInputType | true
    _avg?: StaffAttendanceAvgAggregateInputType
    _sum?: StaffAttendanceSumAggregateInputType
    _min?: StaffAttendanceMinAggregateInputType
    _max?: StaffAttendanceMaxAggregateInputType
  }

  export type StaffAttendanceGroupByOutputType = {
    id: string
    date: Date
    status: string
    notes: string | null
    totalHours: number | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: StaffAttendanceCountAggregateOutputType | null
    _avg: StaffAttendanceAvgAggregateOutputType | null
    _sum: StaffAttendanceSumAggregateOutputType | null
    _min: StaffAttendanceMinAggregateOutputType | null
    _max: StaffAttendanceMaxAggregateOutputType | null
  }

  type GetStaffAttendanceGroupByPayload<T extends StaffAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], StaffAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type StaffAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    totalHours?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    punches?: boolean | StaffAttendance$punchesArgs<ExtArgs>
    _count?: boolean | StaffAttendanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffAttendance"]>

  export type StaffAttendanceSelectScalar = {
    id?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    totalHours?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    punches?: boolean | StaffAttendance$punchesArgs<ExtArgs>
    _count?: boolean | StaffAttendanceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StaffAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffAttendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      punches: Prisma.$StaffPunchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      status: string
      notes: string | null
      totalHours: number | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staffAttendance"]>
    composites: {}
  }


  type StaffAttendanceGetPayload<S extends boolean | null | undefined | StaffAttendanceDefaultArgs> = $Result.GetResult<Prisma.$StaffAttendancePayload, S>

  type StaffAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffAttendanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffAttendanceCountAggregateInputType | true
    }

  export interface StaffAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffAttendance'], meta: { name: 'StaffAttendance' } }
    /**
     * Find zero or one StaffAttendance that matches the filter.
     * @param {StaffAttendanceFindUniqueArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffAttendanceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StaffAttendanceFindUniqueArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaffAttendance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffAttendanceFindUniqueOrThrowArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffAttendanceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffAttendanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaffAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceFindFirstArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffAttendanceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffAttendanceFindFirstArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaffAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceFindFirstOrThrowArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffAttendanceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffAttendanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaffAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffAttendances
     * const staffAttendances = await prisma.staffAttendance.findMany()
     * 
     * // Get first 10 StaffAttendances
     * const staffAttendances = await prisma.staffAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffAttendanceWithIdOnly = await prisma.staffAttendance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffAttendanceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffAttendanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaffAttendance.
     * @param {StaffAttendanceCreateArgs} args - Arguments to create a StaffAttendance.
     * @example
     * // Create one StaffAttendance
     * const StaffAttendance = await prisma.staffAttendance.create({
     *   data: {
     *     // ... data to create a StaffAttendance
     *   }
     * })
     * 
    **/
    create<T extends StaffAttendanceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffAttendanceCreateArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a StaffAttendance.
     * @param {StaffAttendanceDeleteArgs} args - Arguments to delete one StaffAttendance.
     * @example
     * // Delete one StaffAttendance
     * const StaffAttendance = await prisma.staffAttendance.delete({
     *   where: {
     *     // ... filter to delete one StaffAttendance
     *   }
     * })
     * 
    **/
    delete<T extends StaffAttendanceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffAttendanceDeleteArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaffAttendance.
     * @param {StaffAttendanceUpdateArgs} args - Arguments to update one StaffAttendance.
     * @example
     * // Update one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffAttendanceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffAttendanceUpdateArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaffAttendances.
     * @param {StaffAttendanceDeleteManyArgs} args - Arguments to filter StaffAttendances to delete.
     * @example
     * // Delete a few StaffAttendances
     * const { count } = await prisma.staffAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffAttendanceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffAttendanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffAttendances
     * const staffAttendance = await prisma.staffAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffAttendanceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffAttendanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaffAttendance.
     * @param {StaffAttendanceUpsertArgs} args - Arguments to update or create a StaffAttendance.
     * @example
     * // Update or create a StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.upsert({
     *   create: {
     *     // ... data to create a StaffAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffAttendance we want to update
     *   }
     * })
    **/
    upsert<T extends StaffAttendanceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffAttendanceUpsertArgs<ExtArgs>>
    ): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaffAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceCountArgs} args - Arguments to filter StaffAttendances to count.
     * @example
     * // Count the number of StaffAttendances
     * const count = await prisma.staffAttendance.count({
     *   where: {
     *     // ... the filter for the StaffAttendances we want to count
     *   }
     * })
    **/
    count<T extends StaffAttendanceCountArgs>(
      args?: Subset<T, StaffAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAttendanceAggregateArgs>(args: Subset<T, StaffAttendanceAggregateArgs>): Prisma.PrismaPromise<GetStaffAttendanceAggregateType<T>>

    /**
     * Group by StaffAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: StaffAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffAttendance model
   */
  readonly fields: StaffAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    punches<T extends StaffAttendance$punchesArgs<ExtArgs> = {}>(args?: Subset<T, StaffAttendance$punchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StaffAttendance model
   */ 
  interface StaffAttendanceFieldRefs {
    readonly id: FieldRef<"StaffAttendance", 'String'>
    readonly date: FieldRef<"StaffAttendance", 'DateTime'>
    readonly status: FieldRef<"StaffAttendance", 'String'>
    readonly notes: FieldRef<"StaffAttendance", 'String'>
    readonly totalHours: FieldRef<"StaffAttendance", 'Float'>
    readonly userId: FieldRef<"StaffAttendance", 'String'>
    readonly createdAt: FieldRef<"StaffAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffAttendance", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StaffAttendance findUnique
   */
  export type StaffAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where: StaffAttendanceWhereUniqueInput
  }


  /**
   * StaffAttendance findUniqueOrThrow
   */
  export type StaffAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where: StaffAttendanceWhereUniqueInput
  }


  /**
   * StaffAttendance findFirst
   */
  export type StaffAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffAttendances.
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffAttendances.
     */
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }


  /**
   * StaffAttendance findFirstOrThrow
   */
  export type StaffAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffAttendances.
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffAttendances.
     */
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }


  /**
   * StaffAttendance findMany
   */
  export type StaffAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendances to fetch.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffAttendances.
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }


  /**
   * StaffAttendance create
   */
  export type StaffAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffAttendance.
     */
    data: XOR<StaffAttendanceCreateInput, StaffAttendanceUncheckedCreateInput>
  }


  /**
   * StaffAttendance update
   */
  export type StaffAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffAttendance.
     */
    data: XOR<StaffAttendanceUpdateInput, StaffAttendanceUncheckedUpdateInput>
    /**
     * Choose, which StaffAttendance to update.
     */
    where: StaffAttendanceWhereUniqueInput
  }


  /**
   * StaffAttendance updateMany
   */
  export type StaffAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffAttendances.
     */
    data: XOR<StaffAttendanceUpdateManyMutationInput, StaffAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StaffAttendances to update
     */
    where?: StaffAttendanceWhereInput
  }


  /**
   * StaffAttendance upsert
   */
  export type StaffAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffAttendance to update in case it exists.
     */
    where: StaffAttendanceWhereUniqueInput
    /**
     * In case the StaffAttendance found by the `where` argument doesn't exist, create a new StaffAttendance with this data.
     */
    create: XOR<StaffAttendanceCreateInput, StaffAttendanceUncheckedCreateInput>
    /**
     * In case the StaffAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffAttendanceUpdateInput, StaffAttendanceUncheckedUpdateInput>
  }


  /**
   * StaffAttendance delete
   */
  export type StaffAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter which StaffAttendance to delete.
     */
    where: StaffAttendanceWhereUniqueInput
  }


  /**
   * StaffAttendance deleteMany
   */
  export type StaffAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffAttendances to delete
     */
    where?: StaffAttendanceWhereInput
  }


  /**
   * StaffAttendance.punches
   */
  export type StaffAttendance$punchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    where?: StaffPunchWhereInput
    orderBy?: StaffPunchOrderByWithRelationInput | StaffPunchOrderByWithRelationInput[]
    cursor?: StaffPunchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffPunchScalarFieldEnum | StaffPunchScalarFieldEnum[]
  }


  /**
   * StaffAttendance without action
   */
  export type StaffAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
  }



  /**
   * Model StaffPunch
   */

  export type AggregateStaffPunch = {
    _count: StaffPunchCountAggregateOutputType | null
    _min: StaffPunchMinAggregateOutputType | null
    _max: StaffPunchMaxAggregateOutputType | null
  }

  export type StaffPunchMinAggregateOutputType = {
    id: string | null
    type: string | null
    timestamp: Date | null
    attendanceId: string | null
  }

  export type StaffPunchMaxAggregateOutputType = {
    id: string | null
    type: string | null
    timestamp: Date | null
    attendanceId: string | null
  }

  export type StaffPunchCountAggregateOutputType = {
    id: number
    type: number
    timestamp: number
    attendanceId: number
    _all: number
  }


  export type StaffPunchMinAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    attendanceId?: true
  }

  export type StaffPunchMaxAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    attendanceId?: true
  }

  export type StaffPunchCountAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    attendanceId?: true
    _all?: true
  }

  export type StaffPunchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffPunch to aggregate.
     */
    where?: StaffPunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPunches to fetch.
     */
    orderBy?: StaffPunchOrderByWithRelationInput | StaffPunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffPunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPunches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffPunches
    **/
    _count?: true | StaffPunchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffPunchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffPunchMaxAggregateInputType
  }

  export type GetStaffPunchAggregateType<T extends StaffPunchAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffPunch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffPunch[P]>
      : GetScalarType<T[P], AggregateStaffPunch[P]>
  }




  export type StaffPunchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffPunchWhereInput
    orderBy?: StaffPunchOrderByWithAggregationInput | StaffPunchOrderByWithAggregationInput[]
    by: StaffPunchScalarFieldEnum[] | StaffPunchScalarFieldEnum
    having?: StaffPunchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffPunchCountAggregateInputType | true
    _min?: StaffPunchMinAggregateInputType
    _max?: StaffPunchMaxAggregateInputType
  }

  export type StaffPunchGroupByOutputType = {
    id: string
    type: string
    timestamp: Date
    attendanceId: string
    _count: StaffPunchCountAggregateOutputType | null
    _min: StaffPunchMinAggregateOutputType | null
    _max: StaffPunchMaxAggregateOutputType | null
  }

  type GetStaffPunchGroupByPayload<T extends StaffPunchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffPunchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffPunchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffPunchGroupByOutputType[P]>
            : GetScalarType<T[P], StaffPunchGroupByOutputType[P]>
        }
      >
    >


  export type StaffPunchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    timestamp?: boolean
    attendanceId?: boolean
    attendance?: boolean | StaffAttendanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffPunch"]>

  export type StaffPunchSelectScalar = {
    id?: boolean
    type?: boolean
    timestamp?: boolean
    attendanceId?: boolean
  }

  export type StaffPunchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | StaffAttendanceDefaultArgs<ExtArgs>
  }


  export type $StaffPunchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffPunch"
    objects: {
      attendance: Prisma.$StaffAttendancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      timestamp: Date
      attendanceId: string
    }, ExtArgs["result"]["staffPunch"]>
    composites: {}
  }


  type StaffPunchGetPayload<S extends boolean | null | undefined | StaffPunchDefaultArgs> = $Result.GetResult<Prisma.$StaffPunchPayload, S>

  type StaffPunchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffPunchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffPunchCountAggregateInputType | true
    }

  export interface StaffPunchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffPunch'], meta: { name: 'StaffPunch' } }
    /**
     * Find zero or one StaffPunch that matches the filter.
     * @param {StaffPunchFindUniqueArgs} args - Arguments to find a StaffPunch
     * @example
     * // Get one StaffPunch
     * const staffPunch = await prisma.staffPunch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffPunchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StaffPunchFindUniqueArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaffPunch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffPunchFindUniqueOrThrowArgs} args - Arguments to find a StaffPunch
     * @example
     * // Get one StaffPunch
     * const staffPunch = await prisma.staffPunch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffPunchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffPunchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaffPunch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPunchFindFirstArgs} args - Arguments to find a StaffPunch
     * @example
     * // Get one StaffPunch
     * const staffPunch = await prisma.staffPunch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffPunchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffPunchFindFirstArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaffPunch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPunchFindFirstOrThrowArgs} args - Arguments to find a StaffPunch
     * @example
     * // Get one StaffPunch
     * const staffPunch = await prisma.staffPunch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffPunchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffPunchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaffPunches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPunchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffPunches
     * const staffPunches = await prisma.staffPunch.findMany()
     * 
     * // Get first 10 StaffPunches
     * const staffPunches = await prisma.staffPunch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffPunchWithIdOnly = await prisma.staffPunch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffPunchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffPunchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaffPunch.
     * @param {StaffPunchCreateArgs} args - Arguments to create a StaffPunch.
     * @example
     * // Create one StaffPunch
     * const StaffPunch = await prisma.staffPunch.create({
     *   data: {
     *     // ... data to create a StaffPunch
     *   }
     * })
     * 
    **/
    create<T extends StaffPunchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffPunchCreateArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a StaffPunch.
     * @param {StaffPunchDeleteArgs} args - Arguments to delete one StaffPunch.
     * @example
     * // Delete one StaffPunch
     * const StaffPunch = await prisma.staffPunch.delete({
     *   where: {
     *     // ... filter to delete one StaffPunch
     *   }
     * })
     * 
    **/
    delete<T extends StaffPunchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffPunchDeleteArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaffPunch.
     * @param {StaffPunchUpdateArgs} args - Arguments to update one StaffPunch.
     * @example
     * // Update one StaffPunch
     * const staffPunch = await prisma.staffPunch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffPunchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffPunchUpdateArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaffPunches.
     * @param {StaffPunchDeleteManyArgs} args - Arguments to filter StaffPunches to delete.
     * @example
     * // Delete a few StaffPunches
     * const { count } = await prisma.staffPunch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffPunchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffPunchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffPunches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPunchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffPunches
     * const staffPunch = await prisma.staffPunch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffPunchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffPunchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaffPunch.
     * @param {StaffPunchUpsertArgs} args - Arguments to update or create a StaffPunch.
     * @example
     * // Update or create a StaffPunch
     * const staffPunch = await prisma.staffPunch.upsert({
     *   create: {
     *     // ... data to create a StaffPunch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffPunch we want to update
     *   }
     * })
    **/
    upsert<T extends StaffPunchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffPunchUpsertArgs<ExtArgs>>
    ): Prisma__StaffPunchClient<$Result.GetResult<Prisma.$StaffPunchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaffPunches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPunchCountArgs} args - Arguments to filter StaffPunches to count.
     * @example
     * // Count the number of StaffPunches
     * const count = await prisma.staffPunch.count({
     *   where: {
     *     // ... the filter for the StaffPunches we want to count
     *   }
     * })
    **/
    count<T extends StaffPunchCountArgs>(
      args?: Subset<T, StaffPunchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffPunchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffPunch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPunchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffPunchAggregateArgs>(args: Subset<T, StaffPunchAggregateArgs>): Prisma.PrismaPromise<GetStaffPunchAggregateType<T>>

    /**
     * Group by StaffPunch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPunchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffPunchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffPunchGroupByArgs['orderBy'] }
        : { orderBy?: StaffPunchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffPunchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffPunchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffPunch model
   */
  readonly fields: StaffPunchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffPunch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffPunchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    attendance<T extends StaffAttendanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffAttendanceDefaultArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StaffPunch model
   */ 
  interface StaffPunchFieldRefs {
    readonly id: FieldRef<"StaffPunch", 'String'>
    readonly type: FieldRef<"StaffPunch", 'String'>
    readonly timestamp: FieldRef<"StaffPunch", 'DateTime'>
    readonly attendanceId: FieldRef<"StaffPunch", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StaffPunch findUnique
   */
  export type StaffPunchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * Filter, which StaffPunch to fetch.
     */
    where: StaffPunchWhereUniqueInput
  }


  /**
   * StaffPunch findUniqueOrThrow
   */
  export type StaffPunchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * Filter, which StaffPunch to fetch.
     */
    where: StaffPunchWhereUniqueInput
  }


  /**
   * StaffPunch findFirst
   */
  export type StaffPunchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * Filter, which StaffPunch to fetch.
     */
    where?: StaffPunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPunches to fetch.
     */
    orderBy?: StaffPunchOrderByWithRelationInput | StaffPunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffPunches.
     */
    cursor?: StaffPunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPunches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffPunches.
     */
    distinct?: StaffPunchScalarFieldEnum | StaffPunchScalarFieldEnum[]
  }


  /**
   * StaffPunch findFirstOrThrow
   */
  export type StaffPunchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * Filter, which StaffPunch to fetch.
     */
    where?: StaffPunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPunches to fetch.
     */
    orderBy?: StaffPunchOrderByWithRelationInput | StaffPunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffPunches.
     */
    cursor?: StaffPunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPunches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffPunches.
     */
    distinct?: StaffPunchScalarFieldEnum | StaffPunchScalarFieldEnum[]
  }


  /**
   * StaffPunch findMany
   */
  export type StaffPunchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * Filter, which StaffPunches to fetch.
     */
    where?: StaffPunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPunches to fetch.
     */
    orderBy?: StaffPunchOrderByWithRelationInput | StaffPunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffPunches.
     */
    cursor?: StaffPunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPunches.
     */
    skip?: number
    distinct?: StaffPunchScalarFieldEnum | StaffPunchScalarFieldEnum[]
  }


  /**
   * StaffPunch create
   */
  export type StaffPunchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffPunch.
     */
    data: XOR<StaffPunchCreateInput, StaffPunchUncheckedCreateInput>
  }


  /**
   * StaffPunch update
   */
  export type StaffPunchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffPunch.
     */
    data: XOR<StaffPunchUpdateInput, StaffPunchUncheckedUpdateInput>
    /**
     * Choose, which StaffPunch to update.
     */
    where: StaffPunchWhereUniqueInput
  }


  /**
   * StaffPunch updateMany
   */
  export type StaffPunchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffPunches.
     */
    data: XOR<StaffPunchUpdateManyMutationInput, StaffPunchUncheckedUpdateManyInput>
    /**
     * Filter which StaffPunches to update
     */
    where?: StaffPunchWhereInput
  }


  /**
   * StaffPunch upsert
   */
  export type StaffPunchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffPunch to update in case it exists.
     */
    where: StaffPunchWhereUniqueInput
    /**
     * In case the StaffPunch found by the `where` argument doesn't exist, create a new StaffPunch with this data.
     */
    create: XOR<StaffPunchCreateInput, StaffPunchUncheckedCreateInput>
    /**
     * In case the StaffPunch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffPunchUpdateInput, StaffPunchUncheckedUpdateInput>
  }


  /**
   * StaffPunch delete
   */
  export type StaffPunchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
    /**
     * Filter which StaffPunch to delete.
     */
    where: StaffPunchWhereUniqueInput
  }


  /**
   * StaffPunch deleteMany
   */
  export type StaffPunchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffPunches to delete
     */
    where?: StaffPunchWhereInput
  }


  /**
   * StaffPunch without action
   */
  export type StaffPunchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPunch
     */
    select?: StaffPunchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffPunchInclude<ExtArgs> | null
  }



  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    type: string | null
    reason: string | null
    status: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    type: string | null
    reason: string | null
    status: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    type: number
    reason: number
    status: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveRequestMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    type?: true
    reason?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    type?: true
    reason?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    type?: true
    reason?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    type: string
    reason: string | null
    status: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    reason?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    reason?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      type: string
      reason: string | null
      status: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }


  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaveRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LeaveRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaveRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaveRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
    **/
    create<T extends LeaveRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
    **/
    delete<T extends LeaveRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaveRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaveRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaveRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
    **/
    upsert<T extends LeaveRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>
    ): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LeaveRequest model
   */ 
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly type: FieldRef<"LeaveRequest", 'String'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly status: FieldRef<"LeaveRequest", 'String'>
    readonly userId: FieldRef<"LeaveRequest", 'String'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }


  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }


  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }


  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }


  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }


  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }


  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }


  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
  }


  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }


  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }


  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
  }


  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }



  /**
   * Model FeeStructure
   */

  export type AggregateFeeStructure = {
    _count: FeeStructureCountAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  export type FeeStructureMinAggregateOutputType = {
    id: string | null
    name: string | null
    academicYear: string | null
    description: string | null
    termConfig: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeStructureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    academicYear: string | null
    description: string | null
    termConfig: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeStructureCountAggregateOutputType = {
    id: number
    name: number
    academicYear: number
    description: number
    termConfig: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeStructureMinAggregateInputType = {
    id?: true
    name?: true
    academicYear?: true
    description?: true
    termConfig?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeStructureMaxAggregateInputType = {
    id?: true
    name?: true
    academicYear?: true
    description?: true
    termConfig?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeStructureCountAggregateInputType = {
    id?: true
    name?: true
    academicYear?: true
    description?: true
    termConfig?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructure to aggregate.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeStructures
    **/
    _count?: true | FeeStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeStructureMaxAggregateInputType
  }

  export type GetFeeStructureAggregateType<T extends FeeStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeStructure[P]>
      : GetScalarType<T[P], AggregateFeeStructure[P]>
  }




  export type FeeStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithAggregationInput | FeeStructureOrderByWithAggregationInput[]
    by: FeeStructureScalarFieldEnum[] | FeeStructureScalarFieldEnum
    having?: FeeStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeStructureCountAggregateInputType | true
    _min?: FeeStructureMinAggregateInputType
    _max?: FeeStructureMaxAggregateInputType
  }

  export type FeeStructureGroupByOutputType = {
    id: string
    name: string
    academicYear: string
    description: string | null
    termConfig: string | null
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: FeeStructureCountAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  type GetFeeStructureGroupByPayload<T extends FeeStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
            : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
        }
      >
    >


  export type FeeStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    academicYear?: boolean
    description?: boolean
    termConfig?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    components?: boolean | FeeStructure$componentsArgs<ExtArgs>
    _count?: boolean | FeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeStructure"]>

  export type FeeStructureSelectScalar = {
    id?: boolean
    name?: boolean
    academicYear?: boolean
    description?: boolean
    termConfig?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    components?: boolean | FeeStructure$componentsArgs<ExtArgs>
    _count?: boolean | FeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FeeStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeStructure"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      components: Prisma.$FeeComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      academicYear: string
      description: string | null
      termConfig: string | null
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feeStructure"]>
    composites: {}
  }


  type FeeStructureGetPayload<S extends boolean | null | undefined | FeeStructureDefaultArgs> = $Result.GetResult<Prisma.$FeeStructurePayload, S>

  type FeeStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeeStructureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeeStructureCountAggregateInputType | true
    }

  export interface FeeStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeStructure'], meta: { name: 'FeeStructure' } }
    /**
     * Find zero or one FeeStructure that matches the filter.
     * @param {FeeStructureFindUniqueArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeeStructureFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeeStructureFindUniqueArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeeStructure that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeeStructureFindUniqueOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeeStructureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeStructureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeeStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeeStructureFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeStructureFindFirstArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeeStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeeStructureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeStructureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeeStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany()
     * 
     * // Get first 10 FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeeStructureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeStructureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeeStructure.
     * @param {FeeStructureCreateArgs} args - Arguments to create a FeeStructure.
     * @example
     * // Create one FeeStructure
     * const FeeStructure = await prisma.feeStructure.create({
     *   data: {
     *     // ... data to create a FeeStructure
     *   }
     * })
     * 
    **/
    create<T extends FeeStructureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeStructureCreateArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a FeeStructure.
     * @param {FeeStructureDeleteArgs} args - Arguments to delete one FeeStructure.
     * @example
     * // Delete one FeeStructure
     * const FeeStructure = await prisma.feeStructure.delete({
     *   where: {
     *     // ... filter to delete one FeeStructure
     *   }
     * })
     * 
    **/
    delete<T extends FeeStructureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeeStructureDeleteArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeeStructure.
     * @param {FeeStructureUpdateArgs} args - Arguments to update one FeeStructure.
     * @example
     * // Update one FeeStructure
     * const feeStructure = await prisma.feeStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeeStructureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeStructureUpdateArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeeStructures.
     * @param {FeeStructureDeleteManyArgs} args - Arguments to filter FeeStructures to delete.
     * @example
     * // Delete a few FeeStructures
     * const { count } = await prisma.feeStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeeStructureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeStructureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeStructures
     * const feeStructure = await prisma.feeStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeeStructureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeeStructureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeeStructure.
     * @param {FeeStructureUpsertArgs} args - Arguments to update or create a FeeStructure.
     * @example
     * // Update or create a FeeStructure
     * const feeStructure = await prisma.feeStructure.upsert({
     *   create: {
     *     // ... data to create a FeeStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeStructure we want to update
     *   }
     * })
    **/
    upsert<T extends FeeStructureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeeStructureUpsertArgs<ExtArgs>>
    ): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureCountArgs} args - Arguments to filter FeeStructures to count.
     * @example
     * // Count the number of FeeStructures
     * const count = await prisma.feeStructure.count({
     *   where: {
     *     // ... the filter for the FeeStructures we want to count
     *   }
     * })
    **/
    count<T extends FeeStructureCountArgs>(
      args?: Subset<T, FeeStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeStructureAggregateArgs>(args: Subset<T, FeeStructureAggregateArgs>): Prisma.PrismaPromise<GetFeeStructureAggregateType<T>>

    /**
     * Group by FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeStructureGroupByArgs['orderBy'] }
        : { orderBy?: FeeStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeStructure model
   */
  readonly fields: FeeStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    components<T extends FeeStructure$componentsArgs<ExtArgs> = {}>(args?: Subset<T, FeeStructure$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeeStructure model
   */ 
  interface FeeStructureFieldRefs {
    readonly id: FieldRef<"FeeStructure", 'String'>
    readonly name: FieldRef<"FeeStructure", 'String'>
    readonly academicYear: FieldRef<"FeeStructure", 'String'>
    readonly description: FieldRef<"FeeStructure", 'String'>
    readonly termConfig: FieldRef<"FeeStructure", 'String'>
    readonly schoolId: FieldRef<"FeeStructure", 'String'>
    readonly createdAt: FieldRef<"FeeStructure", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeStructure", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * FeeStructure findUnique
   */
  export type FeeStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }


  /**
   * FeeStructure findUniqueOrThrow
   */
  export type FeeStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }


  /**
   * FeeStructure findFirst
   */
  export type FeeStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }


  /**
   * FeeStructure findFirstOrThrow
   */
  export type FeeStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }


  /**
   * FeeStructure findMany
   */
  export type FeeStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructures to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }


  /**
   * FeeStructure create
   */
  export type FeeStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeStructure.
     */
    data: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
  }


  /**
   * FeeStructure update
   */
  export type FeeStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeStructure.
     */
    data: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
    /**
     * Choose, which FeeStructure to update.
     */
    where: FeeStructureWhereUniqueInput
  }


  /**
   * FeeStructure updateMany
   */
  export type FeeStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeStructures.
     */
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which FeeStructures to update
     */
    where?: FeeStructureWhereInput
  }


  /**
   * FeeStructure upsert
   */
  export type FeeStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeStructure to update in case it exists.
     */
    where: FeeStructureWhereUniqueInput
    /**
     * In case the FeeStructure found by the `where` argument doesn't exist, create a new FeeStructure with this data.
     */
    create: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
    /**
     * In case the FeeStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
  }


  /**
   * FeeStructure delete
   */
  export type FeeStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter which FeeStructure to delete.
     */
    where: FeeStructureWhereUniqueInput
  }


  /**
   * FeeStructure deleteMany
   */
  export type FeeStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructures to delete
     */
    where?: FeeStructureWhereInput
  }


  /**
   * FeeStructure.components
   */
  export type FeeStructure$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    where?: FeeComponentWhereInput
    orderBy?: FeeComponentOrderByWithRelationInput | FeeComponentOrderByWithRelationInput[]
    cursor?: FeeComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeComponentScalarFieldEnum | FeeComponentScalarFieldEnum[]
  }


  /**
   * FeeStructure without action
   */
  export type FeeStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeStructureInclude<ExtArgs> | null
  }



  /**
   * Model FeeComponent
   */

  export type AggregateFeeComponent = {
    _count: FeeComponentCountAggregateOutputType | null
    _avg: FeeComponentAvgAggregateOutputType | null
    _sum: FeeComponentSumAggregateOutputType | null
    _min: FeeComponentMinAggregateOutputType | null
    _max: FeeComponentMaxAggregateOutputType | null
  }

  export type FeeComponentAvgAggregateOutputType = {
    amount: number | null
    dueDay: number | null
    dueMonth: number | null
  }

  export type FeeComponentSumAggregateOutputType = {
    amount: number | null
    dueDay: number | null
    dueMonth: number | null
  }

  export type FeeComponentMinAggregateOutputType = {
    id: string | null
    name: string | null
    amount: number | null
    currency: string | null
    frequency: string | null
    dueDate: Date | null
    dueDay: number | null
    dueMonth: number | null
    isOptional: boolean | null
    isRefundable: boolean | null
    midTermRule: string | null
    feeStructureId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeComponentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    amount: number | null
    currency: string | null
    frequency: string | null
    dueDate: Date | null
    dueDay: number | null
    dueMonth: number | null
    isOptional: boolean | null
    isRefundable: boolean | null
    midTermRule: string | null
    feeStructureId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeComponentCountAggregateOutputType = {
    id: number
    name: number
    amount: number
    currency: number
    frequency: number
    dueDate: number
    dueDay: number
    dueMonth: number
    isOptional: number
    isRefundable: number
    midTermRule: number
    feeStructureId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeComponentAvgAggregateInputType = {
    amount?: true
    dueDay?: true
    dueMonth?: true
  }

  export type FeeComponentSumAggregateInputType = {
    amount?: true
    dueDay?: true
    dueMonth?: true
  }

  export type FeeComponentMinAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    currency?: true
    frequency?: true
    dueDate?: true
    dueDay?: true
    dueMonth?: true
    isOptional?: true
    isRefundable?: true
    midTermRule?: true
    feeStructureId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeComponentMaxAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    currency?: true
    frequency?: true
    dueDate?: true
    dueDay?: true
    dueMonth?: true
    isOptional?: true
    isRefundable?: true
    midTermRule?: true
    feeStructureId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeComponentCountAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    currency?: true
    frequency?: true
    dueDate?: true
    dueDay?: true
    dueMonth?: true
    isOptional?: true
    isRefundable?: true
    midTermRule?: true
    feeStructureId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeComponent to aggregate.
     */
    where?: FeeComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeComponents to fetch.
     */
    orderBy?: FeeComponentOrderByWithRelationInput | FeeComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeComponents
    **/
    _count?: true | FeeComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeComponentMaxAggregateInputType
  }

  export type GetFeeComponentAggregateType<T extends FeeComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeComponent[P]>
      : GetScalarType<T[P], AggregateFeeComponent[P]>
  }




  export type FeeComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeComponentWhereInput
    orderBy?: FeeComponentOrderByWithAggregationInput | FeeComponentOrderByWithAggregationInput[]
    by: FeeComponentScalarFieldEnum[] | FeeComponentScalarFieldEnum
    having?: FeeComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeComponentCountAggregateInputType | true
    _avg?: FeeComponentAvgAggregateInputType
    _sum?: FeeComponentSumAggregateInputType
    _min?: FeeComponentMinAggregateInputType
    _max?: FeeComponentMaxAggregateInputType
  }

  export type FeeComponentGroupByOutputType = {
    id: string
    name: string
    amount: number
    currency: string
    frequency: string
    dueDate: Date | null
    dueDay: number | null
    dueMonth: number | null
    isOptional: boolean
    isRefundable: boolean
    midTermRule: string
    feeStructureId: string
    createdAt: Date
    updatedAt: Date
    _count: FeeComponentCountAggregateOutputType | null
    _avg: FeeComponentAvgAggregateOutputType | null
    _sum: FeeComponentSumAggregateOutputType | null
    _min: FeeComponentMinAggregateOutputType | null
    _max: FeeComponentMaxAggregateOutputType | null
  }

  type GetFeeComponentGroupByPayload<T extends FeeComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeComponentGroupByOutputType[P]>
            : GetScalarType<T[P], FeeComponentGroupByOutputType[P]>
        }
      >
    >


  export type FeeComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    currency?: boolean
    frequency?: boolean
    dueDate?: boolean
    dueDay?: boolean
    dueMonth?: boolean
    isOptional?: boolean
    isRefundable?: boolean
    midTermRule?: boolean
    feeStructureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feeStructure?: boolean | FeeStructureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeComponent"]>

  export type FeeComponentSelectScalar = {
    id?: boolean
    name?: boolean
    amount?: boolean
    currency?: boolean
    frequency?: boolean
    dueDate?: boolean
    dueDay?: boolean
    dueMonth?: boolean
    isOptional?: boolean
    isRefundable?: boolean
    midTermRule?: boolean
    feeStructureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeStructure?: boolean | FeeStructureDefaultArgs<ExtArgs>
  }


  export type $FeeComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeComponent"
    objects: {
      feeStructure: Prisma.$FeeStructurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      amount: number
      currency: string
      frequency: string
      dueDate: Date | null
      dueDay: number | null
      dueMonth: number | null
      isOptional: boolean
      isRefundable: boolean
      midTermRule: string
      feeStructureId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feeComponent"]>
    composites: {}
  }


  type FeeComponentGetPayload<S extends boolean | null | undefined | FeeComponentDefaultArgs> = $Result.GetResult<Prisma.$FeeComponentPayload, S>

  type FeeComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeeComponentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeeComponentCountAggregateInputType | true
    }

  export interface FeeComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeComponent'], meta: { name: 'FeeComponent' } }
    /**
     * Find zero or one FeeComponent that matches the filter.
     * @param {FeeComponentFindUniqueArgs} args - Arguments to find a FeeComponent
     * @example
     * // Get one FeeComponent
     * const feeComponent = await prisma.feeComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeeComponentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeeComponentFindUniqueArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeeComponent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeeComponentFindUniqueOrThrowArgs} args - Arguments to find a FeeComponent
     * @example
     * // Get one FeeComponent
     * const feeComponent = await prisma.feeComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeeComponentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeComponentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeeComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeComponentFindFirstArgs} args - Arguments to find a FeeComponent
     * @example
     * // Get one FeeComponent
     * const feeComponent = await prisma.feeComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeeComponentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeComponentFindFirstArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeeComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeComponentFindFirstOrThrowArgs} args - Arguments to find a FeeComponent
     * @example
     * // Get one FeeComponent
     * const feeComponent = await prisma.feeComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeeComponentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeComponentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeeComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeComponentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeComponents
     * const feeComponents = await prisma.feeComponent.findMany()
     * 
     * // Get first 10 FeeComponents
     * const feeComponents = await prisma.feeComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeComponentWithIdOnly = await prisma.feeComponent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeeComponentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeComponentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeeComponent.
     * @param {FeeComponentCreateArgs} args - Arguments to create a FeeComponent.
     * @example
     * // Create one FeeComponent
     * const FeeComponent = await prisma.feeComponent.create({
     *   data: {
     *     // ... data to create a FeeComponent
     *   }
     * })
     * 
    **/
    create<T extends FeeComponentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeComponentCreateArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a FeeComponent.
     * @param {FeeComponentDeleteArgs} args - Arguments to delete one FeeComponent.
     * @example
     * // Delete one FeeComponent
     * const FeeComponent = await prisma.feeComponent.delete({
     *   where: {
     *     // ... filter to delete one FeeComponent
     *   }
     * })
     * 
    **/
    delete<T extends FeeComponentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeeComponentDeleteArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeeComponent.
     * @param {FeeComponentUpdateArgs} args - Arguments to update one FeeComponent.
     * @example
     * // Update one FeeComponent
     * const feeComponent = await prisma.feeComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeeComponentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeComponentUpdateArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeeComponents.
     * @param {FeeComponentDeleteManyArgs} args - Arguments to filter FeeComponents to delete.
     * @example
     * // Delete a few FeeComponents
     * const { count } = await prisma.feeComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeeComponentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeComponentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeComponents
     * const feeComponent = await prisma.feeComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeeComponentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeeComponentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeeComponent.
     * @param {FeeComponentUpsertArgs} args - Arguments to update or create a FeeComponent.
     * @example
     * // Update or create a FeeComponent
     * const feeComponent = await prisma.feeComponent.upsert({
     *   create: {
     *     // ... data to create a FeeComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeComponent we want to update
     *   }
     * })
    **/
    upsert<T extends FeeComponentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeeComponentUpsertArgs<ExtArgs>>
    ): Prisma__FeeComponentClient<$Result.GetResult<Prisma.$FeeComponentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeeComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeComponentCountArgs} args - Arguments to filter FeeComponents to count.
     * @example
     * // Count the number of FeeComponents
     * const count = await prisma.feeComponent.count({
     *   where: {
     *     // ... the filter for the FeeComponents we want to count
     *   }
     * })
    **/
    count<T extends FeeComponentCountArgs>(
      args?: Subset<T, FeeComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeComponentAggregateArgs>(args: Subset<T, FeeComponentAggregateArgs>): Prisma.PrismaPromise<GetFeeComponentAggregateType<T>>

    /**
     * Group by FeeComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeComponentGroupByArgs['orderBy'] }
        : { orderBy?: FeeComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeComponent model
   */
  readonly fields: FeeComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    feeStructure<T extends FeeStructureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeStructureDefaultArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeeComponent model
   */ 
  interface FeeComponentFieldRefs {
    readonly id: FieldRef<"FeeComponent", 'String'>
    readonly name: FieldRef<"FeeComponent", 'String'>
    readonly amount: FieldRef<"FeeComponent", 'Float'>
    readonly currency: FieldRef<"FeeComponent", 'String'>
    readonly frequency: FieldRef<"FeeComponent", 'String'>
    readonly dueDate: FieldRef<"FeeComponent", 'DateTime'>
    readonly dueDay: FieldRef<"FeeComponent", 'Int'>
    readonly dueMonth: FieldRef<"FeeComponent", 'Int'>
    readonly isOptional: FieldRef<"FeeComponent", 'Boolean'>
    readonly isRefundable: FieldRef<"FeeComponent", 'Boolean'>
    readonly midTermRule: FieldRef<"FeeComponent", 'String'>
    readonly feeStructureId: FieldRef<"FeeComponent", 'String'>
    readonly createdAt: FieldRef<"FeeComponent", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeComponent", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * FeeComponent findUnique
   */
  export type FeeComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * Filter, which FeeComponent to fetch.
     */
    where: FeeComponentWhereUniqueInput
  }


  /**
   * FeeComponent findUniqueOrThrow
   */
  export type FeeComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * Filter, which FeeComponent to fetch.
     */
    where: FeeComponentWhereUniqueInput
  }


  /**
   * FeeComponent findFirst
   */
  export type FeeComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * Filter, which FeeComponent to fetch.
     */
    where?: FeeComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeComponents to fetch.
     */
    orderBy?: FeeComponentOrderByWithRelationInput | FeeComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeComponents.
     */
    cursor?: FeeComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeComponents.
     */
    distinct?: FeeComponentScalarFieldEnum | FeeComponentScalarFieldEnum[]
  }


  /**
   * FeeComponent findFirstOrThrow
   */
  export type FeeComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * Filter, which FeeComponent to fetch.
     */
    where?: FeeComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeComponents to fetch.
     */
    orderBy?: FeeComponentOrderByWithRelationInput | FeeComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeComponents.
     */
    cursor?: FeeComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeComponents.
     */
    distinct?: FeeComponentScalarFieldEnum | FeeComponentScalarFieldEnum[]
  }


  /**
   * FeeComponent findMany
   */
  export type FeeComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * Filter, which FeeComponents to fetch.
     */
    where?: FeeComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeComponents to fetch.
     */
    orderBy?: FeeComponentOrderByWithRelationInput | FeeComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeComponents.
     */
    cursor?: FeeComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeComponents.
     */
    skip?: number
    distinct?: FeeComponentScalarFieldEnum | FeeComponentScalarFieldEnum[]
  }


  /**
   * FeeComponent create
   */
  export type FeeComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeComponent.
     */
    data: XOR<FeeComponentCreateInput, FeeComponentUncheckedCreateInput>
  }


  /**
   * FeeComponent update
   */
  export type FeeComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeComponent.
     */
    data: XOR<FeeComponentUpdateInput, FeeComponentUncheckedUpdateInput>
    /**
     * Choose, which FeeComponent to update.
     */
    where: FeeComponentWhereUniqueInput
  }


  /**
   * FeeComponent updateMany
   */
  export type FeeComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeComponents.
     */
    data: XOR<FeeComponentUpdateManyMutationInput, FeeComponentUncheckedUpdateManyInput>
    /**
     * Filter which FeeComponents to update
     */
    where?: FeeComponentWhereInput
  }


  /**
   * FeeComponent upsert
   */
  export type FeeComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeComponent to update in case it exists.
     */
    where: FeeComponentWhereUniqueInput
    /**
     * In case the FeeComponent found by the `where` argument doesn't exist, create a new FeeComponent with this data.
     */
    create: XOR<FeeComponentCreateInput, FeeComponentUncheckedCreateInput>
    /**
     * In case the FeeComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeComponentUpdateInput, FeeComponentUncheckedUpdateInput>
  }


  /**
   * FeeComponent delete
   */
  export type FeeComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
    /**
     * Filter which FeeComponent to delete.
     */
    where: FeeComponentWhereUniqueInput
  }


  /**
   * FeeComponent deleteMany
   */
  export type FeeComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeComponents to delete
     */
    where?: FeeComponentWhereInput
  }


  /**
   * FeeComponent without action
   */
  export type FeeComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeComponent
     */
    select?: FeeComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeComponentInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    address: 'address',
    city: 'city',
    state: 'state',
    zip: 'zip',
    country: 'country',
    latitude: 'latitude',
    longitude: 'longitude',
    phone: 'phone',
    email: 'email',
    website: 'website',
    motto: 'motto',
    foundingYear: 'foundingYear',
    logo: 'logo',
    brandColor: 'brandColor',
    facebook: 'facebook',
    twitter: 'twitter',
    linkedin: 'linkedin',
    instagram: 'instagram',
    youtube: 'youtube',
    currency: 'currency',
    timezone: 'timezone',
    dateFormat: 'dateFormat',
    googleMapsApiKey: 'googleMapsApiKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const AdmissionScalarFieldEnum: {
    id: 'id',
    studentName: 'studentName',
    studentAge: 'studentAge',
    studentGender: 'studentGender',
    dateOfBirth: 'dateOfBirth',
    parentName: 'parentName',
    parentEmail: 'parentEmail',
    parentPhone: 'parentPhone',
    secondaryPhone: 'secondaryPhone',
    relationship: 'relationship',
    fatherName: 'fatherName',
    fatherPhone: 'fatherPhone',
    fatherEmail: 'fatherEmail',
    fatherOccupation: 'fatherOccupation',
    motherName: 'motherName',
    motherPhone: 'motherPhone',
    motherEmail: 'motherEmail',
    motherOccupation: 'motherOccupation',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    zip: 'zip',
    officialStatus: 'officialStatus',
    stage: 'stage',
    priority: 'priority',
    enrolledGrade: 'enrolledGrade',
    source: 'source',
    notes: 'notes',
    bloodGroup: 'bloodGroup',
    medicalConditions: 'medicalConditions',
    allergies: 'allergies',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    previousSchool: 'previousSchool',
    documents: 'documents',
    accessToken: 'accessToken',
    admissionFormStep: 'admissionFormStep',
    dateReceived: 'dateReceived',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionScalarFieldEnum = (typeof AdmissionScalarFieldEnum)[keyof typeof AdmissionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    mobile: 'mobile',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    designation: 'designation',
    department: 'department',
    joiningDate: 'joiningDate',
    status: 'status',
    avatar: 'avatar',
    address: 'address',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    schoolId: 'schoolId',
    documents: 'documents',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    bloodGroup: 'bloodGroup',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    emergencyContactRelation: 'emergencyContactRelation',
    addressCity: 'addressCity',
    addressState: 'addressState',
    addressZip: 'addressZip',
    addressCountry: 'addressCountry',
    qualifications: 'qualifications',
    experience: 'experience',
    employmentType: 'employmentType',
    bankName: 'bankName',
    bankAccountNo: 'bankAccountNo',
    bankIfsc: 'bankIfsc',
    facebook: 'facebook',
    linkedin: 'linkedin',
    twitter: 'twitter',
    instagram: 'instagram'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LeavePolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    isDefault: 'isDefault',
    schoolId: 'schoolId',
    lateComingGrace: 'lateComingGrace',
    lateComingMax: 'lateComingMax',
    earlyLeavingGrace: 'earlyLeavingGrace',
    earlyLeavingMax: 'earlyLeavingMax',
    permissionAllowed: 'permissionAllowed',
    permissionMaxMins: 'permissionMaxMins',
    permissionMaxOccur: 'permissionMaxOccur',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeavePolicyScalarFieldEnum = (typeof LeavePolicyScalarFieldEnum)[keyof typeof LeavePolicyScalarFieldEnum]


  export const LeaveTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    totalDays: 'totalDays',
    canCarryForward: 'canCarryForward',
    maxCarryForward: 'maxCarryForward',
    isPaid: 'isPaid',
    allowHalfDay: 'allowHalfDay',
    minNoticePeriod: 'minNoticePeriod',
    requiresApproval: 'requiresApproval',
    gender: 'gender',
    policyId: 'policyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveTypeScalarFieldEnum = (typeof LeaveTypeScalarFieldEnum)[keyof typeof LeaveTypeScalarFieldEnum]


  export const LeaveBalanceScalarFieldEnum: {
    id: 'id',
    total: 'total',
    used: 'used',
    pending: 'pending',
    remaining: 'remaining',
    userId: 'userId',
    leaveTypeId: 'leaveTypeId',
    year: 'year',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveBalanceScalarFieldEnum = (typeof LeaveBalanceScalarFieldEnum)[keyof typeof LeaveBalanceScalarFieldEnum]


  export const SalaryRevisionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currency: 'currency',
    revisionDate: 'revisionDate',
    effectiveDate: 'effectiveDate',
    reason: 'reason',
    type: 'type',
    basic: 'basic',
    hra: 'hra',
    allowance: 'allowance',
    tax: 'tax',
    pf: 'pf',
    insurance: 'insurance',
    otherDeductions: 'otherDeductions',
    netSalary: 'netSalary',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalaryRevisionScalarFieldEnum = (typeof SalaryRevisionScalarFieldEnum)[keyof typeof SalaryRevisionScalarFieldEnum]


  export const ClassroomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    schoolId: 'schoolId',
    teacherId: 'teacherId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassroomScalarFieldEnum = (typeof ClassroomScalarFieldEnum)[keyof typeof ClassroomScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    avatar: 'avatar',
    age: 'age',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    grade: 'grade',
    status: 'status',
    parentName: 'parentName',
    parentMobile: 'parentMobile',
    parentEmail: 'parentEmail',
    bloodGroup: 'bloodGroup',
    medicalConditions: 'medicalConditions',
    allergies: 'allergies',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    classroomId: 'classroomId',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const FeeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeScalarFieldEnum = (typeof FeeScalarFieldEnum)[keyof typeof FeeScalarFieldEnum]


  export const FeePaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    date: 'date',
    method: 'method',
    reference: 'reference',
    feeId: 'feeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeePaymentScalarFieldEnum = (typeof FeePaymentScalarFieldEnum)[keyof typeof FeePaymentScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    date: 'date',
    status: 'status',
    notes: 'notes',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const ReportCardScalarFieldEnum: {
    id: 'id',
    term: 'term',
    marks: 'marks',
    comments: 'comments',
    published: 'published',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportCardScalarFieldEnum = (typeof ReportCardScalarFieldEnum)[keyof typeof ReportCardScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    mobile: 'mobile',
    code: 'code',
    expiresAt: 'expiresAt',
    verified: 'verified',
    createdAt: 'createdAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    schoolId: 'schoolId'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const MasterDataScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    code: 'code',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MasterDataScalarFieldEnum = (typeof MasterDataScalarFieldEnum)[keyof typeof MasterDataScalarFieldEnum]


  export const StaffAttendanceScalarFieldEnum: {
    id: 'id',
    date: 'date',
    status: 'status',
    notes: 'notes',
    totalHours: 'totalHours',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffAttendanceScalarFieldEnum = (typeof StaffAttendanceScalarFieldEnum)[keyof typeof StaffAttendanceScalarFieldEnum]


  export const StaffPunchScalarFieldEnum: {
    id: 'id',
    type: 'type',
    timestamp: 'timestamp',
    attendanceId: 'attendanceId'
  };

  export type StaffPunchScalarFieldEnum = (typeof StaffPunchScalarFieldEnum)[keyof typeof StaffPunchScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    type: 'type',
    reason: 'reason',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const FeeStructureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    academicYear: 'academicYear',
    description: 'description',
    termConfig: 'termConfig',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeStructureScalarFieldEnum = (typeof FeeStructureScalarFieldEnum)[keyof typeof FeeStructureScalarFieldEnum]


  export const FeeComponentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    amount: 'amount',
    currency: 'currency',
    frequency: 'frequency',
    dueDate: 'dueDate',
    dueDay: 'dueDay',
    dueMonth: 'dueMonth',
    isOptional: 'isOptional',
    isRefundable: 'isRefundable',
    midTermRule: 'midTermRule',
    feeStructureId: 'feeStructureId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeComponentScalarFieldEnum = (typeof FeeComponentScalarFieldEnum)[keyof typeof FeeComponentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    slug?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    city?: StringNullableFilter<"School"> | string | null
    state?: StringNullableFilter<"School"> | string | null
    zip?: StringNullableFilter<"School"> | string | null
    country?: StringNullableFilter<"School"> | string | null
    latitude?: StringNullableFilter<"School"> | string | null
    longitude?: StringNullableFilter<"School"> | string | null
    phone?: StringNullableFilter<"School"> | string | null
    email?: StringNullableFilter<"School"> | string | null
    website?: StringNullableFilter<"School"> | string | null
    motto?: StringNullableFilter<"School"> | string | null
    foundingYear?: StringNullableFilter<"School"> | string | null
    logo?: StringNullableFilter<"School"> | string | null
    brandColor?: StringNullableFilter<"School"> | string | null
    facebook?: StringNullableFilter<"School"> | string | null
    twitter?: StringNullableFilter<"School"> | string | null
    linkedin?: StringNullableFilter<"School"> | string | null
    instagram?: StringNullableFilter<"School"> | string | null
    youtube?: StringNullableFilter<"School"> | string | null
    currency?: StringNullableFilter<"School"> | string | null
    timezone?: StringNullableFilter<"School"> | string | null
    dateFormat?: StringNullableFilter<"School"> | string | null
    googleMapsApiKey?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    students?: StudentListRelationFilter
    classrooms?: ClassroomListRelationFilter
    admissions?: AdmissionListRelationFilter
    leavePolicies?: LeavePolicyListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    feeStructures?: FeeStructureListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    motto?: SortOrderInput | SortOrder
    foundingYear?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    brandColor?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    dateFormat?: SortOrderInput | SortOrder
    googleMapsApiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    classrooms?: ClassroomOrderByRelationAggregateInput
    admissions?: AdmissionOrderByRelationAggregateInput
    leavePolicies?: LeavePolicyOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    feeStructures?: FeeStructureOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    city?: StringNullableFilter<"School"> | string | null
    state?: StringNullableFilter<"School"> | string | null
    zip?: StringNullableFilter<"School"> | string | null
    country?: StringNullableFilter<"School"> | string | null
    latitude?: StringNullableFilter<"School"> | string | null
    longitude?: StringNullableFilter<"School"> | string | null
    phone?: StringNullableFilter<"School"> | string | null
    email?: StringNullableFilter<"School"> | string | null
    website?: StringNullableFilter<"School"> | string | null
    motto?: StringNullableFilter<"School"> | string | null
    foundingYear?: StringNullableFilter<"School"> | string | null
    logo?: StringNullableFilter<"School"> | string | null
    brandColor?: StringNullableFilter<"School"> | string | null
    facebook?: StringNullableFilter<"School"> | string | null
    twitter?: StringNullableFilter<"School"> | string | null
    linkedin?: StringNullableFilter<"School"> | string | null
    instagram?: StringNullableFilter<"School"> | string | null
    youtube?: StringNullableFilter<"School"> | string | null
    currency?: StringNullableFilter<"School"> | string | null
    timezone?: StringNullableFilter<"School"> | string | null
    dateFormat?: StringNullableFilter<"School"> | string | null
    googleMapsApiKey?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    students?: StudentListRelationFilter
    classrooms?: ClassroomListRelationFilter
    admissions?: AdmissionListRelationFilter
    leavePolicies?: LeavePolicyListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    feeStructures?: FeeStructureListRelationFilter
  }, "id" | "slug">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    motto?: SortOrderInput | SortOrder
    foundingYear?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    brandColor?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    dateFormat?: SortOrderInput | SortOrder
    googleMapsApiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    slug?: StringWithAggregatesFilter<"School"> | string
    address?: StringNullableWithAggregatesFilter<"School"> | string | null
    city?: StringNullableWithAggregatesFilter<"School"> | string | null
    state?: StringNullableWithAggregatesFilter<"School"> | string | null
    zip?: StringNullableWithAggregatesFilter<"School"> | string | null
    country?: StringNullableWithAggregatesFilter<"School"> | string | null
    latitude?: StringNullableWithAggregatesFilter<"School"> | string | null
    longitude?: StringNullableWithAggregatesFilter<"School"> | string | null
    phone?: StringNullableWithAggregatesFilter<"School"> | string | null
    email?: StringNullableWithAggregatesFilter<"School"> | string | null
    website?: StringNullableWithAggregatesFilter<"School"> | string | null
    motto?: StringNullableWithAggregatesFilter<"School"> | string | null
    foundingYear?: StringNullableWithAggregatesFilter<"School"> | string | null
    logo?: StringNullableWithAggregatesFilter<"School"> | string | null
    brandColor?: StringNullableWithAggregatesFilter<"School"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"School"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"School"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"School"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"School"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"School"> | string | null
    currency?: StringNullableWithAggregatesFilter<"School"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"School"> | string | null
    dateFormat?: StringNullableWithAggregatesFilter<"School"> | string | null
    googleMapsApiKey?: StringNullableWithAggregatesFilter<"School"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type AdmissionWhereInput = {
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    id?: StringFilter<"Admission"> | string
    studentName?: StringFilter<"Admission"> | string
    studentAge?: IntNullableFilter<"Admission"> | number | null
    studentGender?: StringNullableFilter<"Admission"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Admission"> | Date | string | null
    parentName?: StringFilter<"Admission"> | string
    parentEmail?: StringNullableFilter<"Admission"> | string | null
    parentPhone?: StringNullableFilter<"Admission"> | string | null
    secondaryPhone?: StringNullableFilter<"Admission"> | string | null
    relationship?: StringNullableFilter<"Admission"> | string | null
    fatherName?: StringNullableFilter<"Admission"> | string | null
    fatherPhone?: StringNullableFilter<"Admission"> | string | null
    fatherEmail?: StringNullableFilter<"Admission"> | string | null
    fatherOccupation?: StringNullableFilter<"Admission"> | string | null
    motherName?: StringNullableFilter<"Admission"> | string | null
    motherPhone?: StringNullableFilter<"Admission"> | string | null
    motherEmail?: StringNullableFilter<"Admission"> | string | null
    motherOccupation?: StringNullableFilter<"Admission"> | string | null
    address?: StringNullableFilter<"Admission"> | string | null
    city?: StringNullableFilter<"Admission"> | string | null
    state?: StringNullableFilter<"Admission"> | string | null
    country?: StringNullableFilter<"Admission"> | string | null
    zip?: StringNullableFilter<"Admission"> | string | null
    officialStatus?: StringNullableFilter<"Admission"> | string | null
    stage?: StringFilter<"Admission"> | string
    priority?: StringFilter<"Admission"> | string
    enrolledGrade?: StringNullableFilter<"Admission"> | string | null
    source?: StringNullableFilter<"Admission"> | string | null
    notes?: StringNullableFilter<"Admission"> | string | null
    bloodGroup?: StringNullableFilter<"Admission"> | string | null
    medicalConditions?: StringNullableFilter<"Admission"> | string | null
    allergies?: StringNullableFilter<"Admission"> | string | null
    emergencyContactName?: StringNullableFilter<"Admission"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Admission"> | string | null
    previousSchool?: StringNullableFilter<"Admission"> | string | null
    documents?: StringNullableFilter<"Admission"> | string | null
    accessToken?: StringNullableFilter<"Admission"> | string | null
    admissionFormStep?: IntFilter<"Admission"> | number
    dateReceived?: DateTimeFilter<"Admission"> | Date | string
    schoolId?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type AdmissionOrderByWithRelationInput = {
    id?: SortOrder
    studentName?: SortOrder
    studentAge?: SortOrderInput | SortOrder
    studentGender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    parentName?: SortOrder
    parentEmail?: SortOrderInput | SortOrder
    parentPhone?: SortOrderInput | SortOrder
    secondaryPhone?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    fatherPhone?: SortOrderInput | SortOrder
    fatherEmail?: SortOrderInput | SortOrder
    fatherOccupation?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    motherPhone?: SortOrderInput | SortOrder
    motherEmail?: SortOrderInput | SortOrder
    motherOccupation?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    officialStatus?: SortOrderInput | SortOrder
    stage?: SortOrder
    priority?: SortOrder
    enrolledGrade?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    previousSchool?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    admissionFormStep?: SortOrder
    dateReceived?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type AdmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessToken?: string
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    studentName?: StringFilter<"Admission"> | string
    studentAge?: IntNullableFilter<"Admission"> | number | null
    studentGender?: StringNullableFilter<"Admission"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Admission"> | Date | string | null
    parentName?: StringFilter<"Admission"> | string
    parentEmail?: StringNullableFilter<"Admission"> | string | null
    parentPhone?: StringNullableFilter<"Admission"> | string | null
    secondaryPhone?: StringNullableFilter<"Admission"> | string | null
    relationship?: StringNullableFilter<"Admission"> | string | null
    fatherName?: StringNullableFilter<"Admission"> | string | null
    fatherPhone?: StringNullableFilter<"Admission"> | string | null
    fatherEmail?: StringNullableFilter<"Admission"> | string | null
    fatherOccupation?: StringNullableFilter<"Admission"> | string | null
    motherName?: StringNullableFilter<"Admission"> | string | null
    motherPhone?: StringNullableFilter<"Admission"> | string | null
    motherEmail?: StringNullableFilter<"Admission"> | string | null
    motherOccupation?: StringNullableFilter<"Admission"> | string | null
    address?: StringNullableFilter<"Admission"> | string | null
    city?: StringNullableFilter<"Admission"> | string | null
    state?: StringNullableFilter<"Admission"> | string | null
    country?: StringNullableFilter<"Admission"> | string | null
    zip?: StringNullableFilter<"Admission"> | string | null
    officialStatus?: StringNullableFilter<"Admission"> | string | null
    stage?: StringFilter<"Admission"> | string
    priority?: StringFilter<"Admission"> | string
    enrolledGrade?: StringNullableFilter<"Admission"> | string | null
    source?: StringNullableFilter<"Admission"> | string | null
    notes?: StringNullableFilter<"Admission"> | string | null
    bloodGroup?: StringNullableFilter<"Admission"> | string | null
    medicalConditions?: StringNullableFilter<"Admission"> | string | null
    allergies?: StringNullableFilter<"Admission"> | string | null
    emergencyContactName?: StringNullableFilter<"Admission"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Admission"> | string | null
    previousSchool?: StringNullableFilter<"Admission"> | string | null
    documents?: StringNullableFilter<"Admission"> | string | null
    admissionFormStep?: IntFilter<"Admission"> | number
    dateReceived?: DateTimeFilter<"Admission"> | Date | string
    schoolId?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id" | "accessToken">

  export type AdmissionOrderByWithAggregationInput = {
    id?: SortOrder
    studentName?: SortOrder
    studentAge?: SortOrderInput | SortOrder
    studentGender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    parentName?: SortOrder
    parentEmail?: SortOrderInput | SortOrder
    parentPhone?: SortOrderInput | SortOrder
    secondaryPhone?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    fatherPhone?: SortOrderInput | SortOrder
    fatherEmail?: SortOrderInput | SortOrder
    fatherOccupation?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    motherPhone?: SortOrderInput | SortOrder
    motherEmail?: SortOrderInput | SortOrder
    motherOccupation?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    officialStatus?: SortOrderInput | SortOrder
    stage?: SortOrder
    priority?: SortOrder
    enrolledGrade?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    previousSchool?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    admissionFormStep?: SortOrder
    dateReceived?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionCountOrderByAggregateInput
    _avg?: AdmissionAvgOrderByAggregateInput
    _max?: AdmissionMaxOrderByAggregateInput
    _min?: AdmissionMinOrderByAggregateInput
    _sum?: AdmissionSumOrderByAggregateInput
  }

  export type AdmissionScalarWhereWithAggregatesInput = {
    AND?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    OR?: AdmissionScalarWhereWithAggregatesInput[]
    NOT?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admission"> | string
    studentName?: StringWithAggregatesFilter<"Admission"> | string
    studentAge?: IntNullableWithAggregatesFilter<"Admission"> | number | null
    studentGender?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Admission"> | Date | string | null
    parentName?: StringWithAggregatesFilter<"Admission"> | string
    parentEmail?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    parentPhone?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    secondaryPhone?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    relationship?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    fatherName?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    fatherPhone?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    fatherEmail?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    fatherOccupation?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    motherName?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    motherPhone?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    motherEmail?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    motherOccupation?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    address?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    city?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    state?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    country?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    zip?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    officialStatus?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    stage?: StringWithAggregatesFilter<"Admission"> | string
    priority?: StringWithAggregatesFilter<"Admission"> | string
    enrolledGrade?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    source?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    medicalConditions?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    previousSchool?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    documents?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    admissionFormStep?: IntWithAggregatesFilter<"Admission"> | number
    dateReceived?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    schoolId?: StringWithAggregatesFilter<"Admission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    mobile?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    joiningDate?: DateTimeNullableFilter<"User"> | Date | string | null
    status?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    schoolId?: StringNullableFilter<"User"> | string | null
    documents?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    bloodGroup?: StringNullableFilter<"User"> | string | null
    emergencyContactName?: StringNullableFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableFilter<"User"> | string | null
    emergencyContactRelation?: StringNullableFilter<"User"> | string | null
    addressCity?: StringNullableFilter<"User"> | string | null
    addressState?: StringNullableFilter<"User"> | string | null
    addressZip?: StringNullableFilter<"User"> | string | null
    addressCountry?: StringNullableFilter<"User"> | string | null
    qualifications?: StringNullableFilter<"User"> | string | null
    experience?: StringNullableFilter<"User"> | string | null
    employmentType?: StringNullableFilter<"User"> | string | null
    bankName?: StringNullableFilter<"User"> | string | null
    bankAccountNo?: StringNullableFilter<"User"> | string | null
    bankIfsc?: StringNullableFilter<"User"> | string | null
    facebook?: StringNullableFilter<"User"> | string | null
    linkedin?: StringNullableFilter<"User"> | string | null
    twitter?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
    managedClassrooms?: ClassroomListRelationFilter
    staffAttendance?: StaffAttendanceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    salaryRevisions?: SalaryRevisionListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    mobile?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    joiningDate?: SortOrderInput | SortOrder
    status?: SortOrder
    avatar?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelation?: SortOrderInput | SortOrder
    addressCity?: SortOrderInput | SortOrder
    addressState?: SortOrderInput | SortOrder
    addressZip?: SortOrderInput | SortOrder
    addressCountry?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountNo?: SortOrderInput | SortOrder
    bankIfsc?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    school?: SchoolOrderByWithRelationInput
    managedClassrooms?: ClassroomOrderByRelationAggregateInput
    staffAttendance?: StaffAttendanceOrderByRelationAggregateInput
    leaveRequests?: LeaveRequestOrderByRelationAggregateInput
    salaryRevisions?: SalaryRevisionOrderByRelationAggregateInput
    leaveBalances?: LeaveBalanceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mobile?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    joiningDate?: DateTimeNullableFilter<"User"> | Date | string | null
    status?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    schoolId?: StringNullableFilter<"User"> | string | null
    documents?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    bloodGroup?: StringNullableFilter<"User"> | string | null
    emergencyContactName?: StringNullableFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableFilter<"User"> | string | null
    emergencyContactRelation?: StringNullableFilter<"User"> | string | null
    addressCity?: StringNullableFilter<"User"> | string | null
    addressState?: StringNullableFilter<"User"> | string | null
    addressZip?: StringNullableFilter<"User"> | string | null
    addressCountry?: StringNullableFilter<"User"> | string | null
    qualifications?: StringNullableFilter<"User"> | string | null
    experience?: StringNullableFilter<"User"> | string | null
    employmentType?: StringNullableFilter<"User"> | string | null
    bankName?: StringNullableFilter<"User"> | string | null
    bankAccountNo?: StringNullableFilter<"User"> | string | null
    bankIfsc?: StringNullableFilter<"User"> | string | null
    facebook?: StringNullableFilter<"User"> | string | null
    linkedin?: StringNullableFilter<"User"> | string | null
    twitter?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
    managedClassrooms?: ClassroomListRelationFilter
    staffAttendance?: StaffAttendanceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    salaryRevisions?: SalaryRevisionListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
  }, "id" | "mobile">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    mobile?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    joiningDate?: SortOrderInput | SortOrder
    status?: SortOrder
    avatar?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelation?: SortOrderInput | SortOrder
    addressCity?: SortOrderInput | SortOrder
    addressState?: SortOrderInput | SortOrder
    addressZip?: SortOrderInput | SortOrder
    addressCountry?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountNo?: SortOrderInput | SortOrder
    bankIfsc?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    mobile?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    designation?: StringNullableWithAggregatesFilter<"User"> | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    joiningDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    status?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    schoolId?: StringNullableWithAggregatesFilter<"User"> | string | null
    documents?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyContactRelation?: StringNullableWithAggregatesFilter<"User"> | string | null
    addressCity?: StringNullableWithAggregatesFilter<"User"> | string | null
    addressState?: StringNullableWithAggregatesFilter<"User"> | string | null
    addressZip?: StringNullableWithAggregatesFilter<"User"> | string | null
    addressCountry?: StringNullableWithAggregatesFilter<"User"> | string | null
    qualifications?: StringNullableWithAggregatesFilter<"User"> | string | null
    experience?: StringNullableWithAggregatesFilter<"User"> | string | null
    employmentType?: StringNullableWithAggregatesFilter<"User"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"User"> | string | null
    bankAccountNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    bankIfsc?: StringNullableWithAggregatesFilter<"User"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"User"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"User"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"User"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type LeavePolicyWhereInput = {
    AND?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    OR?: LeavePolicyWhereInput[]
    NOT?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    id?: StringFilter<"LeavePolicy"> | string
    name?: StringFilter<"LeavePolicy"> | string
    description?: StringNullableFilter<"LeavePolicy"> | string | null
    effectiveFrom?: DateTimeFilter<"LeavePolicy"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"LeavePolicy"> | Date | string | null
    isDefault?: BoolFilter<"LeavePolicy"> | boolean
    schoolId?: StringFilter<"LeavePolicy"> | string
    lateComingGrace?: IntFilter<"LeavePolicy"> | number
    lateComingMax?: IntFilter<"LeavePolicy"> | number
    earlyLeavingGrace?: IntFilter<"LeavePolicy"> | number
    earlyLeavingMax?: IntFilter<"LeavePolicy"> | number
    permissionAllowed?: BoolFilter<"LeavePolicy"> | boolean
    permissionMaxMins?: IntFilter<"LeavePolicy"> | number
    permissionMaxOccur?: IntFilter<"LeavePolicy"> | number
    createdAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    leaveTypes?: LeaveTypeListRelationFilter
  }

  export type LeavePolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    schoolId?: SortOrder
    lateComingGrace?: SortOrder
    lateComingMax?: SortOrder
    earlyLeavingGrace?: SortOrder
    earlyLeavingMax?: SortOrder
    permissionAllowed?: SortOrder
    permissionMaxMins?: SortOrder
    permissionMaxOccur?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    leaveTypes?: LeaveTypeOrderByRelationAggregateInput
  }

  export type LeavePolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    OR?: LeavePolicyWhereInput[]
    NOT?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    name?: StringFilter<"LeavePolicy"> | string
    description?: StringNullableFilter<"LeavePolicy"> | string | null
    effectiveFrom?: DateTimeFilter<"LeavePolicy"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"LeavePolicy"> | Date | string | null
    isDefault?: BoolFilter<"LeavePolicy"> | boolean
    schoolId?: StringFilter<"LeavePolicy"> | string
    lateComingGrace?: IntFilter<"LeavePolicy"> | number
    lateComingMax?: IntFilter<"LeavePolicy"> | number
    earlyLeavingGrace?: IntFilter<"LeavePolicy"> | number
    earlyLeavingMax?: IntFilter<"LeavePolicy"> | number
    permissionAllowed?: BoolFilter<"LeavePolicy"> | boolean
    permissionMaxMins?: IntFilter<"LeavePolicy"> | number
    permissionMaxOccur?: IntFilter<"LeavePolicy"> | number
    createdAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    leaveTypes?: LeaveTypeListRelationFilter
  }, "id">

  export type LeavePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    schoolId?: SortOrder
    lateComingGrace?: SortOrder
    lateComingMax?: SortOrder
    earlyLeavingGrace?: SortOrder
    earlyLeavingMax?: SortOrder
    permissionAllowed?: SortOrder
    permissionMaxMins?: SortOrder
    permissionMaxOccur?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeavePolicyCountOrderByAggregateInput
    _avg?: LeavePolicyAvgOrderByAggregateInput
    _max?: LeavePolicyMaxOrderByAggregateInput
    _min?: LeavePolicyMinOrderByAggregateInput
    _sum?: LeavePolicySumOrderByAggregateInput
  }

  export type LeavePolicyScalarWhereWithAggregatesInput = {
    AND?: LeavePolicyScalarWhereWithAggregatesInput | LeavePolicyScalarWhereWithAggregatesInput[]
    OR?: LeavePolicyScalarWhereWithAggregatesInput[]
    NOT?: LeavePolicyScalarWhereWithAggregatesInput | LeavePolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeavePolicy"> | string
    name?: StringWithAggregatesFilter<"LeavePolicy"> | string
    description?: StringNullableWithAggregatesFilter<"LeavePolicy"> | string | null
    effectiveFrom?: DateTimeWithAggregatesFilter<"LeavePolicy"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"LeavePolicy"> | Date | string | null
    isDefault?: BoolWithAggregatesFilter<"LeavePolicy"> | boolean
    schoolId?: StringWithAggregatesFilter<"LeavePolicy"> | string
    lateComingGrace?: IntWithAggregatesFilter<"LeavePolicy"> | number
    lateComingMax?: IntWithAggregatesFilter<"LeavePolicy"> | number
    earlyLeavingGrace?: IntWithAggregatesFilter<"LeavePolicy"> | number
    earlyLeavingMax?: IntWithAggregatesFilter<"LeavePolicy"> | number
    permissionAllowed?: BoolWithAggregatesFilter<"LeavePolicy"> | boolean
    permissionMaxMins?: IntWithAggregatesFilter<"LeavePolicy"> | number
    permissionMaxOccur?: IntWithAggregatesFilter<"LeavePolicy"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeavePolicy"> | Date | string
  }

  export type LeaveTypeWhereInput = {
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    id?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    totalDays?: FloatFilter<"LeaveType"> | number
    canCarryForward?: BoolFilter<"LeaveType"> | boolean
    maxCarryForward?: FloatFilter<"LeaveType"> | number
    isPaid?: BoolFilter<"LeaveType"> | boolean
    allowHalfDay?: BoolFilter<"LeaveType"> | boolean
    minNoticePeriod?: IntFilter<"LeaveType"> | number
    requiresApproval?: BoolFilter<"LeaveType"> | boolean
    gender?: StringNullableFilter<"LeaveType"> | string | null
    policyId?: StringFilter<"LeaveType"> | string
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
    policy?: XOR<LeavePolicyRelationFilter, LeavePolicyWhereInput>
    leaveBalances?: LeaveBalanceListRelationFilter
  }

  export type LeaveTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    totalDays?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForward?: SortOrder
    isPaid?: SortOrder
    allowHalfDay?: SortOrder
    minNoticePeriod?: SortOrder
    requiresApproval?: SortOrder
    gender?: SortOrderInput | SortOrder
    policyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    policy?: LeavePolicyOrderByWithRelationInput
    leaveBalances?: LeaveBalanceOrderByRelationAggregateInput
  }

  export type LeaveTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    totalDays?: FloatFilter<"LeaveType"> | number
    canCarryForward?: BoolFilter<"LeaveType"> | boolean
    maxCarryForward?: FloatFilter<"LeaveType"> | number
    isPaid?: BoolFilter<"LeaveType"> | boolean
    allowHalfDay?: BoolFilter<"LeaveType"> | boolean
    minNoticePeriod?: IntFilter<"LeaveType"> | number
    requiresApproval?: BoolFilter<"LeaveType"> | boolean
    gender?: StringNullableFilter<"LeaveType"> | string | null
    policyId?: StringFilter<"LeaveType"> | string
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
    policy?: XOR<LeavePolicyRelationFilter, LeavePolicyWhereInput>
    leaveBalances?: LeaveBalanceListRelationFilter
  }, "id">

  export type LeaveTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    totalDays?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForward?: SortOrder
    isPaid?: SortOrder
    allowHalfDay?: SortOrder
    minNoticePeriod?: SortOrder
    requiresApproval?: SortOrder
    gender?: SortOrderInput | SortOrder
    policyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveTypeCountOrderByAggregateInput
    _avg?: LeaveTypeAvgOrderByAggregateInput
    _max?: LeaveTypeMaxOrderByAggregateInput
    _min?: LeaveTypeMinOrderByAggregateInput
    _sum?: LeaveTypeSumOrderByAggregateInput
  }

  export type LeaveTypeScalarWhereWithAggregatesInput = {
    AND?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    OR?: LeaveTypeScalarWhereWithAggregatesInput[]
    NOT?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveType"> | string
    name?: StringWithAggregatesFilter<"LeaveType"> | string
    code?: StringWithAggregatesFilter<"LeaveType"> | string
    totalDays?: FloatWithAggregatesFilter<"LeaveType"> | number
    canCarryForward?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    maxCarryForward?: FloatWithAggregatesFilter<"LeaveType"> | number
    isPaid?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    allowHalfDay?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    minNoticePeriod?: IntWithAggregatesFilter<"LeaveType"> | number
    requiresApproval?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    gender?: StringNullableWithAggregatesFilter<"LeaveType"> | string | null
    policyId?: StringWithAggregatesFilter<"LeaveType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveType"> | Date | string
  }

  export type LeaveBalanceWhereInput = {
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    total?: FloatFilter<"LeaveBalance"> | number
    used?: FloatFilter<"LeaveBalance"> | number
    pending?: FloatFilter<"LeaveBalance"> | number
    remaining?: FloatFilter<"LeaveBalance"> | number
    userId?: StringFilter<"LeaveBalance"> | string
    leaveTypeId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    createdAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    leaveType?: XOR<LeaveTypeRelationFilter, LeaveTypeWhereInput>
  }

  export type LeaveBalanceOrderByWithRelationInput = {
    id?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    userId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    leaveType?: LeaveTypeOrderByWithRelationInput
  }

  export type LeaveBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_leaveTypeId_year?: LeaveBalanceUserIdLeaveTypeIdYearCompoundUniqueInput
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    total?: FloatFilter<"LeaveBalance"> | number
    used?: FloatFilter<"LeaveBalance"> | number
    pending?: FloatFilter<"LeaveBalance"> | number
    remaining?: FloatFilter<"LeaveBalance"> | number
    userId?: StringFilter<"LeaveBalance"> | string
    leaveTypeId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    createdAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    leaveType?: XOR<LeaveTypeRelationFilter, LeaveTypeWhereInput>
  }, "id" | "userId_leaveTypeId_year">

  export type LeaveBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    userId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveBalanceCountOrderByAggregateInput
    _avg?: LeaveBalanceAvgOrderByAggregateInput
    _max?: LeaveBalanceMaxOrderByAggregateInput
    _min?: LeaveBalanceMinOrderByAggregateInput
    _sum?: LeaveBalanceSumOrderByAggregateInput
  }

  export type LeaveBalanceScalarWhereWithAggregatesInput = {
    AND?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    OR?: LeaveBalanceScalarWhereWithAggregatesInput[]
    NOT?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveBalance"> | string
    total?: FloatWithAggregatesFilter<"LeaveBalance"> | number
    used?: FloatWithAggregatesFilter<"LeaveBalance"> | number
    pending?: FloatWithAggregatesFilter<"LeaveBalance"> | number
    remaining?: FloatWithAggregatesFilter<"LeaveBalance"> | number
    userId?: StringWithAggregatesFilter<"LeaveBalance"> | string
    leaveTypeId?: StringWithAggregatesFilter<"LeaveBalance"> | string
    year?: IntWithAggregatesFilter<"LeaveBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveBalance"> | Date | string
  }

  export type SalaryRevisionWhereInput = {
    AND?: SalaryRevisionWhereInput | SalaryRevisionWhereInput[]
    OR?: SalaryRevisionWhereInput[]
    NOT?: SalaryRevisionWhereInput | SalaryRevisionWhereInput[]
    id?: StringFilter<"SalaryRevision"> | string
    amount?: FloatFilter<"SalaryRevision"> | number
    currency?: StringFilter<"SalaryRevision"> | string
    revisionDate?: DateTimeFilter<"SalaryRevision"> | Date | string
    effectiveDate?: DateTimeFilter<"SalaryRevision"> | Date | string
    reason?: StringNullableFilter<"SalaryRevision"> | string | null
    type?: StringFilter<"SalaryRevision"> | string
    basic?: FloatFilter<"SalaryRevision"> | number
    hra?: FloatFilter<"SalaryRevision"> | number
    allowance?: FloatFilter<"SalaryRevision"> | number
    tax?: FloatFilter<"SalaryRevision"> | number
    pf?: FloatFilter<"SalaryRevision"> | number
    insurance?: FloatFilter<"SalaryRevision"> | number
    otherDeductions?: FloatFilter<"SalaryRevision"> | number
    netSalary?: FloatFilter<"SalaryRevision"> | number
    userId?: StringFilter<"SalaryRevision"> | string
    createdAt?: DateTimeFilter<"SalaryRevision"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryRevision"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SalaryRevisionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    revisionDate?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    type?: SortOrder
    basic?: SortOrder
    hra?: SortOrder
    allowance?: SortOrder
    tax?: SortOrder
    pf?: SortOrder
    insurance?: SortOrder
    otherDeductions?: SortOrder
    netSalary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SalaryRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalaryRevisionWhereInput | SalaryRevisionWhereInput[]
    OR?: SalaryRevisionWhereInput[]
    NOT?: SalaryRevisionWhereInput | SalaryRevisionWhereInput[]
    amount?: FloatFilter<"SalaryRevision"> | number
    currency?: StringFilter<"SalaryRevision"> | string
    revisionDate?: DateTimeFilter<"SalaryRevision"> | Date | string
    effectiveDate?: DateTimeFilter<"SalaryRevision"> | Date | string
    reason?: StringNullableFilter<"SalaryRevision"> | string | null
    type?: StringFilter<"SalaryRevision"> | string
    basic?: FloatFilter<"SalaryRevision"> | number
    hra?: FloatFilter<"SalaryRevision"> | number
    allowance?: FloatFilter<"SalaryRevision"> | number
    tax?: FloatFilter<"SalaryRevision"> | number
    pf?: FloatFilter<"SalaryRevision"> | number
    insurance?: FloatFilter<"SalaryRevision"> | number
    otherDeductions?: FloatFilter<"SalaryRevision"> | number
    netSalary?: FloatFilter<"SalaryRevision"> | number
    userId?: StringFilter<"SalaryRevision"> | string
    createdAt?: DateTimeFilter<"SalaryRevision"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryRevision"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SalaryRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    revisionDate?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    type?: SortOrder
    basic?: SortOrder
    hra?: SortOrder
    allowance?: SortOrder
    tax?: SortOrder
    pf?: SortOrder
    insurance?: SortOrder
    otherDeductions?: SortOrder
    netSalary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalaryRevisionCountOrderByAggregateInput
    _avg?: SalaryRevisionAvgOrderByAggregateInput
    _max?: SalaryRevisionMaxOrderByAggregateInput
    _min?: SalaryRevisionMinOrderByAggregateInput
    _sum?: SalaryRevisionSumOrderByAggregateInput
  }

  export type SalaryRevisionScalarWhereWithAggregatesInput = {
    AND?: SalaryRevisionScalarWhereWithAggregatesInput | SalaryRevisionScalarWhereWithAggregatesInput[]
    OR?: SalaryRevisionScalarWhereWithAggregatesInput[]
    NOT?: SalaryRevisionScalarWhereWithAggregatesInput | SalaryRevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalaryRevision"> | string
    amount?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    currency?: StringWithAggregatesFilter<"SalaryRevision"> | string
    revisionDate?: DateTimeWithAggregatesFilter<"SalaryRevision"> | Date | string
    effectiveDate?: DateTimeWithAggregatesFilter<"SalaryRevision"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"SalaryRevision"> | string | null
    type?: StringWithAggregatesFilter<"SalaryRevision"> | string
    basic?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    hra?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    allowance?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    tax?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    pf?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    insurance?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    otherDeductions?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    netSalary?: FloatWithAggregatesFilter<"SalaryRevision"> | number
    userId?: StringWithAggregatesFilter<"SalaryRevision"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SalaryRevision"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryRevision"> | Date | string
  }

  export type ClassroomWhereInput = {
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    id?: StringFilter<"Classroom"> | string
    name?: StringFilter<"Classroom"> | string
    schoolId?: StringFilter<"Classroom"> | string
    teacherId?: StringNullableFilter<"Classroom"> | string | null
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    teacher?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    students?: StudentListRelationFilter
  }

  export type ClassroomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    teacher?: UserOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type ClassroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    name?: StringFilter<"Classroom"> | string
    schoolId?: StringFilter<"Classroom"> | string
    teacherId?: StringNullableFilter<"Classroom"> | string | null
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    teacher?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    students?: StudentListRelationFilter
  }, "id">

  export type ClassroomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassroomCountOrderByAggregateInput
    _max?: ClassroomMaxOrderByAggregateInput
    _min?: ClassroomMinOrderByAggregateInput
  }

  export type ClassroomScalarWhereWithAggregatesInput = {
    AND?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    OR?: ClassroomScalarWhereWithAggregatesInput[]
    NOT?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Classroom"> | string
    name?: StringWithAggregatesFilter<"Classroom"> | string
    schoolId?: StringWithAggregatesFilter<"Classroom"> | string
    teacherId?: StringNullableWithAggregatesFilter<"Classroom"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Classroom"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    avatar?: StringNullableFilter<"Student"> | string | null
    age?: IntNullableFilter<"Student"> | number | null
    gender?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    grade?: StringNullableFilter<"Student"> | string | null
    status?: StringFilter<"Student"> | string
    parentName?: StringNullableFilter<"Student"> | string | null
    parentMobile?: StringNullableFilter<"Student"> | string | null
    parentEmail?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    medicalConditions?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    emergencyContactName?: StringNullableFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Student"> | string | null
    classroomId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    classroom?: XOR<ClassroomNullableRelationFilter, ClassroomWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    attendance?: AttendanceListRelationFilter
    reports?: ReportCardListRelationFilter
    fees?: FeeListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    status?: SortOrder
    parentName?: SortOrderInput | SortOrder
    parentMobile?: SortOrderInput | SortOrder
    parentEmail?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    classroomId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classroom?: ClassroomOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    attendance?: AttendanceOrderByRelationAggregateInput
    reports?: ReportCardOrderByRelationAggregateInput
    fees?: FeeOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    avatar?: StringNullableFilter<"Student"> | string | null
    age?: IntNullableFilter<"Student"> | number | null
    gender?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    grade?: StringNullableFilter<"Student"> | string | null
    status?: StringFilter<"Student"> | string
    parentName?: StringNullableFilter<"Student"> | string | null
    parentMobile?: StringNullableFilter<"Student"> | string | null
    parentEmail?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    medicalConditions?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    emergencyContactName?: StringNullableFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Student"> | string | null
    classroomId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    classroom?: XOR<ClassroomNullableRelationFilter, ClassroomWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    attendance?: AttendanceListRelationFilter
    reports?: ReportCardListRelationFilter
    fees?: FeeListRelationFilter
  }, "id">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    status?: SortOrder
    parentName?: SortOrderInput | SortOrder
    parentMobile?: SortOrderInput | SortOrder
    parentEmail?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    classroomId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    avatar?: StringNullableWithAggregatesFilter<"Student"> | string | null
    age?: IntNullableWithAggregatesFilter<"Student"> | number | null
    gender?: StringNullableWithAggregatesFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    grade?: StringNullableWithAggregatesFilter<"Student"> | string | null
    status?: StringWithAggregatesFilter<"Student"> | string
    parentName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    parentMobile?: StringNullableWithAggregatesFilter<"Student"> | string | null
    parentEmail?: StringNullableWithAggregatesFilter<"Student"> | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"Student"> | string | null
    medicalConditions?: StringNullableWithAggregatesFilter<"Student"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"Student"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    classroomId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    schoolId?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type FeeWhereInput = {
    AND?: FeeWhereInput | FeeWhereInput[]
    OR?: FeeWhereInput[]
    NOT?: FeeWhereInput | FeeWhereInput[]
    id?: StringFilter<"Fee"> | string
    title?: StringFilter<"Fee"> | string
    amount?: FloatFilter<"Fee"> | number
    dueDate?: DateTimeFilter<"Fee"> | Date | string
    status?: StringFilter<"Fee"> | string
    studentId?: StringFilter<"Fee"> | string
    createdAt?: DateTimeFilter<"Fee"> | Date | string
    updatedAt?: DateTimeFilter<"Fee"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    payments?: FeePaymentListRelationFilter
  }

  export type FeeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    payments?: FeePaymentOrderByRelationAggregateInput
  }

  export type FeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeWhereInput | FeeWhereInput[]
    OR?: FeeWhereInput[]
    NOT?: FeeWhereInput | FeeWhereInput[]
    title?: StringFilter<"Fee"> | string
    amount?: FloatFilter<"Fee"> | number
    dueDate?: DateTimeFilter<"Fee"> | Date | string
    status?: StringFilter<"Fee"> | string
    studentId?: StringFilter<"Fee"> | string
    createdAt?: DateTimeFilter<"Fee"> | Date | string
    updatedAt?: DateTimeFilter<"Fee"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    payments?: FeePaymentListRelationFilter
  }, "id">

  export type FeeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeCountOrderByAggregateInput
    _avg?: FeeAvgOrderByAggregateInput
    _max?: FeeMaxOrderByAggregateInput
    _min?: FeeMinOrderByAggregateInput
    _sum?: FeeSumOrderByAggregateInput
  }

  export type FeeScalarWhereWithAggregatesInput = {
    AND?: FeeScalarWhereWithAggregatesInput | FeeScalarWhereWithAggregatesInput[]
    OR?: FeeScalarWhereWithAggregatesInput[]
    NOT?: FeeScalarWhereWithAggregatesInput | FeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fee"> | string
    title?: StringWithAggregatesFilter<"Fee"> | string
    amount?: FloatWithAggregatesFilter<"Fee"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Fee"> | Date | string
    status?: StringWithAggregatesFilter<"Fee"> | string
    studentId?: StringWithAggregatesFilter<"Fee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Fee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fee"> | Date | string
  }

  export type FeePaymentWhereInput = {
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    id?: StringFilter<"FeePayment"> | string
    amount?: FloatFilter<"FeePayment"> | number
    date?: DateTimeFilter<"FeePayment"> | Date | string
    method?: StringFilter<"FeePayment"> | string
    reference?: StringNullableFilter<"FeePayment"> | string | null
    feeId?: StringFilter<"FeePayment"> | string
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeFilter<"FeePayment"> | Date | string
    fee?: XOR<FeeRelationFilter, FeeWhereInput>
  }

  export type FeePaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    feeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fee?: FeeOrderByWithRelationInput
  }

  export type FeePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    amount?: FloatFilter<"FeePayment"> | number
    date?: DateTimeFilter<"FeePayment"> | Date | string
    method?: StringFilter<"FeePayment"> | string
    reference?: StringNullableFilter<"FeePayment"> | string | null
    feeId?: StringFilter<"FeePayment"> | string
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeFilter<"FeePayment"> | Date | string
    fee?: XOR<FeeRelationFilter, FeeWhereInput>
  }, "id">

  export type FeePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    feeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeePaymentCountOrderByAggregateInput
    _avg?: FeePaymentAvgOrderByAggregateInput
    _max?: FeePaymentMaxOrderByAggregateInput
    _min?: FeePaymentMinOrderByAggregateInput
    _sum?: FeePaymentSumOrderByAggregateInput
  }

  export type FeePaymentScalarWhereWithAggregatesInput = {
    AND?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    OR?: FeePaymentScalarWhereWithAggregatesInput[]
    NOT?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeePayment"> | string
    amount?: FloatWithAggregatesFilter<"FeePayment"> | number
    date?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
    method?: StringWithAggregatesFilter<"FeePayment"> | string
    reference?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    feeId?: StringWithAggregatesFilter<"FeePayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    notes?: StringNullableFilter<"Attendance"> | string | null
    studentId?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_date?: AttendanceStudentIdDateCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    notes?: StringNullableFilter<"Attendance"> | string | null
    studentId?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "studentId_date">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: StringWithAggregatesFilter<"Attendance"> | string
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    studentId?: StringWithAggregatesFilter<"Attendance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type ReportCardWhereInput = {
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    id?: StringFilter<"ReportCard"> | string
    term?: StringFilter<"ReportCard"> | string
    marks?: StringFilter<"ReportCard"> | string
    comments?: StringNullableFilter<"ReportCard"> | string | null
    published?: BoolFilter<"ReportCard"> | boolean
    studentId?: StringFilter<"ReportCard"> | string
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type ReportCardOrderByWithRelationInput = {
    id?: SortOrder
    term?: SortOrder
    marks?: SortOrder
    comments?: SortOrderInput | SortOrder
    published?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type ReportCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    term?: StringFilter<"ReportCard"> | string
    marks?: StringFilter<"ReportCard"> | string
    comments?: StringNullableFilter<"ReportCard"> | string | null
    published?: BoolFilter<"ReportCard"> | boolean
    studentId?: StringFilter<"ReportCard"> | string
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type ReportCardOrderByWithAggregationInput = {
    id?: SortOrder
    term?: SortOrder
    marks?: SortOrder
    comments?: SortOrderInput | SortOrder
    published?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCardCountOrderByAggregateInput
    _max?: ReportCardMaxOrderByAggregateInput
    _min?: ReportCardMinOrderByAggregateInput
  }

  export type ReportCardScalarWhereWithAggregatesInput = {
    AND?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    OR?: ReportCardScalarWhereWithAggregatesInput[]
    NOT?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportCard"> | string
    term?: StringWithAggregatesFilter<"ReportCard"> | string
    marks?: StringWithAggregatesFilter<"ReportCard"> | string
    comments?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    published?: BoolWithAggregatesFilter<"ReportCard"> | boolean
    studentId?: StringWithAggregatesFilter<"ReportCard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    mobile?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    verified?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    mobile?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    mobile?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    verified?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    mobile?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    mobile?: StringWithAggregatesFilter<"Otp"> | string
    code?: StringWithAggregatesFilter<"Otp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    verified?: BoolWithAggregatesFilter<"Otp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    schoolId?: StringFilter<"Subscription"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    planId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id" | "schoolId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    schoolId?: StringWithAggregatesFilter<"Subscription"> | string
  }

  export type MasterDataWhereInput = {
    AND?: MasterDataWhereInput | MasterDataWhereInput[]
    OR?: MasterDataWhereInput[]
    NOT?: MasterDataWhereInput | MasterDataWhereInput[]
    id?: StringFilter<"MasterData"> | string
    type?: StringFilter<"MasterData"> | string
    name?: StringFilter<"MasterData"> | string
    code?: StringNullableFilter<"MasterData"> | string | null
    parentId?: StringNullableFilter<"MasterData"> | string | null
    createdAt?: DateTimeFilter<"MasterData"> | Date | string
    updatedAt?: DateTimeFilter<"MasterData"> | Date | string
    parent?: XOR<MasterDataNullableRelationFilter, MasterDataWhereInput> | null
    children?: MasterDataListRelationFilter
  }

  export type MasterDataOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: MasterDataOrderByWithRelationInput
    children?: MasterDataOrderByRelationAggregateInput
  }

  export type MasterDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type_name_parentId?: MasterDataTypeNameParentIdCompoundUniqueInput
    AND?: MasterDataWhereInput | MasterDataWhereInput[]
    OR?: MasterDataWhereInput[]
    NOT?: MasterDataWhereInput | MasterDataWhereInput[]
    type?: StringFilter<"MasterData"> | string
    name?: StringFilter<"MasterData"> | string
    code?: StringNullableFilter<"MasterData"> | string | null
    parentId?: StringNullableFilter<"MasterData"> | string | null
    createdAt?: DateTimeFilter<"MasterData"> | Date | string
    updatedAt?: DateTimeFilter<"MasterData"> | Date | string
    parent?: XOR<MasterDataNullableRelationFilter, MasterDataWhereInput> | null
    children?: MasterDataListRelationFilter
  }, "id" | "type_name_parentId">

  export type MasterDataOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MasterDataCountOrderByAggregateInput
    _max?: MasterDataMaxOrderByAggregateInput
    _min?: MasterDataMinOrderByAggregateInput
  }

  export type MasterDataScalarWhereWithAggregatesInput = {
    AND?: MasterDataScalarWhereWithAggregatesInput | MasterDataScalarWhereWithAggregatesInput[]
    OR?: MasterDataScalarWhereWithAggregatesInput[]
    NOT?: MasterDataScalarWhereWithAggregatesInput | MasterDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MasterData"> | string
    type?: StringWithAggregatesFilter<"MasterData"> | string
    name?: StringWithAggregatesFilter<"MasterData"> | string
    code?: StringNullableWithAggregatesFilter<"MasterData"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"MasterData"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MasterData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MasterData"> | Date | string
  }

  export type StaffAttendanceWhereInput = {
    AND?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    OR?: StaffAttendanceWhereInput[]
    NOT?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    id?: StringFilter<"StaffAttendance"> | string
    date?: DateTimeFilter<"StaffAttendance"> | Date | string
    status?: StringFilter<"StaffAttendance"> | string
    notes?: StringNullableFilter<"StaffAttendance"> | string | null
    totalHours?: FloatNullableFilter<"StaffAttendance"> | number | null
    userId?: StringFilter<"StaffAttendance"> | string
    createdAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    punches?: StaffPunchListRelationFilter
  }

  export type StaffAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    totalHours?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    punches?: StaffPunchOrderByRelationAggregateInput
  }

  export type StaffAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: StaffAttendanceUserIdDateCompoundUniqueInput
    AND?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    OR?: StaffAttendanceWhereInput[]
    NOT?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    date?: DateTimeFilter<"StaffAttendance"> | Date | string
    status?: StringFilter<"StaffAttendance"> | string
    notes?: StringNullableFilter<"StaffAttendance"> | string | null
    totalHours?: FloatNullableFilter<"StaffAttendance"> | number | null
    userId?: StringFilter<"StaffAttendance"> | string
    createdAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    punches?: StaffPunchListRelationFilter
  }, "id" | "userId_date">

  export type StaffAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    totalHours?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffAttendanceCountOrderByAggregateInput
    _avg?: StaffAttendanceAvgOrderByAggregateInput
    _max?: StaffAttendanceMaxOrderByAggregateInput
    _min?: StaffAttendanceMinOrderByAggregateInput
    _sum?: StaffAttendanceSumOrderByAggregateInput
  }

  export type StaffAttendanceScalarWhereWithAggregatesInput = {
    AND?: StaffAttendanceScalarWhereWithAggregatesInput | StaffAttendanceScalarWhereWithAggregatesInput[]
    OR?: StaffAttendanceScalarWhereWithAggregatesInput[]
    NOT?: StaffAttendanceScalarWhereWithAggregatesInput | StaffAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"StaffAttendance"> | Date | string
    status?: StringWithAggregatesFilter<"StaffAttendance"> | string
    notes?: StringNullableWithAggregatesFilter<"StaffAttendance"> | string | null
    totalHours?: FloatNullableWithAggregatesFilter<"StaffAttendance"> | number | null
    userId?: StringWithAggregatesFilter<"StaffAttendance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaffAttendance"> | Date | string
  }

  export type StaffPunchWhereInput = {
    AND?: StaffPunchWhereInput | StaffPunchWhereInput[]
    OR?: StaffPunchWhereInput[]
    NOT?: StaffPunchWhereInput | StaffPunchWhereInput[]
    id?: StringFilter<"StaffPunch"> | string
    type?: StringFilter<"StaffPunch"> | string
    timestamp?: DateTimeFilter<"StaffPunch"> | Date | string
    attendanceId?: StringFilter<"StaffPunch"> | string
    attendance?: XOR<StaffAttendanceRelationFilter, StaffAttendanceWhereInput>
  }

  export type StaffPunchOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    attendanceId?: SortOrder
    attendance?: StaffAttendanceOrderByWithRelationInput
  }

  export type StaffPunchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StaffPunchWhereInput | StaffPunchWhereInput[]
    OR?: StaffPunchWhereInput[]
    NOT?: StaffPunchWhereInput | StaffPunchWhereInput[]
    type?: StringFilter<"StaffPunch"> | string
    timestamp?: DateTimeFilter<"StaffPunch"> | Date | string
    attendanceId?: StringFilter<"StaffPunch"> | string
    attendance?: XOR<StaffAttendanceRelationFilter, StaffAttendanceWhereInput>
  }, "id">

  export type StaffPunchOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    attendanceId?: SortOrder
    _count?: StaffPunchCountOrderByAggregateInput
    _max?: StaffPunchMaxOrderByAggregateInput
    _min?: StaffPunchMinOrderByAggregateInput
  }

  export type StaffPunchScalarWhereWithAggregatesInput = {
    AND?: StaffPunchScalarWhereWithAggregatesInput | StaffPunchScalarWhereWithAggregatesInput[]
    OR?: StaffPunchScalarWhereWithAggregatesInput[]
    NOT?: StaffPunchScalarWhereWithAggregatesInput | StaffPunchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffPunch"> | string
    type?: StringWithAggregatesFilter<"StaffPunch"> | string
    timestamp?: DateTimeWithAggregatesFilter<"StaffPunch"> | Date | string
    attendanceId?: StringWithAggregatesFilter<"StaffPunch"> | string
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    type?: StringFilter<"LeaveRequest"> | string
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: StringFilter<"LeaveRequest"> | string
    userId?: StringFilter<"LeaveRequest"> | string
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    type?: StringFilter<"LeaveRequest"> | string
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: StringFilter<"LeaveRequest"> | string
    userId?: StringFilter<"LeaveRequest"> | string
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    type?: StringWithAggregatesFilter<"LeaveRequest"> | string
    reason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    status?: StringWithAggregatesFilter<"LeaveRequest"> | string
    userId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
  }

  export type FeeStructureWhereInput = {
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    id?: StringFilter<"FeeStructure"> | string
    name?: StringFilter<"FeeStructure"> | string
    academicYear?: StringFilter<"FeeStructure"> | string
    description?: StringNullableFilter<"FeeStructure"> | string | null
    termConfig?: StringNullableFilter<"FeeStructure"> | string | null
    schoolId?: StringFilter<"FeeStructure"> | string
    createdAt?: DateTimeFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeFilter<"FeeStructure"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    components?: FeeComponentListRelationFilter
  }

  export type FeeStructureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    academicYear?: SortOrder
    description?: SortOrderInput | SortOrder
    termConfig?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    components?: FeeComponentOrderByRelationAggregateInput
  }

  export type FeeStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    name?: StringFilter<"FeeStructure"> | string
    academicYear?: StringFilter<"FeeStructure"> | string
    description?: StringNullableFilter<"FeeStructure"> | string | null
    termConfig?: StringNullableFilter<"FeeStructure"> | string | null
    schoolId?: StringFilter<"FeeStructure"> | string
    createdAt?: DateTimeFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeFilter<"FeeStructure"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    components?: FeeComponentListRelationFilter
  }, "id">

  export type FeeStructureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    academicYear?: SortOrder
    description?: SortOrderInput | SortOrder
    termConfig?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeStructureCountOrderByAggregateInput
    _max?: FeeStructureMaxOrderByAggregateInput
    _min?: FeeStructureMinOrderByAggregateInput
  }

  export type FeeStructureScalarWhereWithAggregatesInput = {
    AND?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    OR?: FeeStructureScalarWhereWithAggregatesInput[]
    NOT?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeStructure"> | string
    name?: StringWithAggregatesFilter<"FeeStructure"> | string
    academicYear?: StringWithAggregatesFilter<"FeeStructure"> | string
    description?: StringNullableWithAggregatesFilter<"FeeStructure"> | string | null
    termConfig?: StringNullableWithAggregatesFilter<"FeeStructure"> | string | null
    schoolId?: StringWithAggregatesFilter<"FeeStructure"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeStructure"> | Date | string
  }

  export type FeeComponentWhereInput = {
    AND?: FeeComponentWhereInput | FeeComponentWhereInput[]
    OR?: FeeComponentWhereInput[]
    NOT?: FeeComponentWhereInput | FeeComponentWhereInput[]
    id?: StringFilter<"FeeComponent"> | string
    name?: StringFilter<"FeeComponent"> | string
    amount?: FloatFilter<"FeeComponent"> | number
    currency?: StringFilter<"FeeComponent"> | string
    frequency?: StringFilter<"FeeComponent"> | string
    dueDate?: DateTimeNullableFilter<"FeeComponent"> | Date | string | null
    dueDay?: IntNullableFilter<"FeeComponent"> | number | null
    dueMonth?: IntNullableFilter<"FeeComponent"> | number | null
    isOptional?: BoolFilter<"FeeComponent"> | boolean
    isRefundable?: BoolFilter<"FeeComponent"> | boolean
    midTermRule?: StringFilter<"FeeComponent"> | string
    feeStructureId?: StringFilter<"FeeComponent"> | string
    createdAt?: DateTimeFilter<"FeeComponent"> | Date | string
    updatedAt?: DateTimeFilter<"FeeComponent"> | Date | string
    feeStructure?: XOR<FeeStructureRelationFilter, FeeStructureWhereInput>
  }

  export type FeeComponentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    dueDay?: SortOrderInput | SortOrder
    dueMonth?: SortOrderInput | SortOrder
    isOptional?: SortOrder
    isRefundable?: SortOrder
    midTermRule?: SortOrder
    feeStructureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feeStructure?: FeeStructureOrderByWithRelationInput
  }

  export type FeeComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeComponentWhereInput | FeeComponentWhereInput[]
    OR?: FeeComponentWhereInput[]
    NOT?: FeeComponentWhereInput | FeeComponentWhereInput[]
    name?: StringFilter<"FeeComponent"> | string
    amount?: FloatFilter<"FeeComponent"> | number
    currency?: StringFilter<"FeeComponent"> | string
    frequency?: StringFilter<"FeeComponent"> | string
    dueDate?: DateTimeNullableFilter<"FeeComponent"> | Date | string | null
    dueDay?: IntNullableFilter<"FeeComponent"> | number | null
    dueMonth?: IntNullableFilter<"FeeComponent"> | number | null
    isOptional?: BoolFilter<"FeeComponent"> | boolean
    isRefundable?: BoolFilter<"FeeComponent"> | boolean
    midTermRule?: StringFilter<"FeeComponent"> | string
    feeStructureId?: StringFilter<"FeeComponent"> | string
    createdAt?: DateTimeFilter<"FeeComponent"> | Date | string
    updatedAt?: DateTimeFilter<"FeeComponent"> | Date | string
    feeStructure?: XOR<FeeStructureRelationFilter, FeeStructureWhereInput>
  }, "id">

  export type FeeComponentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    dueDay?: SortOrderInput | SortOrder
    dueMonth?: SortOrderInput | SortOrder
    isOptional?: SortOrder
    isRefundable?: SortOrder
    midTermRule?: SortOrder
    feeStructureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeComponentCountOrderByAggregateInput
    _avg?: FeeComponentAvgOrderByAggregateInput
    _max?: FeeComponentMaxOrderByAggregateInput
    _min?: FeeComponentMinOrderByAggregateInput
    _sum?: FeeComponentSumOrderByAggregateInput
  }

  export type FeeComponentScalarWhereWithAggregatesInput = {
    AND?: FeeComponentScalarWhereWithAggregatesInput | FeeComponentScalarWhereWithAggregatesInput[]
    OR?: FeeComponentScalarWhereWithAggregatesInput[]
    NOT?: FeeComponentScalarWhereWithAggregatesInput | FeeComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeComponent"> | string
    name?: StringWithAggregatesFilter<"FeeComponent"> | string
    amount?: FloatWithAggregatesFilter<"FeeComponent"> | number
    currency?: StringWithAggregatesFilter<"FeeComponent"> | string
    frequency?: StringWithAggregatesFilter<"FeeComponent"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"FeeComponent"> | Date | string | null
    dueDay?: IntNullableWithAggregatesFilter<"FeeComponent"> | number | null
    dueMonth?: IntNullableWithAggregatesFilter<"FeeComponent"> | number | null
    isOptional?: BoolWithAggregatesFilter<"FeeComponent"> | boolean
    isRefundable?: BoolWithAggregatesFilter<"FeeComponent"> | boolean
    midTermRule?: StringWithAggregatesFilter<"FeeComponent"> | string
    feeStructureId?: StringWithAggregatesFilter<"FeeComponent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeeComponent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeComponent"> | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateInput = {
    id?: string
    studentName: string
    studentAge?: number | null
    studentGender?: string | null
    dateOfBirth?: Date | string | null
    parentName: string
    parentEmail?: string | null
    parentPhone?: string | null
    secondaryPhone?: string | null
    relationship?: string | null
    fatherName?: string | null
    fatherPhone?: string | null
    fatherEmail?: string | null
    fatherOccupation?: string | null
    motherName?: string | null
    motherPhone?: string | null
    motherEmail?: string | null
    motherOccupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zip?: string | null
    officialStatus?: string | null
    stage?: string
    priority?: string
    enrolledGrade?: string | null
    source?: string | null
    notes?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    previousSchool?: string | null
    documents?: string | null
    accessToken?: string | null
    admissionFormStep?: number
    dateReceived?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateInput = {
    id?: string
    studentName: string
    studentAge?: number | null
    studentGender?: string | null
    dateOfBirth?: Date | string | null
    parentName: string
    parentEmail?: string | null
    parentPhone?: string | null
    secondaryPhone?: string | null
    relationship?: string | null
    fatherName?: string | null
    fatherPhone?: string | null
    fatherEmail?: string | null
    fatherOccupation?: string | null
    motherName?: string | null
    motherPhone?: string | null
    motherEmail?: string | null
    motherOccupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zip?: string | null
    officialStatus?: string | null
    stage?: string
    priority?: string
    enrolledGrade?: string | null
    source?: string | null
    notes?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    previousSchool?: string | null
    documents?: string | null
    accessToken?: string | null
    admissionFormStep?: number
    dateReceived?: Date | string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentAge?: NullableIntFieldUpdateOperationsInput | number | null
    studentGender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentName?: StringFieldUpdateOperationsInput | string
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    officialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    enrolledGrade?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    admissionFormStep?: IntFieldUpdateOperationsInput | number
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentAge?: NullableIntFieldUpdateOperationsInput | number | null
    studentGender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentName?: StringFieldUpdateOperationsInput | string
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    officialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    enrolledGrade?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    admissionFormStep?: IntFieldUpdateOperationsInput | number
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentAge?: NullableIntFieldUpdateOperationsInput | number | null
    studentGender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentName?: StringFieldUpdateOperationsInput | string
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    officialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    enrolledGrade?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    admissionFormStep?: IntFieldUpdateOperationsInput | number
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentAge?: NullableIntFieldUpdateOperationsInput | number | null
    studentGender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentName?: StringFieldUpdateOperationsInput | string
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    officialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    enrolledGrade?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    admissionFormStep?: IntFieldUpdateOperationsInput | number
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    school?: SchoolCreateNestedOneWithoutUsersInput
    managedClassrooms?: ClassroomCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId?: string | null
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    managedClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceUncheckedCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    school?: SchoolUpdateOneWithoutUsersNestedInput
    managedClassrooms?: ClassroomUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    managedClassrooms?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUncheckedUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeavePolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    isDefault?: boolean
    lateComingGrace?: number
    lateComingMax?: number
    earlyLeavingGrace?: number
    earlyLeavingMax?: number
    permissionAllowed?: boolean
    permissionMaxMins?: number
    permissionMaxOccur?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutLeavePoliciesInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutPolicyInput
  }

  export type LeavePolicyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    isDefault?: boolean
    schoolId: string
    lateComingGrace?: number
    lateComingMax?: number
    earlyLeavingGrace?: number
    earlyLeavingMax?: number
    permissionAllowed?: boolean
    permissionMaxMins?: number
    permissionMaxOccur?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type LeavePolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutLeavePoliciesNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutPolicyNestedInput
  }

  export type LeavePolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type LeavePolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeCreateInput = {
    id?: string
    name: string
    code: string
    totalDays: number
    canCarryForward?: boolean
    maxCarryForward?: number
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: number
    requiresApproval?: boolean
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: LeavePolicyCreateNestedOneWithoutLeaveTypesInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    totalDays: number
    canCarryForward?: boolean
    maxCarryForward?: number
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: number
    requiresApproval?: boolean
    gender?: string | null
    policyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: LeavePolicyUpdateOneRequiredWithoutLeaveTypesNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    policyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    policyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceCreateInput = {
    id?: string
    total: number
    used?: number
    pending?: number
    remaining: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveBalancesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveBalancesInput
  }

  export type LeaveBalanceUncheckedCreateInput = {
    id?: string
    total: number
    used?: number
    pending?: number
    remaining: number
    userId: string
    leaveTypeId: string
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveBalancesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRevisionCreateInput = {
    id?: string
    amount: number
    currency?: string
    revisionDate?: Date | string
    effectiveDate: Date | string
    reason?: string | null
    type?: string
    basic?: number
    hra?: number
    allowance?: number
    tax?: number
    pf?: number
    insurance?: number
    otherDeductions?: number
    netSalary?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalaryRevisionsInput
  }

  export type SalaryRevisionUncheckedCreateInput = {
    id?: string
    amount: number
    currency?: string
    revisionDate?: Date | string
    effectiveDate: Date | string
    reason?: string | null
    type?: string
    basic?: number
    hra?: number
    allowance?: number
    tax?: number
    pf?: number
    insurance?: number
    otherDeductions?: number
    netSalary?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    revisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    basic?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    allowance?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    pf?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalaryRevisionsNestedInput
  }

  export type SalaryRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    revisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    basic?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    allowance?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    pf?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    revisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    basic?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    allowance?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    pf?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    revisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    basic?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    allowance?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    pf?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutManagedClassroomsInput
    students?: StudentCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateInput = {
    id?: string
    name: string
    schoolId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutManagedClassroomsNestedInput
    students?: StudentUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom?: ClassroomCreateNestedOneWithoutStudentsInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    reports?: ReportCardCreateNestedManyWithoutStudentInput
    fees?: FeeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    classroomId?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    reports?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    fees?: FeeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneWithoutStudentsNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUpdateManyWithoutStudentNestedInput
    fees?: FeeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    fees?: FeeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeCreateInput = {
    id?: string
    title: string
    amount: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeesInput
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type FeeUncheckedCreateInput = {
    id?: string
    title: string
    amount: number
    dueDate: Date | string
    status?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeesNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentCreateInput = {
    id?: string
    amount: number
    date?: Date | string
    method: string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fee: FeeCreateNestedOneWithoutPaymentsInput
  }

  export type FeePaymentUncheckedCreateInput = {
    id?: string
    amount: number
    date?: Date | string
    method: string
    reference?: string | null
    feeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fee?: FeeUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type FeePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    feeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    feeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    date: Date | string
    status: string
    notes?: string | null
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardCreateInput = {
    id?: string
    term: string
    marks: string
    comments?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutReportsInput
  }

  export type ReportCardUncheckedCreateInput = {
    id?: string
    term: string
    marks: string
    comments?: string | null
    published?: boolean
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    marks?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    marks?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    marks?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    marks?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    id?: string
    mobile: string
    code: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    mobile: string
    code: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type OtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    planId: string
    status?: string
    startDate?: Date | string
    endDate?: Date | string | null
    school: SchoolCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    planId: string
    status?: string
    startDate?: Date | string
    endDate?: Date | string | null
    schoolId: string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    school?: SchoolUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type MasterDataCreateInput = {
    id?: string
    type: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MasterDataCreateNestedOneWithoutChildrenInput
    children?: MasterDataCreateNestedManyWithoutParentInput
  }

  export type MasterDataUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    code?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MasterDataUncheckedCreateNestedManyWithoutParentInput
  }

  export type MasterDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MasterDataUpdateOneWithoutChildrenNestedInput
    children?: MasterDataUpdateManyWithoutParentNestedInput
  }

  export type MasterDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MasterDataUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MasterDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceCreateInput = {
    id?: string
    date: Date | string
    status?: string
    notes?: string | null
    totalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffAttendanceInput
    punches?: StaffPunchCreateNestedManyWithoutAttendanceInput
  }

  export type StaffAttendanceUncheckedCreateInput = {
    id?: string
    date: Date | string
    status?: string
    notes?: string | null
    totalHours?: number | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    punches?: StaffPunchUncheckedCreateNestedManyWithoutAttendanceInput
  }

  export type StaffAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffAttendanceNestedInput
    punches?: StaffPunchUpdateManyWithoutAttendanceNestedInput
  }

  export type StaffAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    punches?: StaffPunchUncheckedUpdateManyWithoutAttendanceNestedInput
  }

  export type StaffAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffPunchCreateInput = {
    id?: string
    type: string
    timestamp?: Date | string
    attendance: StaffAttendanceCreateNestedOneWithoutPunchesInput
  }

  export type StaffPunchUncheckedCreateInput = {
    id?: string
    type: string
    timestamp?: Date | string
    attendanceId: string
  }

  export type StaffPunchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: StaffAttendanceUpdateOneRequiredWithoutPunchesNestedInput
  }

  export type StaffPunchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceId?: StringFieldUpdateOperationsInput | string
  }

  export type StaffPunchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffPunchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceId?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveRequestCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    type: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveRequestsInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    type: string
    reason?: string | null
    status?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeStructureCreateInput = {
    id?: string
    name: string
    academicYear: string
    description?: string | null
    termConfig?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFeeStructuresInput
    components?: FeeComponentCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUncheckedCreateInput = {
    id?: string
    name: string
    academicYear: string
    description?: string | null
    termConfig?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: FeeComponentUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFeeStructuresNestedInput
    components?: FeeComponentUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: FeeComponentUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeStructureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeComponentCreateInput = {
    id?: string
    name: string
    amount: number
    currency?: string
    frequency: string
    dueDate?: Date | string | null
    dueDay?: number | null
    dueMonth?: number | null
    isOptional?: boolean
    isRefundable?: boolean
    midTermRule?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    feeStructure: FeeStructureCreateNestedOneWithoutComponentsInput
  }

  export type FeeComponentUncheckedCreateInput = {
    id?: string
    name: string
    amount: number
    currency?: string
    frequency: string
    dueDate?: Date | string | null
    dueDay?: number | null
    dueMonth?: number | null
    isOptional?: boolean
    isRefundable?: boolean
    midTermRule?: string
    feeStructureId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueMonth?: NullableIntFieldUpdateOperationsInput | number | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    isRefundable?: BoolFieldUpdateOperationsInput | boolean
    midTermRule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeStructure?: FeeStructureUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type FeeComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueMonth?: NullableIntFieldUpdateOperationsInput | number | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    isRefundable?: BoolFieldUpdateOperationsInput | boolean
    midTermRule?: StringFieldUpdateOperationsInput | string
    feeStructureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueMonth?: NullableIntFieldUpdateOperationsInput | number | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    isRefundable?: BoolFieldUpdateOperationsInput | boolean
    midTermRule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueMonth?: NullableIntFieldUpdateOperationsInput | number | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    isRefundable?: BoolFieldUpdateOperationsInput | boolean
    midTermRule?: StringFieldUpdateOperationsInput | string
    feeStructureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type ClassroomListRelationFilter = {
    every?: ClassroomWhereInput
    some?: ClassroomWhereInput
    none?: ClassroomWhereInput
  }

  export type AdmissionListRelationFilter = {
    every?: AdmissionWhereInput
    some?: AdmissionWhereInput
    none?: AdmissionWhereInput
  }

  export type LeavePolicyListRelationFilter = {
    every?: LeavePolicyWhereInput
    some?: LeavePolicyWhereInput
    none?: LeavePolicyWhereInput
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type FeeStructureListRelationFilter = {
    every?: FeeStructureWhereInput
    some?: FeeStructureWhereInput
    none?: FeeStructureWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeavePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeStructureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    motto?: SortOrder
    foundingYear?: SortOrder
    logo?: SortOrder
    brandColor?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    instagram?: SortOrder
    youtube?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    googleMapsApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    motto?: SortOrder
    foundingYear?: SortOrder
    logo?: SortOrder
    brandColor?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    instagram?: SortOrder
    youtube?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    googleMapsApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    motto?: SortOrder
    foundingYear?: SortOrder
    logo?: SortOrder
    brandColor?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    instagram?: SortOrder
    youtube?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    googleMapsApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type AdmissionCountOrderByAggregateInput = {
    id?: SortOrder
    studentName?: SortOrder
    studentAge?: SortOrder
    studentGender?: SortOrder
    dateOfBirth?: SortOrder
    parentName?: SortOrder
    parentEmail?: SortOrder
    parentPhone?: SortOrder
    secondaryPhone?: SortOrder
    relationship?: SortOrder
    fatherName?: SortOrder
    fatherPhone?: SortOrder
    fatherEmail?: SortOrder
    fatherOccupation?: SortOrder
    motherName?: SortOrder
    motherPhone?: SortOrder
    motherEmail?: SortOrder
    motherOccupation?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zip?: SortOrder
    officialStatus?: SortOrder
    stage?: SortOrder
    priority?: SortOrder
    enrolledGrade?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    bloodGroup?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    previousSchool?: SortOrder
    documents?: SortOrder
    accessToken?: SortOrder
    admissionFormStep?: SortOrder
    dateReceived?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionAvgOrderByAggregateInput = {
    studentAge?: SortOrder
    admissionFormStep?: SortOrder
  }

  export type AdmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentName?: SortOrder
    studentAge?: SortOrder
    studentGender?: SortOrder
    dateOfBirth?: SortOrder
    parentName?: SortOrder
    parentEmail?: SortOrder
    parentPhone?: SortOrder
    secondaryPhone?: SortOrder
    relationship?: SortOrder
    fatherName?: SortOrder
    fatherPhone?: SortOrder
    fatherEmail?: SortOrder
    fatherOccupation?: SortOrder
    motherName?: SortOrder
    motherPhone?: SortOrder
    motherEmail?: SortOrder
    motherOccupation?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zip?: SortOrder
    officialStatus?: SortOrder
    stage?: SortOrder
    priority?: SortOrder
    enrolledGrade?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    bloodGroup?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    previousSchool?: SortOrder
    documents?: SortOrder
    accessToken?: SortOrder
    admissionFormStep?: SortOrder
    dateReceived?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionMinOrderByAggregateInput = {
    id?: SortOrder
    studentName?: SortOrder
    studentAge?: SortOrder
    studentGender?: SortOrder
    dateOfBirth?: SortOrder
    parentName?: SortOrder
    parentEmail?: SortOrder
    parentPhone?: SortOrder
    secondaryPhone?: SortOrder
    relationship?: SortOrder
    fatherName?: SortOrder
    fatherPhone?: SortOrder
    fatherEmail?: SortOrder
    fatherOccupation?: SortOrder
    motherName?: SortOrder
    motherPhone?: SortOrder
    motherEmail?: SortOrder
    motherOccupation?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zip?: SortOrder
    officialStatus?: SortOrder
    stage?: SortOrder
    priority?: SortOrder
    enrolledGrade?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    bloodGroup?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    previousSchool?: SortOrder
    documents?: SortOrder
    accessToken?: SortOrder
    admissionFormStep?: SortOrder
    dateReceived?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionSumOrderByAggregateInput = {
    studentAge?: SortOrder
    admissionFormStep?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type SchoolNullableRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type StaffAttendanceListRelationFilter = {
    every?: StaffAttendanceWhereInput
    some?: StaffAttendanceWhereInput
    none?: StaffAttendanceWhereInput
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type SalaryRevisionListRelationFilter = {
    every?: SalaryRevisionWhereInput
    some?: SalaryRevisionWhereInput
    none?: SalaryRevisionWhereInput
  }

  export type LeaveBalanceListRelationFilter = {
    every?: LeaveBalanceWhereInput
    some?: LeaveBalanceWhereInput
    none?: LeaveBalanceWhereInput
  }

  export type StaffAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    joiningDate?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    documents?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    bloodGroup?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelation?: SortOrder
    addressCity?: SortOrder
    addressState?: SortOrder
    addressZip?: SortOrder
    addressCountry?: SortOrder
    qualifications?: SortOrder
    experience?: SortOrder
    employmentType?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    facebook?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    instagram?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    joiningDate?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    documents?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    bloodGroup?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelation?: SortOrder
    addressCity?: SortOrder
    addressState?: SortOrder
    addressZip?: SortOrder
    addressCountry?: SortOrder
    qualifications?: SortOrder
    experience?: SortOrder
    employmentType?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    facebook?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    instagram?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    joiningDate?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    documents?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    bloodGroup?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelation?: SortOrder
    addressCity?: SortOrder
    addressState?: SortOrder
    addressZip?: SortOrder
    addressCountry?: SortOrder
    qualifications?: SortOrder
    experience?: SortOrder
    employmentType?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    facebook?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    instagram?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LeaveTypeListRelationFilter = {
    every?: LeaveTypeWhereInput
    some?: LeaveTypeWhereInput
    none?: LeaveTypeWhereInput
  }

  export type LeaveTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeavePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    isDefault?: SortOrder
    schoolId?: SortOrder
    lateComingGrace?: SortOrder
    lateComingMax?: SortOrder
    earlyLeavingGrace?: SortOrder
    earlyLeavingMax?: SortOrder
    permissionAllowed?: SortOrder
    permissionMaxMins?: SortOrder
    permissionMaxOccur?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeavePolicyAvgOrderByAggregateInput = {
    lateComingGrace?: SortOrder
    lateComingMax?: SortOrder
    earlyLeavingGrace?: SortOrder
    earlyLeavingMax?: SortOrder
    permissionMaxMins?: SortOrder
    permissionMaxOccur?: SortOrder
  }

  export type LeavePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    isDefault?: SortOrder
    schoolId?: SortOrder
    lateComingGrace?: SortOrder
    lateComingMax?: SortOrder
    earlyLeavingGrace?: SortOrder
    earlyLeavingMax?: SortOrder
    permissionAllowed?: SortOrder
    permissionMaxMins?: SortOrder
    permissionMaxOccur?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeavePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    isDefault?: SortOrder
    schoolId?: SortOrder
    lateComingGrace?: SortOrder
    lateComingMax?: SortOrder
    earlyLeavingGrace?: SortOrder
    earlyLeavingMax?: SortOrder
    permissionAllowed?: SortOrder
    permissionMaxMins?: SortOrder
    permissionMaxOccur?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeavePolicySumOrderByAggregateInput = {
    lateComingGrace?: SortOrder
    lateComingMax?: SortOrder
    earlyLeavingGrace?: SortOrder
    earlyLeavingMax?: SortOrder
    permissionMaxMins?: SortOrder
    permissionMaxOccur?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LeavePolicyRelationFilter = {
    is?: LeavePolicyWhereInput
    isNot?: LeavePolicyWhereInput
  }

  export type LeaveTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    totalDays?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForward?: SortOrder
    isPaid?: SortOrder
    allowHalfDay?: SortOrder
    minNoticePeriod?: SortOrder
    requiresApproval?: SortOrder
    gender?: SortOrder
    policyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeAvgOrderByAggregateInput = {
    totalDays?: SortOrder
    maxCarryForward?: SortOrder
    minNoticePeriod?: SortOrder
  }

  export type LeaveTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    totalDays?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForward?: SortOrder
    isPaid?: SortOrder
    allowHalfDay?: SortOrder
    minNoticePeriod?: SortOrder
    requiresApproval?: SortOrder
    gender?: SortOrder
    policyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    totalDays?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForward?: SortOrder
    isPaid?: SortOrder
    allowHalfDay?: SortOrder
    minNoticePeriod?: SortOrder
    requiresApproval?: SortOrder
    gender?: SortOrder
    policyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeSumOrderByAggregateInput = {
    totalDays?: SortOrder
    maxCarryForward?: SortOrder
    minNoticePeriod?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LeaveTypeRelationFilter = {
    is?: LeaveTypeWhereInput
    isNot?: LeaveTypeWhereInput
  }

  export type LeaveBalanceUserIdLeaveTypeIdYearCompoundUniqueInput = {
    userId: string
    leaveTypeId: string
    year: number
  }

  export type LeaveBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    userId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveBalanceAvgOrderByAggregateInput = {
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    year?: SortOrder
  }

  export type LeaveBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    userId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    userId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveBalanceSumOrderByAggregateInput = {
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    year?: SortOrder
  }

  export type SalaryRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    revisionDate?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    basic?: SortOrder
    hra?: SortOrder
    allowance?: SortOrder
    tax?: SortOrder
    pf?: SortOrder
    insurance?: SortOrder
    otherDeductions?: SortOrder
    netSalary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryRevisionAvgOrderByAggregateInput = {
    amount?: SortOrder
    basic?: SortOrder
    hra?: SortOrder
    allowance?: SortOrder
    tax?: SortOrder
    pf?: SortOrder
    insurance?: SortOrder
    otherDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type SalaryRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    revisionDate?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    basic?: SortOrder
    hra?: SortOrder
    allowance?: SortOrder
    tax?: SortOrder
    pf?: SortOrder
    insurance?: SortOrder
    otherDeductions?: SortOrder
    netSalary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    revisionDate?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    basic?: SortOrder
    hra?: SortOrder
    allowance?: SortOrder
    tax?: SortOrder
    pf?: SortOrder
    insurance?: SortOrder
    otherDeductions?: SortOrder
    netSalary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryRevisionSumOrderByAggregateInput = {
    amount?: SortOrder
    basic?: SortOrder
    hra?: SortOrder
    allowance?: SortOrder
    tax?: SortOrder
    pf?: SortOrder
    insurance?: SortOrder
    otherDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClassroomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomNullableRelationFilter = {
    is?: ClassroomWhereInput | null
    isNot?: ClassroomWhereInput | null
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type ReportCardListRelationFilter = {
    every?: ReportCardWhereInput
    some?: ReportCardWhereInput
    none?: ReportCardWhereInput
  }

  export type FeeListRelationFilter = {
    every?: FeeWhereInput
    some?: FeeWhereInput
    none?: FeeWhereInput
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    grade?: SortOrder
    status?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    parentEmail?: SortOrder
    bloodGroup?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    classroomId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    grade?: SortOrder
    status?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    parentEmail?: SortOrder
    bloodGroup?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    classroomId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    grade?: SortOrder
    status?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    parentEmail?: SortOrder
    bloodGroup?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    classroomId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type FeePaymentListRelationFilter = {
    every?: FeePaymentWhereInput
    some?: FeePaymentWhereInput
    none?: FeePaymentWhereInput
  }

  export type FeePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeeRelationFilter = {
    is?: FeeWhereInput
    isNot?: FeeWhereInput
  }

  export type FeePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    feeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    feeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    feeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AttendanceStudentIdDateCompoundUniqueInput = {
    studentId: string
    date: Date | string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardCountOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    marks?: SortOrder
    comments?: SortOrder
    published?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardMaxOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    marks?: SortOrder
    comments?: SortOrder
    published?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardMinOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    marks?: SortOrder
    comments?: SortOrder
    published?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    schoolId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    schoolId?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    schoolId?: SortOrder
  }

  export type MasterDataNullableRelationFilter = {
    is?: MasterDataWhereInput | null
    isNot?: MasterDataWhereInput | null
  }

  export type MasterDataListRelationFilter = {
    every?: MasterDataWhereInput
    some?: MasterDataWhereInput
    none?: MasterDataWhereInput
  }

  export type MasterDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterDataTypeNameParentIdCompoundUniqueInput = {
    type: string
    name: string
    parentId: string
  }

  export type MasterDataCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MasterDataMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MasterDataMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StaffPunchListRelationFilter = {
    every?: StaffPunchWhereInput
    some?: StaffPunchWhereInput
    none?: StaffPunchWhereInput
  }

  export type StaffPunchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffAttendanceUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type StaffAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    totalHours?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAttendanceAvgOrderByAggregateInput = {
    totalHours?: SortOrder
  }

  export type StaffAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    totalHours?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    totalHours?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAttendanceSumOrderByAggregateInput = {
    totalHours?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StaffAttendanceRelationFilter = {
    is?: StaffAttendanceWhereInput
    isNot?: StaffAttendanceWhereInput
  }

  export type StaffPunchCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    attendanceId?: SortOrder
  }

  export type StaffPunchMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    attendanceId?: SortOrder
  }

  export type StaffPunchMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    attendanceId?: SortOrder
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeComponentListRelationFilter = {
    every?: FeeComponentWhereInput
    some?: FeeComponentWhereInput
    none?: FeeComponentWhereInput
  }

  export type FeeComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeStructureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    academicYear?: SortOrder
    description?: SortOrder
    termConfig?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    academicYear?: SortOrder
    description?: SortOrder
    termConfig?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeStructureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    academicYear?: SortOrder
    description?: SortOrder
    termConfig?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeStructureRelationFilter = {
    is?: FeeStructureWhereInput
    isNot?: FeeStructureWhereInput
  }

  export type FeeComponentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrder
    dueDay?: SortOrder
    dueMonth?: SortOrder
    isOptional?: SortOrder
    isRefundable?: SortOrder
    midTermRule?: SortOrder
    feeStructureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeComponentAvgOrderByAggregateInput = {
    amount?: SortOrder
    dueDay?: SortOrder
    dueMonth?: SortOrder
  }

  export type FeeComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrder
    dueDay?: SortOrder
    dueMonth?: SortOrder
    isOptional?: SortOrder
    isRefundable?: SortOrder
    midTermRule?: SortOrder
    feeStructureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeComponentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrder
    dueDay?: SortOrder
    dueMonth?: SortOrder
    isOptional?: SortOrder
    isRefundable?: SortOrder
    midTermRule?: SortOrder
    feeStructureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeComponentSumOrderByAggregateInput = {
    amount?: SortOrder
    dueDay?: SortOrder
    dueMonth?: SortOrder
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassroomCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassroomCreateWithoutSchoolInput, ClassroomUncheckedCreateWithoutSchoolInput> | ClassroomCreateWithoutSchoolInput[] | ClassroomUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutSchoolInput | ClassroomCreateOrConnectWithoutSchoolInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AdmissionCreateWithoutSchoolInput, AdmissionUncheckedCreateWithoutSchoolInput> | AdmissionCreateWithoutSchoolInput[] | AdmissionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutSchoolInput | AdmissionCreateOrConnectWithoutSchoolInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type LeavePolicyCreateNestedManyWithoutSchoolInput = {
    create?: XOR<LeavePolicyCreateWithoutSchoolInput, LeavePolicyUncheckedCreateWithoutSchoolInput> | LeavePolicyCreateWithoutSchoolInput[] | LeavePolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutSchoolInput | LeavePolicyCreateOrConnectWithoutSchoolInput[]
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SubscriptionCreateWithoutSchoolInput, SubscriptionUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSchoolInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type FeeStructureCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassroomCreateWithoutSchoolInput, ClassroomUncheckedCreateWithoutSchoolInput> | ClassroomCreateWithoutSchoolInput[] | ClassroomUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutSchoolInput | ClassroomCreateOrConnectWithoutSchoolInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AdmissionCreateWithoutSchoolInput, AdmissionUncheckedCreateWithoutSchoolInput> | AdmissionCreateWithoutSchoolInput[] | AdmissionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutSchoolInput | AdmissionCreateOrConnectWithoutSchoolInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<LeavePolicyCreateWithoutSchoolInput, LeavePolicyUncheckedCreateWithoutSchoolInput> | LeavePolicyCreateWithoutSchoolInput[] | LeavePolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutSchoolInput | LeavePolicyCreateOrConnectWithoutSchoolInput[]
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SubscriptionCreateWithoutSchoolInput, SubscriptionUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSchoolInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type FeeStructureUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassroomUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassroomCreateWithoutSchoolInput, ClassroomUncheckedCreateWithoutSchoolInput> | ClassroomCreateWithoutSchoolInput[] | ClassroomUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutSchoolInput | ClassroomCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutSchoolInput | ClassroomUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutSchoolInput | ClassroomUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutSchoolInput | ClassroomUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AdmissionCreateWithoutSchoolInput, AdmissionUncheckedCreateWithoutSchoolInput> | AdmissionCreateWithoutSchoolInput[] | AdmissionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutSchoolInput | AdmissionCreateOrConnectWithoutSchoolInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutSchoolInput | AdmissionUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutSchoolInput | AdmissionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutSchoolInput | AdmissionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type LeavePolicyUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<LeavePolicyCreateWithoutSchoolInput, LeavePolicyUncheckedCreateWithoutSchoolInput> | LeavePolicyCreateWithoutSchoolInput[] | LeavePolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutSchoolInput | LeavePolicyCreateOrConnectWithoutSchoolInput[]
    upsert?: LeavePolicyUpsertWithWhereUniqueWithoutSchoolInput | LeavePolicyUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    disconnect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    delete?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    update?: LeavePolicyUpdateWithWhereUniqueWithoutSchoolInput | LeavePolicyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: LeavePolicyUpdateManyWithWhereWithoutSchoolInput | LeavePolicyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSchoolInput, SubscriptionUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSchoolInput
    upsert?: SubscriptionUpsertWithoutSchoolInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutSchoolInput, SubscriptionUpdateWithoutSchoolInput>, SubscriptionUncheckedUpdateWithoutSchoolInput>
  }

  export type FeeStructureUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutSchoolInput | FeeStructureUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutSchoolInput | FeeStructureUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutSchoolInput | FeeStructureUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassroomCreateWithoutSchoolInput, ClassroomUncheckedCreateWithoutSchoolInput> | ClassroomCreateWithoutSchoolInput[] | ClassroomUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutSchoolInput | ClassroomCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutSchoolInput | ClassroomUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutSchoolInput | ClassroomUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutSchoolInput | ClassroomUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AdmissionCreateWithoutSchoolInput, AdmissionUncheckedCreateWithoutSchoolInput> | AdmissionCreateWithoutSchoolInput[] | AdmissionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutSchoolInput | AdmissionCreateOrConnectWithoutSchoolInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutSchoolInput | AdmissionUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutSchoolInput | AdmissionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutSchoolInput | AdmissionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<LeavePolicyCreateWithoutSchoolInput, LeavePolicyUncheckedCreateWithoutSchoolInput> | LeavePolicyCreateWithoutSchoolInput[] | LeavePolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutSchoolInput | LeavePolicyCreateOrConnectWithoutSchoolInput[]
    upsert?: LeavePolicyUpsertWithWhereUniqueWithoutSchoolInput | LeavePolicyUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    disconnect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    delete?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    update?: LeavePolicyUpdateWithWhereUniqueWithoutSchoolInput | LeavePolicyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: LeavePolicyUpdateManyWithWhereWithoutSchoolInput | LeavePolicyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSchoolInput, SubscriptionUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSchoolInput
    upsert?: SubscriptionUpsertWithoutSchoolInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutSchoolInput, SubscriptionUpdateWithoutSchoolInput>, SubscriptionUncheckedUpdateWithoutSchoolInput>
  }

  export type FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutSchoolInput | FeeStructureUpsertWithWhereUniqueWithoutSchoolInput[]
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutSchoolInput | FeeStructureUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutSchoolInput | FeeStructureUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<SchoolCreateWithoutAdmissionsInput, SchoolUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdmissionsInput
    connect?: SchoolWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SchoolUpdateOneRequiredWithoutAdmissionsNestedInput = {
    create?: XOR<SchoolCreateWithoutAdmissionsInput, SchoolUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdmissionsInput
    upsert?: SchoolUpsertWithoutAdmissionsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAdmissionsInput, SchoolUpdateWithoutAdmissionsInput>, SchoolUncheckedUpdateWithoutAdmissionsInput>
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassroomCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type StaffAttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffAttendanceCreateWithoutUserInput, StaffAttendanceUncheckedCreateWithoutUserInput> | StaffAttendanceCreateWithoutUserInput[] | StaffAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutUserInput | StaffAttendanceCreateOrConnectWithoutUserInput[]
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type SalaryRevisionCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryRevisionCreateWithoutUserInput, SalaryRevisionUncheckedCreateWithoutUserInput> | SalaryRevisionCreateWithoutUserInput[] | SalaryRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRevisionCreateOrConnectWithoutUserInput | SalaryRevisionCreateOrConnectWithoutUserInput[]
    connect?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
  }

  export type LeaveBalanceCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type StaffAttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffAttendanceCreateWithoutUserInput, StaffAttendanceUncheckedCreateWithoutUserInput> | StaffAttendanceCreateWithoutUserInput[] | StaffAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutUserInput | StaffAttendanceCreateOrConnectWithoutUserInput[]
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type SalaryRevisionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryRevisionCreateWithoutUserInput, SalaryRevisionUncheckedCreateWithoutUserInput> | SalaryRevisionCreateWithoutUserInput[] | SalaryRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRevisionCreateOrConnectWithoutUserInput | SalaryRevisionCreateOrConnectWithoutUserInput[]
    connect?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
  }

  export type LeaveBalanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type SchoolUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type ClassroomUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutTeacherInput | ClassroomUpsertWithWhereUniqueWithoutTeacherInput[]
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutTeacherInput | ClassroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutTeacherInput | ClassroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type StaffAttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffAttendanceCreateWithoutUserInput, StaffAttendanceUncheckedCreateWithoutUserInput> | StaffAttendanceCreateWithoutUserInput[] | StaffAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutUserInput | StaffAttendanceCreateOrConnectWithoutUserInput[]
    upsert?: StaffAttendanceUpsertWithWhereUniqueWithoutUserInput | StaffAttendanceUpsertWithWhereUniqueWithoutUserInput[]
    set?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    disconnect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    delete?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    update?: StaffAttendanceUpdateWithWhereUniqueWithoutUserInput | StaffAttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffAttendanceUpdateManyWithWhereWithoutUserInput | StaffAttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutUserInput | LeaveRequestUpsertWithWhereUniqueWithoutUserInput[]
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutUserInput | LeaveRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutUserInput | LeaveRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type SalaryRevisionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryRevisionCreateWithoutUserInput, SalaryRevisionUncheckedCreateWithoutUserInput> | SalaryRevisionCreateWithoutUserInput[] | SalaryRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRevisionCreateOrConnectWithoutUserInput | SalaryRevisionCreateOrConnectWithoutUserInput[]
    upsert?: SalaryRevisionUpsertWithWhereUniqueWithoutUserInput | SalaryRevisionUpsertWithWhereUniqueWithoutUserInput[]
    set?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    disconnect?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    delete?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    connect?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    update?: SalaryRevisionUpdateWithWhereUniqueWithoutUserInput | SalaryRevisionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryRevisionUpdateManyWithWhereWithoutUserInput | SalaryRevisionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryRevisionScalarWhereInput | SalaryRevisionScalarWhereInput[]
  }

  export type LeaveBalanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutUserInput | LeaveBalanceUpsertWithWhereUniqueWithoutUserInput[]
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutUserInput | LeaveBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutUserInput | LeaveBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutTeacherInput | ClassroomUpsertWithWhereUniqueWithoutTeacherInput[]
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutTeacherInput | ClassroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutTeacherInput | ClassroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type StaffAttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffAttendanceCreateWithoutUserInput, StaffAttendanceUncheckedCreateWithoutUserInput> | StaffAttendanceCreateWithoutUserInput[] | StaffAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutUserInput | StaffAttendanceCreateOrConnectWithoutUserInput[]
    upsert?: StaffAttendanceUpsertWithWhereUniqueWithoutUserInput | StaffAttendanceUpsertWithWhereUniqueWithoutUserInput[]
    set?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    disconnect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    delete?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    update?: StaffAttendanceUpdateWithWhereUniqueWithoutUserInput | StaffAttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffAttendanceUpdateManyWithWhereWithoutUserInput | StaffAttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutUserInput | LeaveRequestUpsertWithWhereUniqueWithoutUserInput[]
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutUserInput | LeaveRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutUserInput | LeaveRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type SalaryRevisionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryRevisionCreateWithoutUserInput, SalaryRevisionUncheckedCreateWithoutUserInput> | SalaryRevisionCreateWithoutUserInput[] | SalaryRevisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRevisionCreateOrConnectWithoutUserInput | SalaryRevisionCreateOrConnectWithoutUserInput[]
    upsert?: SalaryRevisionUpsertWithWhereUniqueWithoutUserInput | SalaryRevisionUpsertWithWhereUniqueWithoutUserInput[]
    set?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    disconnect?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    delete?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    connect?: SalaryRevisionWhereUniqueInput | SalaryRevisionWhereUniqueInput[]
    update?: SalaryRevisionUpdateWithWhereUniqueWithoutUserInput | SalaryRevisionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryRevisionUpdateManyWithWhereWithoutUserInput | SalaryRevisionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryRevisionScalarWhereInput | SalaryRevisionScalarWhereInput[]
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutUserInput | LeaveBalanceUpsertWithWhereUniqueWithoutUserInput[]
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutUserInput | LeaveBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutUserInput | LeaveBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutLeavePoliciesInput = {
    create?: XOR<SchoolCreateWithoutLeavePoliciesInput, SchoolUncheckedCreateWithoutLeavePoliciesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutLeavePoliciesInput
    connect?: SchoolWhereUniqueInput
  }

  export type LeaveTypeCreateNestedManyWithoutPolicyInput = {
    create?: XOR<LeaveTypeCreateWithoutPolicyInput, LeaveTypeUncheckedCreateWithoutPolicyInput> | LeaveTypeCreateWithoutPolicyInput[] | LeaveTypeUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutPolicyInput | LeaveTypeCreateOrConnectWithoutPolicyInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
  }

  export type LeaveTypeUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<LeaveTypeCreateWithoutPolicyInput, LeaveTypeUncheckedCreateWithoutPolicyInput> | LeaveTypeCreateWithoutPolicyInput[] | LeaveTypeUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutPolicyInput | LeaveTypeCreateOrConnectWithoutPolicyInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SchoolUpdateOneRequiredWithoutLeavePoliciesNestedInput = {
    create?: XOR<SchoolCreateWithoutLeavePoliciesInput, SchoolUncheckedCreateWithoutLeavePoliciesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutLeavePoliciesInput
    upsert?: SchoolUpsertWithoutLeavePoliciesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutLeavePoliciesInput, SchoolUpdateWithoutLeavePoliciesInput>, SchoolUncheckedUpdateWithoutLeavePoliciesInput>
  }

  export type LeaveTypeUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutPolicyInput, LeaveTypeUncheckedCreateWithoutPolicyInput> | LeaveTypeCreateWithoutPolicyInput[] | LeaveTypeUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutPolicyInput | LeaveTypeCreateOrConnectWithoutPolicyInput[]
    upsert?: LeaveTypeUpsertWithWhereUniqueWithoutPolicyInput | LeaveTypeUpsertWithWhereUniqueWithoutPolicyInput[]
    set?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    disconnect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    delete?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    update?: LeaveTypeUpdateWithWhereUniqueWithoutPolicyInput | LeaveTypeUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: LeaveTypeUpdateManyWithWhereWithoutPolicyInput | LeaveTypeUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
  }

  export type LeaveTypeUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutPolicyInput, LeaveTypeUncheckedCreateWithoutPolicyInput> | LeaveTypeCreateWithoutPolicyInput[] | LeaveTypeUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutPolicyInput | LeaveTypeCreateOrConnectWithoutPolicyInput[]
    upsert?: LeaveTypeUpsertWithWhereUniqueWithoutPolicyInput | LeaveTypeUpsertWithWhereUniqueWithoutPolicyInput[]
    set?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    disconnect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    delete?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    update?: LeaveTypeUpdateWithWhereUniqueWithoutPolicyInput | LeaveTypeUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: LeaveTypeUpdateManyWithWhereWithoutPolicyInput | LeaveTypeUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
  }

  export type LeavePolicyCreateNestedOneWithoutLeaveTypesInput = {
    create?: XOR<LeavePolicyCreateWithoutLeaveTypesInput, LeavePolicyUncheckedCreateWithoutLeaveTypesInput>
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutLeaveTypesInput
    connect?: LeavePolicyWhereUniqueInput
  }

  export type LeaveBalanceCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveBalanceUncheckedCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LeavePolicyUpdateOneRequiredWithoutLeaveTypesNestedInput = {
    create?: XOR<LeavePolicyCreateWithoutLeaveTypesInput, LeavePolicyUncheckedCreateWithoutLeaveTypesInput>
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutLeaveTypesInput
    upsert?: LeavePolicyUpsertWithoutLeaveTypesInput
    connect?: LeavePolicyWhereUniqueInput
    update?: XOR<XOR<LeavePolicyUpdateToOneWithWhereWithoutLeaveTypesInput, LeavePolicyUpdateWithoutLeaveTypesInput>, LeavePolicyUncheckedUpdateWithoutLeaveTypesInput>
  }

  export type LeaveBalanceUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput | LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput | LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLeaveBalancesInput = {
    create?: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveBalancesInput
    connect?: UserWhereUniqueInput
  }

  export type LeaveTypeCreateNestedOneWithoutLeaveBalancesInput = {
    create?: XOR<LeaveTypeCreateWithoutLeaveBalancesInput, LeaveTypeUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeaveBalancesInput
    connect?: LeaveTypeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaveBalancesNestedInput = {
    create?: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveBalancesInput
    upsert?: UserUpsertWithoutLeaveBalancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveBalancesInput, UserUpdateWithoutLeaveBalancesInput>, UserUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type LeaveTypeUpdateOneRequiredWithoutLeaveBalancesNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutLeaveBalancesInput, LeaveTypeUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeaveBalancesInput
    upsert?: LeaveTypeUpsertWithoutLeaveBalancesInput
    connect?: LeaveTypeWhereUniqueInput
    update?: XOR<XOR<LeaveTypeUpdateToOneWithWhereWithoutLeaveBalancesInput, LeaveTypeUpdateWithoutLeaveBalancesInput>, LeaveTypeUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type UserCreateNestedOneWithoutSalaryRevisionsInput = {
    create?: XOR<UserCreateWithoutSalaryRevisionsInput, UserUncheckedCreateWithoutSalaryRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalaryRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutSalaryRevisionsInput, UserUncheckedCreateWithoutSalaryRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryRevisionsInput
    upsert?: UserUpsertWithoutSalaryRevisionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryRevisionsInput, UserUpdateWithoutSalaryRevisionsInput>, UserUncheckedUpdateWithoutSalaryRevisionsInput>
  }

  export type SchoolCreateNestedOneWithoutClassroomsInput = {
    create?: XOR<SchoolCreateWithoutClassroomsInput, SchoolUncheckedCreateWithoutClassroomsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassroomsInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedClassroomsInput = {
    create?: XOR<UserCreateWithoutManagedClassroomsInput, UserUncheckedCreateWithoutManagedClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedClassroomsInput
    connect?: UserWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutClassroomInput = {
    create?: XOR<StudentCreateWithoutClassroomInput, StudentUncheckedCreateWithoutClassroomInput> | StudentCreateWithoutClassroomInput[] | StudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassroomInput | StudentCreateOrConnectWithoutClassroomInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<StudentCreateWithoutClassroomInput, StudentUncheckedCreateWithoutClassroomInput> | StudentCreateWithoutClassroomInput[] | StudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassroomInput | StudentCreateOrConnectWithoutClassroomInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutClassroomsNestedInput = {
    create?: XOR<SchoolCreateWithoutClassroomsInput, SchoolUncheckedCreateWithoutClassroomsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassroomsInput
    upsert?: SchoolUpsertWithoutClassroomsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassroomsInput, SchoolUpdateWithoutClassroomsInput>, SchoolUncheckedUpdateWithoutClassroomsInput>
  }

  export type UserUpdateOneWithoutManagedClassroomsNestedInput = {
    create?: XOR<UserCreateWithoutManagedClassroomsInput, UserUncheckedCreateWithoutManagedClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedClassroomsInput
    upsert?: UserUpsertWithoutManagedClassroomsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedClassroomsInput, UserUpdateWithoutManagedClassroomsInput>, UserUncheckedUpdateWithoutManagedClassroomsInput>
  }

  export type StudentUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<StudentCreateWithoutClassroomInput, StudentUncheckedCreateWithoutClassroomInput> | StudentCreateWithoutClassroomInput[] | StudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassroomInput | StudentCreateOrConnectWithoutClassroomInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassroomInput | StudentUpsertWithWhereUniqueWithoutClassroomInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassroomInput | StudentUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassroomInput | StudentUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<StudentCreateWithoutClassroomInput, StudentUncheckedCreateWithoutClassroomInput> | StudentCreateWithoutClassroomInput[] | StudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassroomInput | StudentCreateOrConnectWithoutClassroomInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassroomInput | StudentUpsertWithWhereUniqueWithoutClassroomInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassroomInput | StudentUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassroomInput | StudentUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassroomCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutStudentsInput
    connect?: ClassroomWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type ReportCardCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type FeeCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type ReportCardUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type FeeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type ClassroomUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutStudentsInput
    upsert?: ClassroomUpsertWithoutStudentsInput
    disconnect?: ClassroomWhereInput | boolean
    delete?: ClassroomWhereInput | boolean
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutStudentsInput, ClassroomUpdateWithoutStudentsInput>, ClassroomUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    upsert?: SchoolUpsertWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStudentsInput, SchoolUpdateWithoutStudentsInput>, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type AttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type ReportCardUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type FeeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutStudentInput | FeeUpsertWithWhereUniqueWithoutStudentInput[]
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutStudentInput | FeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutStudentInput | FeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type FeeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutStudentInput | FeeUpsertWithWhereUniqueWithoutStudentInput[]
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutStudentInput | FeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutStudentInput | FeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutFeesInput = {
    create?: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeesInput
    connect?: StudentWhereUniqueInput
  }

  export type FeePaymentCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type FeePaymentUncheckedCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeesInput
    upsert?: StudentUpsertWithoutFeesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFeesInput, StudentUpdateWithoutFeesInput>, StudentUncheckedUpdateWithoutFeesInput>
  }

  export type FeePaymentUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeInput | FeePaymentUpsertWithWhereUniqueWithoutFeeInput[]
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeInput | FeePaymentUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeInput | FeePaymentUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeInput | FeePaymentUpsertWithWhereUniqueWithoutFeeInput[]
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeInput | FeePaymentUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeInput | FeePaymentUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type FeeCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeCreateOrConnectWithoutPaymentsInput
    connect?: FeeWhereUniqueInput
  }

  export type FeeUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeCreateOrConnectWithoutPaymentsInput
    upsert?: FeeUpsertWithoutPaymentsInput
    connect?: FeeWhereUniqueInput
    update?: XOR<XOR<FeeUpdateToOneWithWhereWithoutPaymentsInput, FeeUpdateWithoutPaymentsInput>, FeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    upsert?: StudentUpsertWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceInput, StudentUpdateWithoutAttendanceInput>, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type StudentCreateNestedOneWithoutReportsInput = {
    create?: XOR<StudentCreateWithoutReportsInput, StudentUncheckedCreateWithoutReportsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<StudentCreateWithoutReportsInput, StudentUncheckedCreateWithoutReportsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportsInput
    upsert?: StudentUpsertWithoutReportsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutReportsInput, StudentUpdateWithoutReportsInput>, StudentUncheckedUpdateWithoutReportsInput>
  }

  export type SchoolCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<SchoolCreateWithoutSubscriptionInput, SchoolUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubscriptionInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<SchoolCreateWithoutSubscriptionInput, SchoolUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubscriptionInput
    upsert?: SchoolUpsertWithoutSubscriptionInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSubscriptionInput, SchoolUpdateWithoutSubscriptionInput>, SchoolUncheckedUpdateWithoutSubscriptionInput>
  }

  export type MasterDataCreateNestedOneWithoutChildrenInput = {
    create?: XOR<MasterDataCreateWithoutChildrenInput, MasterDataUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MasterDataCreateOrConnectWithoutChildrenInput
    connect?: MasterDataWhereUniqueInput
  }

  export type MasterDataCreateNestedManyWithoutParentInput = {
    create?: XOR<MasterDataCreateWithoutParentInput, MasterDataUncheckedCreateWithoutParentInput> | MasterDataCreateWithoutParentInput[] | MasterDataUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MasterDataCreateOrConnectWithoutParentInput | MasterDataCreateOrConnectWithoutParentInput[]
    connect?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
  }

  export type MasterDataUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MasterDataCreateWithoutParentInput, MasterDataUncheckedCreateWithoutParentInput> | MasterDataCreateWithoutParentInput[] | MasterDataUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MasterDataCreateOrConnectWithoutParentInput | MasterDataCreateOrConnectWithoutParentInput[]
    connect?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
  }

  export type MasterDataUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<MasterDataCreateWithoutChildrenInput, MasterDataUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MasterDataCreateOrConnectWithoutChildrenInput
    upsert?: MasterDataUpsertWithoutChildrenInput
    disconnect?: MasterDataWhereInput | boolean
    delete?: MasterDataWhereInput | boolean
    connect?: MasterDataWhereUniqueInput
    update?: XOR<XOR<MasterDataUpdateToOneWithWhereWithoutChildrenInput, MasterDataUpdateWithoutChildrenInput>, MasterDataUncheckedUpdateWithoutChildrenInput>
  }

  export type MasterDataUpdateManyWithoutParentNestedInput = {
    create?: XOR<MasterDataCreateWithoutParentInput, MasterDataUncheckedCreateWithoutParentInput> | MasterDataCreateWithoutParentInput[] | MasterDataUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MasterDataCreateOrConnectWithoutParentInput | MasterDataCreateOrConnectWithoutParentInput[]
    upsert?: MasterDataUpsertWithWhereUniqueWithoutParentInput | MasterDataUpsertWithWhereUniqueWithoutParentInput[]
    set?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    disconnect?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    delete?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    connect?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    update?: MasterDataUpdateWithWhereUniqueWithoutParentInput | MasterDataUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MasterDataUpdateManyWithWhereWithoutParentInput | MasterDataUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MasterDataScalarWhereInput | MasterDataScalarWhereInput[]
  }

  export type MasterDataUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MasterDataCreateWithoutParentInput, MasterDataUncheckedCreateWithoutParentInput> | MasterDataCreateWithoutParentInput[] | MasterDataUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MasterDataCreateOrConnectWithoutParentInput | MasterDataCreateOrConnectWithoutParentInput[]
    upsert?: MasterDataUpsertWithWhereUniqueWithoutParentInput | MasterDataUpsertWithWhereUniqueWithoutParentInput[]
    set?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    disconnect?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    delete?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    connect?: MasterDataWhereUniqueInput | MasterDataWhereUniqueInput[]
    update?: MasterDataUpdateWithWhereUniqueWithoutParentInput | MasterDataUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MasterDataUpdateManyWithWhereWithoutParentInput | MasterDataUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MasterDataScalarWhereInput | MasterDataScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStaffAttendanceInput = {
    create?: XOR<UserCreateWithoutStaffAttendanceInput, UserUncheckedCreateWithoutStaffAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type StaffPunchCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<StaffPunchCreateWithoutAttendanceInput, StaffPunchUncheckedCreateWithoutAttendanceInput> | StaffPunchCreateWithoutAttendanceInput[] | StaffPunchUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: StaffPunchCreateOrConnectWithoutAttendanceInput | StaffPunchCreateOrConnectWithoutAttendanceInput[]
    connect?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
  }

  export type StaffPunchUncheckedCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<StaffPunchCreateWithoutAttendanceInput, StaffPunchUncheckedCreateWithoutAttendanceInput> | StaffPunchCreateWithoutAttendanceInput[] | StaffPunchUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: StaffPunchCreateOrConnectWithoutAttendanceInput | StaffPunchCreateOrConnectWithoutAttendanceInput[]
    connect?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutStaffAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutStaffAttendanceInput, UserUncheckedCreateWithoutStaffAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffAttendanceInput
    upsert?: UserUpsertWithoutStaffAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffAttendanceInput, UserUpdateWithoutStaffAttendanceInput>, UserUncheckedUpdateWithoutStaffAttendanceInput>
  }

  export type StaffPunchUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<StaffPunchCreateWithoutAttendanceInput, StaffPunchUncheckedCreateWithoutAttendanceInput> | StaffPunchCreateWithoutAttendanceInput[] | StaffPunchUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: StaffPunchCreateOrConnectWithoutAttendanceInput | StaffPunchCreateOrConnectWithoutAttendanceInput[]
    upsert?: StaffPunchUpsertWithWhereUniqueWithoutAttendanceInput | StaffPunchUpsertWithWhereUniqueWithoutAttendanceInput[]
    set?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    disconnect?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    delete?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    connect?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    update?: StaffPunchUpdateWithWhereUniqueWithoutAttendanceInput | StaffPunchUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: StaffPunchUpdateManyWithWhereWithoutAttendanceInput | StaffPunchUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: StaffPunchScalarWhereInput | StaffPunchScalarWhereInput[]
  }

  export type StaffPunchUncheckedUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<StaffPunchCreateWithoutAttendanceInput, StaffPunchUncheckedCreateWithoutAttendanceInput> | StaffPunchCreateWithoutAttendanceInput[] | StaffPunchUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: StaffPunchCreateOrConnectWithoutAttendanceInput | StaffPunchCreateOrConnectWithoutAttendanceInput[]
    upsert?: StaffPunchUpsertWithWhereUniqueWithoutAttendanceInput | StaffPunchUpsertWithWhereUniqueWithoutAttendanceInput[]
    set?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    disconnect?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    delete?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    connect?: StaffPunchWhereUniqueInput | StaffPunchWhereUniqueInput[]
    update?: StaffPunchUpdateWithWhereUniqueWithoutAttendanceInput | StaffPunchUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: StaffPunchUpdateManyWithWhereWithoutAttendanceInput | StaffPunchUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: StaffPunchScalarWhereInput | StaffPunchScalarWhereInput[]
  }

  export type StaffAttendanceCreateNestedOneWithoutPunchesInput = {
    create?: XOR<StaffAttendanceCreateWithoutPunchesInput, StaffAttendanceUncheckedCreateWithoutPunchesInput>
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutPunchesInput
    connect?: StaffAttendanceWhereUniqueInput
  }

  export type StaffAttendanceUpdateOneRequiredWithoutPunchesNestedInput = {
    create?: XOR<StaffAttendanceCreateWithoutPunchesInput, StaffAttendanceUncheckedCreateWithoutPunchesInput>
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutPunchesInput
    upsert?: StaffAttendanceUpsertWithoutPunchesInput
    connect?: StaffAttendanceWhereUniqueInput
    update?: XOR<XOR<StaffAttendanceUpdateToOneWithWhereWithoutPunchesInput, StaffAttendanceUpdateWithoutPunchesInput>, StaffAttendanceUncheckedUpdateWithoutPunchesInput>
  }

  export type UserCreateNestedOneWithoutLeaveRequestsInput = {
    create?: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaveRequestsNestedInput = {
    create?: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestsInput
    upsert?: UserUpsertWithoutLeaveRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveRequestsInput, UserUpdateWithoutLeaveRequestsInput>, UserUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type SchoolCreateNestedOneWithoutFeeStructuresInput = {
    create?: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFeeStructuresInput
    connect?: SchoolWhereUniqueInput
  }

  export type FeeComponentCreateNestedManyWithoutFeeStructureInput = {
    create?: XOR<FeeComponentCreateWithoutFeeStructureInput, FeeComponentUncheckedCreateWithoutFeeStructureInput> | FeeComponentCreateWithoutFeeStructureInput[] | FeeComponentUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: FeeComponentCreateOrConnectWithoutFeeStructureInput | FeeComponentCreateOrConnectWithoutFeeStructureInput[]
    connect?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
  }

  export type FeeComponentUncheckedCreateNestedManyWithoutFeeStructureInput = {
    create?: XOR<FeeComponentCreateWithoutFeeStructureInput, FeeComponentUncheckedCreateWithoutFeeStructureInput> | FeeComponentCreateWithoutFeeStructureInput[] | FeeComponentUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: FeeComponentCreateOrConnectWithoutFeeStructureInput | FeeComponentCreateOrConnectWithoutFeeStructureInput[]
    connect?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutFeeStructuresNestedInput = {
    create?: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFeeStructuresInput
    upsert?: SchoolUpsertWithoutFeeStructuresInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFeeStructuresInput, SchoolUpdateWithoutFeeStructuresInput>, SchoolUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type FeeComponentUpdateManyWithoutFeeStructureNestedInput = {
    create?: XOR<FeeComponentCreateWithoutFeeStructureInput, FeeComponentUncheckedCreateWithoutFeeStructureInput> | FeeComponentCreateWithoutFeeStructureInput[] | FeeComponentUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: FeeComponentCreateOrConnectWithoutFeeStructureInput | FeeComponentCreateOrConnectWithoutFeeStructureInput[]
    upsert?: FeeComponentUpsertWithWhereUniqueWithoutFeeStructureInput | FeeComponentUpsertWithWhereUniqueWithoutFeeStructureInput[]
    set?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    disconnect?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    delete?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    connect?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    update?: FeeComponentUpdateWithWhereUniqueWithoutFeeStructureInput | FeeComponentUpdateWithWhereUniqueWithoutFeeStructureInput[]
    updateMany?: FeeComponentUpdateManyWithWhereWithoutFeeStructureInput | FeeComponentUpdateManyWithWhereWithoutFeeStructureInput[]
    deleteMany?: FeeComponentScalarWhereInput | FeeComponentScalarWhereInput[]
  }

  export type FeeComponentUncheckedUpdateManyWithoutFeeStructureNestedInput = {
    create?: XOR<FeeComponentCreateWithoutFeeStructureInput, FeeComponentUncheckedCreateWithoutFeeStructureInput> | FeeComponentCreateWithoutFeeStructureInput[] | FeeComponentUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: FeeComponentCreateOrConnectWithoutFeeStructureInput | FeeComponentCreateOrConnectWithoutFeeStructureInput[]
    upsert?: FeeComponentUpsertWithWhereUniqueWithoutFeeStructureInput | FeeComponentUpsertWithWhereUniqueWithoutFeeStructureInput[]
    set?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    disconnect?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    delete?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    connect?: FeeComponentWhereUniqueInput | FeeComponentWhereUniqueInput[]
    update?: FeeComponentUpdateWithWhereUniqueWithoutFeeStructureInput | FeeComponentUpdateWithWhereUniqueWithoutFeeStructureInput[]
    updateMany?: FeeComponentUpdateManyWithWhereWithoutFeeStructureInput | FeeComponentUpdateManyWithWhereWithoutFeeStructureInput[]
    deleteMany?: FeeComponentScalarWhereInput | FeeComponentScalarWhereInput[]
  }

  export type FeeStructureCreateNestedOneWithoutComponentsInput = {
    create?: XOR<FeeStructureCreateWithoutComponentsInput, FeeStructureUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutComponentsInput
    connect?: FeeStructureWhereUniqueInput
  }

  export type FeeStructureUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<FeeStructureCreateWithoutComponentsInput, FeeStructureUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutComponentsInput
    upsert?: FeeStructureUpsertWithoutComponentsInput
    connect?: FeeStructureWhereUniqueInput
    update?: XOR<XOR<FeeStructureUpdateToOneWithWhereWithoutComponentsInput, FeeStructureUpdateWithoutComponentsInput>, FeeStructureUncheckedUpdateWithoutComponentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    managedClassrooms?: ClassroomCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    managedClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceUncheckedCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type StudentCreateWithoutSchoolInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom?: ClassroomCreateNestedOneWithoutStudentsInput
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    reports?: ReportCardCreateNestedManyWithoutStudentInput
    fees?: FeeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSchoolInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    reports?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    fees?: FeeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type ClassroomCreateWithoutSchoolInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: UserCreateNestedOneWithoutManagedClassroomsInput
    students?: StudentCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutSchoolInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutSchoolInput, ClassroomUncheckedCreateWithoutSchoolInput>
  }

  export type AdmissionCreateWithoutSchoolInput = {
    id?: string
    studentName: string
    studentAge?: number | null
    studentGender?: string | null
    dateOfBirth?: Date | string | null
    parentName: string
    parentEmail?: string | null
    parentPhone?: string | null
    secondaryPhone?: string | null
    relationship?: string | null
    fatherName?: string | null
    fatherPhone?: string | null
    fatherEmail?: string | null
    fatherOccupation?: string | null
    motherName?: string | null
    motherPhone?: string | null
    motherEmail?: string | null
    motherOccupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zip?: string | null
    officialStatus?: string | null
    stage?: string
    priority?: string
    enrolledGrade?: string | null
    source?: string | null
    notes?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    previousSchool?: string | null
    documents?: string | null
    accessToken?: string | null
    admissionFormStep?: number
    dateReceived?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUncheckedCreateWithoutSchoolInput = {
    id?: string
    studentName: string
    studentAge?: number | null
    studentGender?: string | null
    dateOfBirth?: Date | string | null
    parentName: string
    parentEmail?: string | null
    parentPhone?: string | null
    secondaryPhone?: string | null
    relationship?: string | null
    fatherName?: string | null
    fatherPhone?: string | null
    fatherEmail?: string | null
    fatherOccupation?: string | null
    motherName?: string | null
    motherPhone?: string | null
    motherEmail?: string | null
    motherOccupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zip?: string | null
    officialStatus?: string | null
    stage?: string
    priority?: string
    enrolledGrade?: string | null
    source?: string | null
    notes?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    previousSchool?: string | null
    documents?: string | null
    accessToken?: string | null
    admissionFormStep?: number
    dateReceived?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutSchoolInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutSchoolInput, AdmissionUncheckedCreateWithoutSchoolInput>
  }

  export type LeavePolicyCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    isDefault?: boolean
    lateComingGrace?: number
    lateComingMax?: number
    earlyLeavingGrace?: number
    earlyLeavingMax?: number
    permissionAllowed?: boolean
    permissionMaxMins?: number
    permissionMaxOccur?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveTypes?: LeaveTypeCreateNestedManyWithoutPolicyInput
  }

  export type LeavePolicyUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    isDefault?: boolean
    lateComingGrace?: number
    lateComingMax?: number
    earlyLeavingGrace?: number
    earlyLeavingMax?: number
    permissionAllowed?: boolean
    permissionMaxMins?: number
    permissionMaxOccur?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type LeavePolicyCreateOrConnectWithoutSchoolInput = {
    where: LeavePolicyWhereUniqueInput
    create: XOR<LeavePolicyCreateWithoutSchoolInput, LeavePolicyUncheckedCreateWithoutSchoolInput>
  }

  export type SubscriptionCreateWithoutSchoolInput = {
    id?: string
    planId: string
    status?: string
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type SubscriptionUncheckedCreateWithoutSchoolInput = {
    id?: string
    planId: string
    status?: string
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type SubscriptionCreateOrConnectWithoutSchoolInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutSchoolInput, SubscriptionUncheckedCreateWithoutSchoolInput>
  }

  export type FeeStructureCreateWithoutSchoolInput = {
    id?: string
    name: string
    academicYear: string
    description?: string | null
    termConfig?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: FeeComponentCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    academicYear: string
    description?: string | null
    termConfig?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: FeeComponentUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureCreateOrConnectWithoutSchoolInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    mobile?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    joiningDate?: DateTimeNullableFilter<"User"> | Date | string | null
    status?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    schoolId?: StringNullableFilter<"User"> | string | null
    documents?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    bloodGroup?: StringNullableFilter<"User"> | string | null
    emergencyContactName?: StringNullableFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableFilter<"User"> | string | null
    emergencyContactRelation?: StringNullableFilter<"User"> | string | null
    addressCity?: StringNullableFilter<"User"> | string | null
    addressState?: StringNullableFilter<"User"> | string | null
    addressZip?: StringNullableFilter<"User"> | string | null
    addressCountry?: StringNullableFilter<"User"> | string | null
    qualifications?: StringNullableFilter<"User"> | string | null
    experience?: StringNullableFilter<"User"> | string | null
    employmentType?: StringNullableFilter<"User"> | string | null
    bankName?: StringNullableFilter<"User"> | string | null
    bankAccountNo?: StringNullableFilter<"User"> | string | null
    bankIfsc?: StringNullableFilter<"User"> | string | null
    facebook?: StringNullableFilter<"User"> | string | null
    linkedin?: StringNullableFilter<"User"> | string | null
    twitter?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
  }

  export type StudentUpsertWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
  }

  export type StudentUpdateManyWithWhereWithoutSchoolInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    avatar?: StringNullableFilter<"Student"> | string | null
    age?: IntNullableFilter<"Student"> | number | null
    gender?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    grade?: StringNullableFilter<"Student"> | string | null
    status?: StringFilter<"Student"> | string
    parentName?: StringNullableFilter<"Student"> | string | null
    parentMobile?: StringNullableFilter<"Student"> | string | null
    parentEmail?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    medicalConditions?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    emergencyContactName?: StringNullableFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Student"> | string | null
    classroomId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type ClassroomUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutSchoolInput, ClassroomUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassroomCreateWithoutSchoolInput, ClassroomUncheckedCreateWithoutSchoolInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutSchoolInput, ClassroomUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassroomScalarWhereInput = {
    AND?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    OR?: ClassroomScalarWhereInput[]
    NOT?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    id?: StringFilter<"Classroom"> | string
    name?: StringFilter<"Classroom"> | string
    schoolId?: StringFilter<"Classroom"> | string
    teacherId?: StringNullableFilter<"Classroom"> | string | null
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
  }

  export type AdmissionUpsertWithWhereUniqueWithoutSchoolInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutSchoolInput, AdmissionUncheckedUpdateWithoutSchoolInput>
    create: XOR<AdmissionCreateWithoutSchoolInput, AdmissionUncheckedCreateWithoutSchoolInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutSchoolInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutSchoolInput, AdmissionUncheckedUpdateWithoutSchoolInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutSchoolInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AdmissionScalarWhereInput = {
    AND?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    OR?: AdmissionScalarWhereInput[]
    NOT?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    id?: StringFilter<"Admission"> | string
    studentName?: StringFilter<"Admission"> | string
    studentAge?: IntNullableFilter<"Admission"> | number | null
    studentGender?: StringNullableFilter<"Admission"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Admission"> | Date | string | null
    parentName?: StringFilter<"Admission"> | string
    parentEmail?: StringNullableFilter<"Admission"> | string | null
    parentPhone?: StringNullableFilter<"Admission"> | string | null
    secondaryPhone?: StringNullableFilter<"Admission"> | string | null
    relationship?: StringNullableFilter<"Admission"> | string | null
    fatherName?: StringNullableFilter<"Admission"> | string | null
    fatherPhone?: StringNullableFilter<"Admission"> | string | null
    fatherEmail?: StringNullableFilter<"Admission"> | string | null
    fatherOccupation?: StringNullableFilter<"Admission"> | string | null
    motherName?: StringNullableFilter<"Admission"> | string | null
    motherPhone?: StringNullableFilter<"Admission"> | string | null
    motherEmail?: StringNullableFilter<"Admission"> | string | null
    motherOccupation?: StringNullableFilter<"Admission"> | string | null
    address?: StringNullableFilter<"Admission"> | string | null
    city?: StringNullableFilter<"Admission"> | string | null
    state?: StringNullableFilter<"Admission"> | string | null
    country?: StringNullableFilter<"Admission"> | string | null
    zip?: StringNullableFilter<"Admission"> | string | null
    officialStatus?: StringNullableFilter<"Admission"> | string | null
    stage?: StringFilter<"Admission"> | string
    priority?: StringFilter<"Admission"> | string
    enrolledGrade?: StringNullableFilter<"Admission"> | string | null
    source?: StringNullableFilter<"Admission"> | string | null
    notes?: StringNullableFilter<"Admission"> | string | null
    bloodGroup?: StringNullableFilter<"Admission"> | string | null
    medicalConditions?: StringNullableFilter<"Admission"> | string | null
    allergies?: StringNullableFilter<"Admission"> | string | null
    emergencyContactName?: StringNullableFilter<"Admission"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Admission"> | string | null
    previousSchool?: StringNullableFilter<"Admission"> | string | null
    documents?: StringNullableFilter<"Admission"> | string | null
    accessToken?: StringNullableFilter<"Admission"> | string | null
    admissionFormStep?: IntFilter<"Admission"> | number
    dateReceived?: DateTimeFilter<"Admission"> | Date | string
    schoolId?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
  }

  export type LeavePolicyUpsertWithWhereUniqueWithoutSchoolInput = {
    where: LeavePolicyWhereUniqueInput
    update: XOR<LeavePolicyUpdateWithoutSchoolInput, LeavePolicyUncheckedUpdateWithoutSchoolInput>
    create: XOR<LeavePolicyCreateWithoutSchoolInput, LeavePolicyUncheckedCreateWithoutSchoolInput>
  }

  export type LeavePolicyUpdateWithWhereUniqueWithoutSchoolInput = {
    where: LeavePolicyWhereUniqueInput
    data: XOR<LeavePolicyUpdateWithoutSchoolInput, LeavePolicyUncheckedUpdateWithoutSchoolInput>
  }

  export type LeavePolicyUpdateManyWithWhereWithoutSchoolInput = {
    where: LeavePolicyScalarWhereInput
    data: XOR<LeavePolicyUpdateManyMutationInput, LeavePolicyUncheckedUpdateManyWithoutSchoolInput>
  }

  export type LeavePolicyScalarWhereInput = {
    AND?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
    OR?: LeavePolicyScalarWhereInput[]
    NOT?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
    id?: StringFilter<"LeavePolicy"> | string
    name?: StringFilter<"LeavePolicy"> | string
    description?: StringNullableFilter<"LeavePolicy"> | string | null
    effectiveFrom?: DateTimeFilter<"LeavePolicy"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"LeavePolicy"> | Date | string | null
    isDefault?: BoolFilter<"LeavePolicy"> | boolean
    schoolId?: StringFilter<"LeavePolicy"> | string
    lateComingGrace?: IntFilter<"LeavePolicy"> | number
    lateComingMax?: IntFilter<"LeavePolicy"> | number
    earlyLeavingGrace?: IntFilter<"LeavePolicy"> | number
    earlyLeavingMax?: IntFilter<"LeavePolicy"> | number
    permissionAllowed?: BoolFilter<"LeavePolicy"> | boolean
    permissionMaxMins?: IntFilter<"LeavePolicy"> | number
    permissionMaxOccur?: IntFilter<"LeavePolicy"> | number
    createdAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"LeavePolicy"> | Date | string
  }

  export type SubscriptionUpsertWithoutSchoolInput = {
    update: XOR<SubscriptionUpdateWithoutSchoolInput, SubscriptionUncheckedUpdateWithoutSchoolInput>
    create: XOR<SubscriptionCreateWithoutSchoolInput, SubscriptionUncheckedCreateWithoutSchoolInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutSchoolInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutSchoolInput, SubscriptionUncheckedUpdateWithoutSchoolInput>
  }

  export type SubscriptionUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeeStructureUpsertWithWhereUniqueWithoutSchoolInput = {
    where: FeeStructureWhereUniqueInput
    update: XOR<FeeStructureUpdateWithoutSchoolInput, FeeStructureUncheckedUpdateWithoutSchoolInput>
    create: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput>
  }

  export type FeeStructureUpdateWithWhereUniqueWithoutSchoolInput = {
    where: FeeStructureWhereUniqueInput
    data: XOR<FeeStructureUpdateWithoutSchoolInput, FeeStructureUncheckedUpdateWithoutSchoolInput>
  }

  export type FeeStructureUpdateManyWithWhereWithoutSchoolInput = {
    where: FeeStructureScalarWhereInput
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyWithoutSchoolInput>
  }

  export type FeeStructureScalarWhereInput = {
    AND?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
    OR?: FeeStructureScalarWhereInput[]
    NOT?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
    id?: StringFilter<"FeeStructure"> | string
    name?: StringFilter<"FeeStructure"> | string
    academicYear?: StringFilter<"FeeStructure"> | string
    description?: StringNullableFilter<"FeeStructure"> | string | null
    termConfig?: StringNullableFilter<"FeeStructure"> | string | null
    schoolId?: StringFilter<"FeeStructure"> | string
    createdAt?: DateTimeFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeFilter<"FeeStructure"> | Date | string
  }

  export type SchoolCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAdmissionsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAdmissionsInput, SchoolUncheckedCreateWithoutAdmissionsInput>
  }

  export type SchoolUpsertWithoutAdmissionsInput = {
    update: XOR<SchoolUpdateWithoutAdmissionsInput, SchoolUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<SchoolCreateWithoutAdmissionsInput, SchoolUncheckedCreateWithoutAdmissionsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAdmissionsInput, SchoolUncheckedUpdateWithoutAdmissionsInput>
  }

  export type SchoolUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type ClassroomCreateWithoutTeacherInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassroomsInput
    students?: StudentCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutTeacherInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutTeacherInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput>
  }

  export type StaffAttendanceCreateWithoutUserInput = {
    id?: string
    date: Date | string
    status?: string
    notes?: string | null
    totalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    punches?: StaffPunchCreateNestedManyWithoutAttendanceInput
  }

  export type StaffAttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    status?: string
    notes?: string | null
    totalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    punches?: StaffPunchUncheckedCreateNestedManyWithoutAttendanceInput
  }

  export type StaffAttendanceCreateOrConnectWithoutUserInput = {
    where: StaffAttendanceWhereUniqueInput
    create: XOR<StaffAttendanceCreateWithoutUserInput, StaffAttendanceUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    type: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUncheckedCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    type: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateOrConnectWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput>
  }

  export type SalaryRevisionCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    revisionDate?: Date | string
    effectiveDate: Date | string
    reason?: string | null
    type?: string
    basic?: number
    hra?: number
    allowance?: number
    tax?: number
    pf?: number
    insurance?: number
    otherDeductions?: number
    netSalary?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryRevisionUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    revisionDate?: Date | string
    effectiveDate: Date | string
    reason?: string | null
    type?: string
    basic?: number
    hra?: number
    allowance?: number
    tax?: number
    pf?: number
    insurance?: number
    otherDeductions?: number
    netSalary?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryRevisionCreateOrConnectWithoutUserInput = {
    where: SalaryRevisionWhereUniqueInput
    create: XOR<SalaryRevisionCreateWithoutUserInput, SalaryRevisionUncheckedCreateWithoutUserInput>
  }

  export type LeaveBalanceCreateWithoutUserInput = {
    id?: string
    total: number
    used?: number
    pending?: number
    remaining: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveBalancesInput
  }

  export type LeaveBalanceUncheckedCreateWithoutUserInput = {
    id?: string
    total: number
    used?: number
    pending?: number
    remaining: number
    leaveTypeId: string
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceCreateOrConnectWithoutUserInput = {
    where: LeaveBalanceWhereUniqueInput
    create: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput>
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassroomUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutTeacherInput, ClassroomUncheckedUpdateWithoutTeacherInput>
    create: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutTeacherInput, ClassroomUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutTeacherInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutTeacherInput>
  }

  export type StaffAttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: StaffAttendanceWhereUniqueInput
    update: XOR<StaffAttendanceUpdateWithoutUserInput, StaffAttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<StaffAttendanceCreateWithoutUserInput, StaffAttendanceUncheckedCreateWithoutUserInput>
  }

  export type StaffAttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: StaffAttendanceWhereUniqueInput
    data: XOR<StaffAttendanceUpdateWithoutUserInput, StaffAttendanceUncheckedUpdateWithoutUserInput>
  }

  export type StaffAttendanceUpdateManyWithWhereWithoutUserInput = {
    where: StaffAttendanceScalarWhereInput
    data: XOR<StaffAttendanceUpdateManyMutationInput, StaffAttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type StaffAttendanceScalarWhereInput = {
    AND?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
    OR?: StaffAttendanceScalarWhereInput[]
    NOT?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
    id?: StringFilter<"StaffAttendance"> | string
    date?: DateTimeFilter<"StaffAttendance"> | Date | string
    status?: StringFilter<"StaffAttendance"> | string
    notes?: StringNullableFilter<"StaffAttendance"> | string | null
    totalHours?: FloatNullableFilter<"StaffAttendance"> | number | null
    userId?: StringFilter<"StaffAttendance"> | string
    createdAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StaffAttendance"> | Date | string
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutUserInput, LeaveRequestUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutUserInput, LeaveRequestUncheckedUpdateWithoutUserInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutUserInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    type?: StringFilter<"LeaveRequest"> | string
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: StringFilter<"LeaveRequest"> | string
    userId?: StringFilter<"LeaveRequest"> | string
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }

  export type SalaryRevisionUpsertWithWhereUniqueWithoutUserInput = {
    where: SalaryRevisionWhereUniqueInput
    update: XOR<SalaryRevisionUpdateWithoutUserInput, SalaryRevisionUncheckedUpdateWithoutUserInput>
    create: XOR<SalaryRevisionCreateWithoutUserInput, SalaryRevisionUncheckedCreateWithoutUserInput>
  }

  export type SalaryRevisionUpdateWithWhereUniqueWithoutUserInput = {
    where: SalaryRevisionWhereUniqueInput
    data: XOR<SalaryRevisionUpdateWithoutUserInput, SalaryRevisionUncheckedUpdateWithoutUserInput>
  }

  export type SalaryRevisionUpdateManyWithWhereWithoutUserInput = {
    where: SalaryRevisionScalarWhereInput
    data: XOR<SalaryRevisionUpdateManyMutationInput, SalaryRevisionUncheckedUpdateManyWithoutUserInput>
  }

  export type SalaryRevisionScalarWhereInput = {
    AND?: SalaryRevisionScalarWhereInput | SalaryRevisionScalarWhereInput[]
    OR?: SalaryRevisionScalarWhereInput[]
    NOT?: SalaryRevisionScalarWhereInput | SalaryRevisionScalarWhereInput[]
    id?: StringFilter<"SalaryRevision"> | string
    amount?: FloatFilter<"SalaryRevision"> | number
    currency?: StringFilter<"SalaryRevision"> | string
    revisionDate?: DateTimeFilter<"SalaryRevision"> | Date | string
    effectiveDate?: DateTimeFilter<"SalaryRevision"> | Date | string
    reason?: StringNullableFilter<"SalaryRevision"> | string | null
    type?: StringFilter<"SalaryRevision"> | string
    basic?: FloatFilter<"SalaryRevision"> | number
    hra?: FloatFilter<"SalaryRevision"> | number
    allowance?: FloatFilter<"SalaryRevision"> | number
    tax?: FloatFilter<"SalaryRevision"> | number
    pf?: FloatFilter<"SalaryRevision"> | number
    insurance?: FloatFilter<"SalaryRevision"> | number
    otherDeductions?: FloatFilter<"SalaryRevision"> | number
    netSalary?: FloatFilter<"SalaryRevision"> | number
    userId?: StringFilter<"SalaryRevision"> | string
    createdAt?: DateTimeFilter<"SalaryRevision"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryRevision"> | Date | string
  }

  export type LeaveBalanceUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveBalanceWhereUniqueInput
    update: XOR<LeaveBalanceUpdateWithoutUserInput, LeaveBalanceUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput>
  }

  export type LeaveBalanceUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveBalanceWhereUniqueInput
    data: XOR<LeaveBalanceUpdateWithoutUserInput, LeaveBalanceUncheckedUpdateWithoutUserInput>
  }

  export type LeaveBalanceUpdateManyWithWhereWithoutUserInput = {
    where: LeaveBalanceScalarWhereInput
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveBalanceScalarWhereInput = {
    AND?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    OR?: LeaveBalanceScalarWhereInput[]
    NOT?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    total?: FloatFilter<"LeaveBalance"> | number
    used?: FloatFilter<"LeaveBalance"> | number
    pending?: FloatFilter<"LeaveBalance"> | number
    remaining?: FloatFilter<"LeaveBalance"> | number
    userId?: StringFilter<"LeaveBalance"> | string
    leaveTypeId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    createdAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveBalance"> | Date | string
  }

  export type SchoolCreateWithoutLeavePoliciesInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutLeavePoliciesInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutLeavePoliciesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutLeavePoliciesInput, SchoolUncheckedCreateWithoutLeavePoliciesInput>
  }

  export type LeaveTypeCreateWithoutPolicyInput = {
    id?: string
    name: string
    code: string
    totalDays: number
    canCarryForward?: boolean
    maxCarryForward?: number
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: number
    requiresApproval?: boolean
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateWithoutPolicyInput = {
    id?: string
    name: string
    code: string
    totalDays: number
    canCarryForward?: boolean
    maxCarryForward?: number
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: number
    requiresApproval?: boolean
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeCreateOrConnectWithoutPolicyInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutPolicyInput, LeaveTypeUncheckedCreateWithoutPolicyInput>
  }

  export type SchoolUpsertWithoutLeavePoliciesInput = {
    update: XOR<SchoolUpdateWithoutLeavePoliciesInput, SchoolUncheckedUpdateWithoutLeavePoliciesInput>
    create: XOR<SchoolCreateWithoutLeavePoliciesInput, SchoolUncheckedCreateWithoutLeavePoliciesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutLeavePoliciesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutLeavePoliciesInput, SchoolUncheckedUpdateWithoutLeavePoliciesInput>
  }

  export type SchoolUpdateWithoutLeavePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutLeavePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type LeaveTypeUpsertWithWhereUniqueWithoutPolicyInput = {
    where: LeaveTypeWhereUniqueInput
    update: XOR<LeaveTypeUpdateWithoutPolicyInput, LeaveTypeUncheckedUpdateWithoutPolicyInput>
    create: XOR<LeaveTypeCreateWithoutPolicyInput, LeaveTypeUncheckedCreateWithoutPolicyInput>
  }

  export type LeaveTypeUpdateWithWhereUniqueWithoutPolicyInput = {
    where: LeaveTypeWhereUniqueInput
    data: XOR<LeaveTypeUpdateWithoutPolicyInput, LeaveTypeUncheckedUpdateWithoutPolicyInput>
  }

  export type LeaveTypeUpdateManyWithWhereWithoutPolicyInput = {
    where: LeaveTypeScalarWhereInput
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyWithoutPolicyInput>
  }

  export type LeaveTypeScalarWhereInput = {
    AND?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
    OR?: LeaveTypeScalarWhereInput[]
    NOT?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
    id?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    totalDays?: FloatFilter<"LeaveType"> | number
    canCarryForward?: BoolFilter<"LeaveType"> | boolean
    maxCarryForward?: FloatFilter<"LeaveType"> | number
    isPaid?: BoolFilter<"LeaveType"> | boolean
    allowHalfDay?: BoolFilter<"LeaveType"> | boolean
    minNoticePeriod?: IntFilter<"LeaveType"> | number
    requiresApproval?: BoolFilter<"LeaveType"> | boolean
    gender?: StringNullableFilter<"LeaveType"> | string | null
    policyId?: StringFilter<"LeaveType"> | string
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
  }

  export type LeavePolicyCreateWithoutLeaveTypesInput = {
    id?: string
    name: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    isDefault?: boolean
    lateComingGrace?: number
    lateComingMax?: number
    earlyLeavingGrace?: number
    earlyLeavingMax?: number
    permissionAllowed?: boolean
    permissionMaxMins?: number
    permissionMaxOccur?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutLeavePoliciesInput
  }

  export type LeavePolicyUncheckedCreateWithoutLeaveTypesInput = {
    id?: string
    name: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    isDefault?: boolean
    schoolId: string
    lateComingGrace?: number
    lateComingMax?: number
    earlyLeavingGrace?: number
    earlyLeavingMax?: number
    permissionAllowed?: boolean
    permissionMaxMins?: number
    permissionMaxOccur?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeavePolicyCreateOrConnectWithoutLeaveTypesInput = {
    where: LeavePolicyWhereUniqueInput
    create: XOR<LeavePolicyCreateWithoutLeaveTypesInput, LeavePolicyUncheckedCreateWithoutLeaveTypesInput>
  }

  export type LeaveBalanceCreateWithoutLeaveTypeInput = {
    id?: string
    total: number
    used?: number
    pending?: number
    remaining: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveBalancesInput
  }

  export type LeaveBalanceUncheckedCreateWithoutLeaveTypeInput = {
    id?: string
    total: number
    used?: number
    pending?: number
    remaining: number
    userId: string
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceCreateOrConnectWithoutLeaveTypeInput = {
    where: LeaveBalanceWhereUniqueInput
    create: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeavePolicyUpsertWithoutLeaveTypesInput = {
    update: XOR<LeavePolicyUpdateWithoutLeaveTypesInput, LeavePolicyUncheckedUpdateWithoutLeaveTypesInput>
    create: XOR<LeavePolicyCreateWithoutLeaveTypesInput, LeavePolicyUncheckedCreateWithoutLeaveTypesInput>
    where?: LeavePolicyWhereInput
  }

  export type LeavePolicyUpdateToOneWithWhereWithoutLeaveTypesInput = {
    where?: LeavePolicyWhereInput
    data: XOR<LeavePolicyUpdateWithoutLeaveTypesInput, LeavePolicyUncheckedUpdateWithoutLeaveTypesInput>
  }

  export type LeavePolicyUpdateWithoutLeaveTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutLeavePoliciesNestedInput
  }

  export type LeavePolicyUncheckedUpdateWithoutLeaveTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveBalanceWhereUniqueInput
    update: XOR<LeaveBalanceUpdateWithoutLeaveTypeInput, LeaveBalanceUncheckedUpdateWithoutLeaveTypeInput>
    create: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveBalanceWhereUniqueInput
    data: XOR<LeaveBalanceUpdateWithoutLeaveTypeInput, LeaveBalanceUncheckedUpdateWithoutLeaveTypeInput>
  }

  export type LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput = {
    where: LeaveBalanceScalarWhereInput
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeInput>
  }

  export type UserCreateWithoutLeaveBalancesInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    school?: SchoolCreateNestedOneWithoutUsersInput
    managedClassrooms?: ClassroomCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaveBalancesInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId?: string | null
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    managedClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceUncheckedCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaveBalancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
  }

  export type LeaveTypeCreateWithoutLeaveBalancesInput = {
    id?: string
    name: string
    code: string
    totalDays: number
    canCarryForward?: boolean
    maxCarryForward?: number
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: number
    requiresApproval?: boolean
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: LeavePolicyCreateNestedOneWithoutLeaveTypesInput
  }

  export type LeaveTypeUncheckedCreateWithoutLeaveBalancesInput = {
    id?: string
    name: string
    code: string
    totalDays: number
    canCarryForward?: boolean
    maxCarryForward?: number
    isPaid?: boolean
    allowHalfDay?: boolean
    minNoticePeriod?: number
    requiresApproval?: boolean
    gender?: string | null
    policyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveTypeCreateOrConnectWithoutLeaveBalancesInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutLeaveBalancesInput, LeaveTypeUncheckedCreateWithoutLeaveBalancesInput>
  }

  export type UserUpsertWithoutLeaveBalancesInput = {
    update: XOR<UserUpdateWithoutLeaveBalancesInput, UserUncheckedUpdateWithoutLeaveBalancesInput>
    create: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveBalancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveBalancesInput, UserUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type UserUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    school?: SchoolUpdateOneWithoutUsersNestedInput
    managedClassrooms?: ClassroomUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    managedClassrooms?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUncheckedUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LeaveTypeUpsertWithoutLeaveBalancesInput = {
    update: XOR<LeaveTypeUpdateWithoutLeaveBalancesInput, LeaveTypeUncheckedUpdateWithoutLeaveBalancesInput>
    create: XOR<LeaveTypeCreateWithoutLeaveBalancesInput, LeaveTypeUncheckedCreateWithoutLeaveBalancesInput>
    where?: LeaveTypeWhereInput
  }

  export type LeaveTypeUpdateToOneWithWhereWithoutLeaveBalancesInput = {
    where?: LeaveTypeWhereInput
    data: XOR<LeaveTypeUpdateWithoutLeaveBalancesInput, LeaveTypeUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type LeaveTypeUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: LeavePolicyUpdateOneRequiredWithoutLeaveTypesNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    policyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSalaryRevisionsInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    school?: SchoolCreateNestedOneWithoutUsersInput
    managedClassrooms?: ClassroomCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalaryRevisionsInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId?: string | null
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    managedClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceUncheckedCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalaryRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryRevisionsInput, UserUncheckedCreateWithoutSalaryRevisionsInput>
  }

  export type UserUpsertWithoutSalaryRevisionsInput = {
    update: XOR<UserUpdateWithoutSalaryRevisionsInput, UserUncheckedUpdateWithoutSalaryRevisionsInput>
    create: XOR<UserCreateWithoutSalaryRevisionsInput, UserUncheckedCreateWithoutSalaryRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryRevisionsInput, UserUncheckedUpdateWithoutSalaryRevisionsInput>
  }

  export type UserUpdateWithoutSalaryRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    school?: SchoolUpdateOneWithoutUsersNestedInput
    managedClassrooms?: ClassroomUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    managedClassrooms?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUncheckedUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolCreateWithoutClassroomsInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassroomsInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassroomsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassroomsInput, SchoolUncheckedCreateWithoutClassroomsInput>
  }

  export type UserCreateWithoutManagedClassroomsInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    school?: SchoolCreateNestedOneWithoutUsersInput
    staffAttendance?: StaffAttendanceCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagedClassroomsInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId?: string | null
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    staffAttendance?: StaffAttendanceUncheckedCreateNestedManyWithoutUserInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagedClassroomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedClassroomsInput, UserUncheckedCreateWithoutManagedClassroomsInput>
  }

  export type StudentCreateWithoutClassroomInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentsInput
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    reports?: ReportCardCreateNestedManyWithoutStudentInput
    fees?: FeeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassroomInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    reports?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    fees?: FeeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassroomInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassroomInput, StudentUncheckedCreateWithoutClassroomInput>
  }

  export type SchoolUpsertWithoutClassroomsInput = {
    update: XOR<SchoolUpdateWithoutClassroomsInput, SchoolUncheckedUpdateWithoutClassroomsInput>
    create: XOR<SchoolCreateWithoutClassroomsInput, SchoolUncheckedCreateWithoutClassroomsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassroomsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassroomsInput, SchoolUncheckedUpdateWithoutClassroomsInput>
  }

  export type SchoolUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserUpsertWithoutManagedClassroomsInput = {
    update: XOR<UserUpdateWithoutManagedClassroomsInput, UserUncheckedUpdateWithoutManagedClassroomsInput>
    create: XOR<UserCreateWithoutManagedClassroomsInput, UserUncheckedCreateWithoutManagedClassroomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedClassroomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedClassroomsInput, UserUncheckedUpdateWithoutManagedClassroomsInput>
  }

  export type UserUpdateWithoutManagedClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    school?: SchoolUpdateOneWithoutUsersNestedInput
    staffAttendance?: StaffAttendanceUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    staffAttendance?: StaffAttendanceUncheckedUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutClassroomInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassroomInput, StudentUncheckedUpdateWithoutClassroomInput>
    create: XOR<StudentCreateWithoutClassroomInput, StudentUncheckedCreateWithoutClassroomInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassroomInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassroomInput, StudentUncheckedUpdateWithoutClassroomInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassroomInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassroomInput>
  }

  export type ClassroomCreateWithoutStudentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutManagedClassroomsInput
  }

  export type ClassroomUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    schoolId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCreateOrConnectWithoutStudentsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput>
  }

  export type SchoolCreateWithoutStudentsInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStudentsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
  }

  export type AttendanceCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardCreateWithoutStudentInput = {
    id?: string
    term: string
    marks: string
    comments?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardUncheckedCreateWithoutStudentInput = {
    id?: string
    term: string
    marks: string
    comments?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardCreateOrConnectWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type FeeCreateWithoutStudentInput = {
    id?: string
    title: string
    amount: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type FeeUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    amount: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeeCreateOrConnectWithoutStudentInput = {
    where: FeeWhereUniqueInput
    create: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput>
  }

  export type ClassroomUpsertWithoutStudentsInput = {
    update: XOR<ClassroomUpdateWithoutStudentsInput, ClassroomUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutStudentsInput, ClassroomUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassroomUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutManagedClassroomsNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpsertWithoutStudentsInput = {
    update: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    notes?: StringNullableFilter<"Attendance"> | string | null
    studentId?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type ReportCardUpsertWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    update: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardUpdateWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    data: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
  }

  export type ReportCardUpdateManyWithWhereWithoutStudentInput = {
    where: ReportCardScalarWhereInput
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyWithoutStudentInput>
  }

  export type ReportCardScalarWhereInput = {
    AND?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    OR?: ReportCardScalarWhereInput[]
    NOT?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    id?: StringFilter<"ReportCard"> | string
    term?: StringFilter<"ReportCard"> | string
    marks?: StringFilter<"ReportCard"> | string
    comments?: StringNullableFilter<"ReportCard"> | string | null
    published?: BoolFilter<"ReportCard"> | boolean
    studentId?: StringFilter<"ReportCard"> | string
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
  }

  export type FeeUpsertWithWhereUniqueWithoutStudentInput = {
    where: FeeWhereUniqueInput
    update: XOR<FeeUpdateWithoutStudentInput, FeeUncheckedUpdateWithoutStudentInput>
    create: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput>
  }

  export type FeeUpdateWithWhereUniqueWithoutStudentInput = {
    where: FeeWhereUniqueInput
    data: XOR<FeeUpdateWithoutStudentInput, FeeUncheckedUpdateWithoutStudentInput>
  }

  export type FeeUpdateManyWithWhereWithoutStudentInput = {
    where: FeeScalarWhereInput
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyWithoutStudentInput>
  }

  export type FeeScalarWhereInput = {
    AND?: FeeScalarWhereInput | FeeScalarWhereInput[]
    OR?: FeeScalarWhereInput[]
    NOT?: FeeScalarWhereInput | FeeScalarWhereInput[]
    id?: StringFilter<"Fee"> | string
    title?: StringFilter<"Fee"> | string
    amount?: FloatFilter<"Fee"> | number
    dueDate?: DateTimeFilter<"Fee"> | Date | string
    status?: StringFilter<"Fee"> | string
    studentId?: StringFilter<"Fee"> | string
    createdAt?: DateTimeFilter<"Fee"> | Date | string
    updatedAt?: DateTimeFilter<"Fee"> | Date | string
  }

  export type StudentCreateWithoutFeesInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom?: ClassroomCreateNestedOneWithoutStudentsInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    reports?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFeesInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    classroomId?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    reports?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFeesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
  }

  export type FeePaymentCreateWithoutFeeInput = {
    id?: string
    amount: number
    date?: Date | string
    method: string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentUncheckedCreateWithoutFeeInput = {
    id?: string
    amount: number
    date?: Date | string
    method: string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentCreateOrConnectWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    create: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput>
  }

  export type StudentUpsertWithoutFeesInput = {
    update: XOR<StudentUpdateWithoutFeesInput, StudentUncheckedUpdateWithoutFeesInput>
    create: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFeesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFeesInput, StudentUncheckedUpdateWithoutFeesInput>
  }

  export type StudentUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneWithoutStudentsNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type FeePaymentUpsertWithWhereUniqueWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    update: XOR<FeePaymentUpdateWithoutFeeInput, FeePaymentUncheckedUpdateWithoutFeeInput>
    create: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput>
  }

  export type FeePaymentUpdateWithWhereUniqueWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    data: XOR<FeePaymentUpdateWithoutFeeInput, FeePaymentUncheckedUpdateWithoutFeeInput>
  }

  export type FeePaymentUpdateManyWithWhereWithoutFeeInput = {
    where: FeePaymentScalarWhereInput
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyWithoutFeeInput>
  }

  export type FeePaymentScalarWhereInput = {
    AND?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    OR?: FeePaymentScalarWhereInput[]
    NOT?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    id?: StringFilter<"FeePayment"> | string
    amount?: FloatFilter<"FeePayment"> | number
    date?: DateTimeFilter<"FeePayment"> | Date | string
    method?: StringFilter<"FeePayment"> | string
    reference?: StringNullableFilter<"FeePayment"> | string | null
    feeId?: StringFilter<"FeePayment"> | string
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeFilter<"FeePayment"> | Date | string
  }

  export type FeeCreateWithoutPaymentsInput = {
    id?: string
    title: string
    amount: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeesInput
  }

  export type FeeUncheckedCreateWithoutPaymentsInput = {
    id?: string
    title: string
    amount: number
    dueDate: Date | string
    status?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeCreateOrConnectWithoutPaymentsInput = {
    where: FeeWhereUniqueInput
    create: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
  }

  export type FeeUpsertWithoutPaymentsInput = {
    update: XOR<FeeUpdateWithoutPaymentsInput, FeeUncheckedUpdateWithoutPaymentsInput>
    create: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
    where?: FeeWhereInput
  }

  export type FeeUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: FeeWhereInput
    data: XOR<FeeUpdateWithoutPaymentsInput, FeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type FeeUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeesNestedInput
  }

  export type FeeUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutAttendanceInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom?: ClassroomCreateNestedOneWithoutStudentsInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    reports?: ReportCardCreateNestedManyWithoutStudentInput
    fees?: FeeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    classroomId?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    fees?: FeeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
  }

  export type StudentUpsertWithoutAttendanceInput = {
    update: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type StudentUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneWithoutStudentsNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    reports?: ReportCardUpdateManyWithoutStudentNestedInput
    fees?: FeeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    fees?: FeeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutReportsInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom?: ClassroomCreateNestedOneWithoutStudentsInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    fees?: FeeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutReportsInput = {
    id?: string
    firstName: string
    lastName: string
    avatar?: string | null
    age?: number | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    grade?: string | null
    status?: string
    parentName?: string | null
    parentMobile?: string | null
    parentEmail?: string | null
    bloodGroup?: string | null
    medicalConditions?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    classroomId?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    fees?: FeeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutReportsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutReportsInput, StudentUncheckedCreateWithoutReportsInput>
  }

  export type StudentUpsertWithoutReportsInput = {
    update: XOR<StudentUpdateWithoutReportsInput, StudentUncheckedUpdateWithoutReportsInput>
    create: XOR<StudentCreateWithoutReportsInput, StudentUncheckedCreateWithoutReportsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutReportsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutReportsInput, StudentUncheckedUpdateWithoutReportsInput>
  }

  export type StudentUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneWithoutStudentsNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    fees?: FeeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    fees?: FeeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SchoolCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSubscriptionInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSubscriptionInput, SchoolUncheckedCreateWithoutSubscriptionInput>
  }

  export type SchoolUpsertWithoutSubscriptionInput = {
    update: XOR<SchoolUpdateWithoutSubscriptionInput, SchoolUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SchoolCreateWithoutSubscriptionInput, SchoolUncheckedCreateWithoutSubscriptionInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSubscriptionInput, SchoolUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SchoolUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type MasterDataCreateWithoutChildrenInput = {
    id?: string
    type: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MasterDataCreateNestedOneWithoutChildrenInput
  }

  export type MasterDataUncheckedCreateWithoutChildrenInput = {
    id?: string
    type: string
    name: string
    code?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MasterDataCreateOrConnectWithoutChildrenInput = {
    where: MasterDataWhereUniqueInput
    create: XOR<MasterDataCreateWithoutChildrenInput, MasterDataUncheckedCreateWithoutChildrenInput>
  }

  export type MasterDataCreateWithoutParentInput = {
    id?: string
    type: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MasterDataCreateNestedManyWithoutParentInput
  }

  export type MasterDataUncheckedCreateWithoutParentInput = {
    id?: string
    type: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MasterDataUncheckedCreateNestedManyWithoutParentInput
  }

  export type MasterDataCreateOrConnectWithoutParentInput = {
    where: MasterDataWhereUniqueInput
    create: XOR<MasterDataCreateWithoutParentInput, MasterDataUncheckedCreateWithoutParentInput>
  }

  export type MasterDataUpsertWithoutChildrenInput = {
    update: XOR<MasterDataUpdateWithoutChildrenInput, MasterDataUncheckedUpdateWithoutChildrenInput>
    create: XOR<MasterDataCreateWithoutChildrenInput, MasterDataUncheckedCreateWithoutChildrenInput>
    where?: MasterDataWhereInput
  }

  export type MasterDataUpdateToOneWithWhereWithoutChildrenInput = {
    where?: MasterDataWhereInput
    data: XOR<MasterDataUpdateWithoutChildrenInput, MasterDataUncheckedUpdateWithoutChildrenInput>
  }

  export type MasterDataUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MasterDataUpdateOneWithoutChildrenNestedInput
  }

  export type MasterDataUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterDataUpsertWithWhereUniqueWithoutParentInput = {
    where: MasterDataWhereUniqueInput
    update: XOR<MasterDataUpdateWithoutParentInput, MasterDataUncheckedUpdateWithoutParentInput>
    create: XOR<MasterDataCreateWithoutParentInput, MasterDataUncheckedCreateWithoutParentInput>
  }

  export type MasterDataUpdateWithWhereUniqueWithoutParentInput = {
    where: MasterDataWhereUniqueInput
    data: XOR<MasterDataUpdateWithoutParentInput, MasterDataUncheckedUpdateWithoutParentInput>
  }

  export type MasterDataUpdateManyWithWhereWithoutParentInput = {
    where: MasterDataScalarWhereInput
    data: XOR<MasterDataUpdateManyMutationInput, MasterDataUncheckedUpdateManyWithoutParentInput>
  }

  export type MasterDataScalarWhereInput = {
    AND?: MasterDataScalarWhereInput | MasterDataScalarWhereInput[]
    OR?: MasterDataScalarWhereInput[]
    NOT?: MasterDataScalarWhereInput | MasterDataScalarWhereInput[]
    id?: StringFilter<"MasterData"> | string
    type?: StringFilter<"MasterData"> | string
    name?: StringFilter<"MasterData"> | string
    code?: StringNullableFilter<"MasterData"> | string | null
    parentId?: StringNullableFilter<"MasterData"> | string | null
    createdAt?: DateTimeFilter<"MasterData"> | Date | string
    updatedAt?: DateTimeFilter<"MasterData"> | Date | string
  }

  export type UserCreateWithoutStaffAttendanceInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    school?: SchoolCreateNestedOneWithoutUsersInput
    managedClassrooms?: ClassroomCreateNestedManyWithoutTeacherInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffAttendanceInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId?: string | null
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    managedClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffAttendanceInput, UserUncheckedCreateWithoutStaffAttendanceInput>
  }

  export type StaffPunchCreateWithoutAttendanceInput = {
    id?: string
    type: string
    timestamp?: Date | string
  }

  export type StaffPunchUncheckedCreateWithoutAttendanceInput = {
    id?: string
    type: string
    timestamp?: Date | string
  }

  export type StaffPunchCreateOrConnectWithoutAttendanceInput = {
    where: StaffPunchWhereUniqueInput
    create: XOR<StaffPunchCreateWithoutAttendanceInput, StaffPunchUncheckedCreateWithoutAttendanceInput>
  }

  export type UserUpsertWithoutStaffAttendanceInput = {
    update: XOR<UserUpdateWithoutStaffAttendanceInput, UserUncheckedUpdateWithoutStaffAttendanceInput>
    create: XOR<UserCreateWithoutStaffAttendanceInput, UserUncheckedCreateWithoutStaffAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffAttendanceInput, UserUncheckedUpdateWithoutStaffAttendanceInput>
  }

  export type UserUpdateWithoutStaffAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    school?: SchoolUpdateOneWithoutUsersNestedInput
    managedClassrooms?: ClassroomUpdateManyWithoutTeacherNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    managedClassrooms?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StaffPunchUpsertWithWhereUniqueWithoutAttendanceInput = {
    where: StaffPunchWhereUniqueInput
    update: XOR<StaffPunchUpdateWithoutAttendanceInput, StaffPunchUncheckedUpdateWithoutAttendanceInput>
    create: XOR<StaffPunchCreateWithoutAttendanceInput, StaffPunchUncheckedCreateWithoutAttendanceInput>
  }

  export type StaffPunchUpdateWithWhereUniqueWithoutAttendanceInput = {
    where: StaffPunchWhereUniqueInput
    data: XOR<StaffPunchUpdateWithoutAttendanceInput, StaffPunchUncheckedUpdateWithoutAttendanceInput>
  }

  export type StaffPunchUpdateManyWithWhereWithoutAttendanceInput = {
    where: StaffPunchScalarWhereInput
    data: XOR<StaffPunchUpdateManyMutationInput, StaffPunchUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type StaffPunchScalarWhereInput = {
    AND?: StaffPunchScalarWhereInput | StaffPunchScalarWhereInput[]
    OR?: StaffPunchScalarWhereInput[]
    NOT?: StaffPunchScalarWhereInput | StaffPunchScalarWhereInput[]
    id?: StringFilter<"StaffPunch"> | string
    type?: StringFilter<"StaffPunch"> | string
    timestamp?: DateTimeFilter<"StaffPunch"> | Date | string
    attendanceId?: StringFilter<"StaffPunch"> | string
  }

  export type StaffAttendanceCreateWithoutPunchesInput = {
    id?: string
    date: Date | string
    status?: string
    notes?: string | null
    totalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffAttendanceInput
  }

  export type StaffAttendanceUncheckedCreateWithoutPunchesInput = {
    id?: string
    date: Date | string
    status?: string
    notes?: string | null
    totalHours?: number | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffAttendanceCreateOrConnectWithoutPunchesInput = {
    where: StaffAttendanceWhereUniqueInput
    create: XOR<StaffAttendanceCreateWithoutPunchesInput, StaffAttendanceUncheckedCreateWithoutPunchesInput>
  }

  export type StaffAttendanceUpsertWithoutPunchesInput = {
    update: XOR<StaffAttendanceUpdateWithoutPunchesInput, StaffAttendanceUncheckedUpdateWithoutPunchesInput>
    create: XOR<StaffAttendanceCreateWithoutPunchesInput, StaffAttendanceUncheckedCreateWithoutPunchesInput>
    where?: StaffAttendanceWhereInput
  }

  export type StaffAttendanceUpdateToOneWithWhereWithoutPunchesInput = {
    where?: StaffAttendanceWhereInput
    data: XOR<StaffAttendanceUpdateWithoutPunchesInput, StaffAttendanceUncheckedUpdateWithoutPunchesInput>
  }

  export type StaffAttendanceUpdateWithoutPunchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffAttendanceNestedInput
  }

  export type StaffAttendanceUncheckedUpdateWithoutPunchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutLeaveRequestsInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    school?: SchoolCreateNestedOneWithoutUsersInput
    managedClassrooms?: ClassroomCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaveRequestsInput = {
    id?: string
    mobile: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    designation?: string | null
    department?: string | null
    joiningDate?: Date | string | null
    status?: string
    avatar?: string | null
    address?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId?: string | null
    documents?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    bloodGroup?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    addressCity?: string | null
    addressState?: string | null
    addressZip?: string | null
    addressCountry?: string | null
    qualifications?: string | null
    experience?: string | null
    employmentType?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    facebook?: string | null
    linkedin?: string | null
    twitter?: string | null
    instagram?: string | null
    managedClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    staffAttendance?: StaffAttendanceUncheckedCreateNestedManyWithoutUserInput
    salaryRevisions?: SalaryRevisionUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaveRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
  }

  export type UserUpsertWithoutLeaveRequestsInput = {
    update: XOR<UserUpdateWithoutLeaveRequestsInput, UserUncheckedUpdateWithoutLeaveRequestsInput>
    create: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveRequestsInput, UserUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type UserUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    school?: SchoolUpdateOneWithoutUsersNestedInput
    managedClassrooms?: ClassroomUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    managedClassrooms?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUncheckedUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolCreateWithoutFeeStructuresInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFeeStructuresInput = {
    id?: string
    name: string
    slug: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    latitude?: string | null
    longitude?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    motto?: string | null
    foundingYear?: string | null
    logo?: string | null
    brandColor?: string | null
    facebook?: string | null
    twitter?: string | null
    linkedin?: string | null
    instagram?: string | null
    youtube?: string | null
    currency?: string | null
    timezone?: string | null
    dateFormat?: string | null
    googleMapsApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutSchoolInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutSchoolInput
    leavePolicies?: LeavePolicyUncheckedCreateNestedManyWithoutSchoolInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFeeStructuresInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
  }

  export type FeeComponentCreateWithoutFeeStructureInput = {
    id?: string
    name: string
    amount: number
    currency?: string
    frequency: string
    dueDate?: Date | string | null
    dueDay?: number | null
    dueMonth?: number | null
    isOptional?: boolean
    isRefundable?: boolean
    midTermRule?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeComponentUncheckedCreateWithoutFeeStructureInput = {
    id?: string
    name: string
    amount: number
    currency?: string
    frequency: string
    dueDate?: Date | string | null
    dueDay?: number | null
    dueMonth?: number | null
    isOptional?: boolean
    isRefundable?: boolean
    midTermRule?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeComponentCreateOrConnectWithoutFeeStructureInput = {
    where: FeeComponentWhereUniqueInput
    create: XOR<FeeComponentCreateWithoutFeeStructureInput, FeeComponentUncheckedCreateWithoutFeeStructureInput>
  }

  export type SchoolUpsertWithoutFeeStructuresInput = {
    update: XOR<SchoolUpdateWithoutFeeStructuresInput, SchoolUncheckedUpdateWithoutFeeStructuresInput>
    create: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFeeStructuresInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFeeStructuresInput, SchoolUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type SchoolUpdateWithoutFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    foundingYear?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dateFormat?: NullableStringFieldUpdateOperationsInput | string | null
    googleMapsApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutSchoolNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutSchoolNestedInput
    leavePolicies?: LeavePolicyUncheckedUpdateManyWithoutSchoolNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type FeeComponentUpsertWithWhereUniqueWithoutFeeStructureInput = {
    where: FeeComponentWhereUniqueInput
    update: XOR<FeeComponentUpdateWithoutFeeStructureInput, FeeComponentUncheckedUpdateWithoutFeeStructureInput>
    create: XOR<FeeComponentCreateWithoutFeeStructureInput, FeeComponentUncheckedCreateWithoutFeeStructureInput>
  }

  export type FeeComponentUpdateWithWhereUniqueWithoutFeeStructureInput = {
    where: FeeComponentWhereUniqueInput
    data: XOR<FeeComponentUpdateWithoutFeeStructureInput, FeeComponentUncheckedUpdateWithoutFeeStructureInput>
  }

  export type FeeComponentUpdateManyWithWhereWithoutFeeStructureInput = {
    where: FeeComponentScalarWhereInput
    data: XOR<FeeComponentUpdateManyMutationInput, FeeComponentUncheckedUpdateManyWithoutFeeStructureInput>
  }

  export type FeeComponentScalarWhereInput = {
    AND?: FeeComponentScalarWhereInput | FeeComponentScalarWhereInput[]
    OR?: FeeComponentScalarWhereInput[]
    NOT?: FeeComponentScalarWhereInput | FeeComponentScalarWhereInput[]
    id?: StringFilter<"FeeComponent"> | string
    name?: StringFilter<"FeeComponent"> | string
    amount?: FloatFilter<"FeeComponent"> | number
    currency?: StringFilter<"FeeComponent"> | string
    frequency?: StringFilter<"FeeComponent"> | string
    dueDate?: DateTimeNullableFilter<"FeeComponent"> | Date | string | null
    dueDay?: IntNullableFilter<"FeeComponent"> | number | null
    dueMonth?: IntNullableFilter<"FeeComponent"> | number | null
    isOptional?: BoolFilter<"FeeComponent"> | boolean
    isRefundable?: BoolFilter<"FeeComponent"> | boolean
    midTermRule?: StringFilter<"FeeComponent"> | string
    feeStructureId?: StringFilter<"FeeComponent"> | string
    createdAt?: DateTimeFilter<"FeeComponent"> | Date | string
    updatedAt?: DateTimeFilter<"FeeComponent"> | Date | string
  }

  export type FeeStructureCreateWithoutComponentsInput = {
    id?: string
    name: string
    academicYear: string
    description?: string | null
    termConfig?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFeeStructuresInput
  }

  export type FeeStructureUncheckedCreateWithoutComponentsInput = {
    id?: string
    name: string
    academicYear: string
    description?: string | null
    termConfig?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeStructureCreateOrConnectWithoutComponentsInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutComponentsInput, FeeStructureUncheckedCreateWithoutComponentsInput>
  }

  export type FeeStructureUpsertWithoutComponentsInput = {
    update: XOR<FeeStructureUpdateWithoutComponentsInput, FeeStructureUncheckedUpdateWithoutComponentsInput>
    create: XOR<FeeStructureCreateWithoutComponentsInput, FeeStructureUncheckedCreateWithoutComponentsInput>
    where?: FeeStructureWhereInput
  }

  export type FeeStructureUpdateToOneWithWhereWithoutComponentsInput = {
    where?: FeeStructureWhereInput
    data: XOR<FeeStructureUpdateWithoutComponentsInput, FeeStructureUncheckedUpdateWithoutComponentsInput>
  }

  export type FeeStructureUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFeeStructuresNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    managedClassrooms?: ClassroomUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    managedClassrooms?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    staffAttendance?: StaffAttendanceUncheckedUpdateManyWithoutUserNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    salaryRevisions?: SalaryRevisionUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    addressCity?: NullableStringFieldUpdateOperationsInput | string | null
    addressState?: NullableStringFieldUpdateOperationsInput | string | null
    addressZip?: NullableStringFieldUpdateOperationsInput | string | null
    addressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneWithoutStudentsNestedInput
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUpdateManyWithoutStudentNestedInput
    fees?: FeeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    fees?: FeeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneWithoutManagedClassroomsNestedInput
    students?: StudentUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentAge?: NullableIntFieldUpdateOperationsInput | number | null
    studentGender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentName?: StringFieldUpdateOperationsInput | string
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    officialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    enrolledGrade?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    admissionFormStep?: IntFieldUpdateOperationsInput | number
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentAge?: NullableIntFieldUpdateOperationsInput | number | null
    studentGender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentName?: StringFieldUpdateOperationsInput | string
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    officialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    enrolledGrade?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    admissionFormStep?: IntFieldUpdateOperationsInput | number
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentAge?: NullableIntFieldUpdateOperationsInput | number | null
    studentGender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentName?: StringFieldUpdateOperationsInput | string
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherEmail?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    officialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    enrolledGrade?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    admissionFormStep?: IntFieldUpdateOperationsInput | number
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTypes?: LeaveTypeUpdateManyWithoutPolicyNestedInput
  }

  export type LeavePolicyUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type LeavePolicyUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lateComingGrace?: IntFieldUpdateOperationsInput | number
    lateComingMax?: IntFieldUpdateOperationsInput | number
    earlyLeavingGrace?: IntFieldUpdateOperationsInput | number
    earlyLeavingMax?: IntFieldUpdateOperationsInput | number
    permissionAllowed?: BoolFieldUpdateOperationsInput | boolean
    permissionMaxMins?: IntFieldUpdateOperationsInput | number
    permissionMaxOccur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeStructureUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: FeeComponentUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: FeeComponentUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    termConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassroomsNestedInput
    students?: StudentUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    punches?: StaffPunchUpdateManyWithoutAttendanceNestedInput
  }

  export type StaffAttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    punches?: StaffPunchUncheckedUpdateManyWithoutAttendanceNestedInput
  }

  export type StaffAttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRevisionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    revisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    basic?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    allowance?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    pf?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRevisionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    revisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    basic?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    allowance?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    pf?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRevisionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    revisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    basic?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    allowance?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    pf?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveBalances?: LeaveBalanceUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateManyWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalDays?: FloatFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForward?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    minNoticePeriod?: IntFieldUpdateOperationsInput | number
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUpdateManyWithoutStudentNestedInput
    fees?: FeeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    reports?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    fees?: FeeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentMobile?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    marks?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    marks?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    marks?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterDataUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MasterDataUpdateManyWithoutParentNestedInput
  }

  export type MasterDataUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MasterDataUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MasterDataUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffPunchUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffPunchUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffPunchUncheckedUpdateManyWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeComponentUpdateWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueMonth?: NullableIntFieldUpdateOperationsInput | number | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    isRefundable?: BoolFieldUpdateOperationsInput | boolean
    midTermRule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeComponentUncheckedUpdateWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueMonth?: NullableIntFieldUpdateOperationsInput | number | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    isRefundable?: BoolFieldUpdateOperationsInput | boolean
    midTermRule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeComponentUncheckedUpdateManyWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueMonth?: NullableIntFieldUpdateOperationsInput | number | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    isRefundable?: BoolFieldUpdateOperationsInput | boolean
    midTermRule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeavePolicyCountOutputTypeDefaultArgs instead
     */
    export type LeavePolicyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeavePolicyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveTypeCountOutputTypeDefaultArgs instead
     */
    export type LeaveTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomCountOutputTypeDefaultArgs instead
     */
    export type ClassroomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeeCountOutputTypeDefaultArgs instead
     */
    export type FeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MasterDataCountOutputTypeDefaultArgs instead
     */
    export type MasterDataCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MasterDataCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffAttendanceCountOutputTypeDefaultArgs instead
     */
    export type StaffAttendanceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffAttendanceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeeStructureCountOutputTypeDefaultArgs instead
     */
    export type FeeStructureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeeStructureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolDefaultArgs instead
     */
    export type SchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionDefaultArgs instead
     */
    export type AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeavePolicyDefaultArgs instead
     */
    export type LeavePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeavePolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveTypeDefaultArgs instead
     */
    export type LeaveTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveBalanceDefaultArgs instead
     */
    export type LeaveBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveBalanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryRevisionDefaultArgs instead
     */
    export type SalaryRevisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryRevisionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomDefaultArgs instead
     */
    export type ClassroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeeDefaultArgs instead
     */
    export type FeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeePaymentDefaultArgs instead
     */
    export type FeePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeePaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceDefaultArgs instead
     */
    export type AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCardDefaultArgs instead
     */
    export type ReportCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtpDefaultArgs instead
     */
    export type OtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MasterDataDefaultArgs instead
     */
    export type MasterDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MasterDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffAttendanceDefaultArgs instead
     */
    export type StaffAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffAttendanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffPunchDefaultArgs instead
     */
    export type StaffPunchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffPunchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveRequestDefaultArgs instead
     */
    export type LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeeStructureDefaultArgs instead
     */
    export type FeeStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeeStructureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeeComponentDefaultArgs instead
     */
    export type FeeComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeeComponentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}